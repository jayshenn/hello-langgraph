# LangGraph é”™è¯¯ç å¯¹ç…§è¡¨

> ğŸš¨ **æ•…éšœæ’é™¤**ï¼šå¿«é€Ÿè¯Šæ–­å’Œè§£å†³ LangGraph å¸¸è§é”™è¯¯

## ğŸ“‹ é”™è¯¯åˆ†ç±»

- [å›¾ç»“æ„é”™è¯¯](#å›¾ç»“æ„é”™è¯¯)
- [çŠ¶æ€ç®¡ç†é”™è¯¯](#çŠ¶æ€ç®¡ç†é”™è¯¯)
- [æ‰§è¡Œæ—¶é”™è¯¯](#æ‰§è¡Œæ—¶é”™è¯¯)
- [å¹³å°ç›¸å…³é”™è¯¯](#å¹³å°ç›¸å…³é”™è¯¯)
- [é…ç½®é”™è¯¯](#é…ç½®é”™è¯¯)

---

## ğŸ—ï¸ å›¾ç»“æ„é”™è¯¯

### GRAPH_RECURSION_LIMIT

**é”™è¯¯æè¿°**ï¼šå›¾æ‰§è¡Œè¶…è¿‡é€’å½’é™åˆ¶ã€‚

**é”™è¯¯ä¿¡æ¯**ï¼š
```
GraphRecursionError: Exceeded maximum step limit of 25
```

**å¸¸è§åŸå› **ï¼š
- å›¾ä¸­å­˜åœ¨æ— é™å¾ªç¯
- æ¡ä»¶è¾¹æ²¡æœ‰æ­£ç¡®çš„ç»ˆæ­¢æ¡ä»¶
- é€’å½’æ·±åº¦è®¾ç½®è¿‡å°

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **æ£€æŸ¥å¾ªç¯é€»è¾‘**
```python
def router(state: MyState) -> str:
    # âŒ é”™è¯¯ï¼šæ²¡æœ‰ç»ˆæ­¢æ¡ä»¶
    if state["continue"]:
        return "loop_node"

    # âœ… æ­£ç¡®ï¼šæ·»åŠ è®¡æ•°å™¨é˜²æ­¢æ— é™å¾ªç¯
    if state["continue"] and state.get("step_count", 0) < 10:
        return "loop_node"
    else:
        return "end_node"
```

2. **å¢åŠ é€’å½’é™åˆ¶**
```python
# ç¼–è¯‘æ—¶è®¾ç½®æ›´å¤§çš„é™åˆ¶
app = graph.compile(
    recursion_limit=100  # é»˜è®¤æ˜¯ 25
)

# æˆ–è¿è¡Œæ—¶è®¾ç½®
config = {"recursion_limit": 100}
result = app.invoke(input_data, config=config)
```

3. **æ·»åŠ æ­¥æ•°è·Ÿè¸ª**
```python
class SafeState(TypedDict):
    step_count: int
    max_steps: int
    data: str

def increment_step(state: SafeState) -> SafeState:
    return {
        **state,
        "step_count": state.get("step_count", 0) + 1
    }

def check_limit(state: SafeState) -> str:
    if state.get("step_count", 0) >= state.get("max_steps", 25):
        return "force_end"
    return "continue"
```

---

### INVALID_CONCURRENT_GRAPH_UPDATE

**é”™è¯¯æè¿°**ï¼šå¤šä¸ªå¹¶è¡ŒèŠ‚ç‚¹è¯•å›¾æ›´æ–°åŒä¸€çŠ¶æ€å­—æ®µã€‚

**é”™è¯¯ä¿¡æ¯**ï¼š
```
InvalidUpdateError: Received multiple values for field 'result'
```

**å¸¸è§åŸå› **ï¼š
- å¹¶è¡ŒèŠ‚ç‚¹è¿”å›äº†ç›¸åŒçš„çŠ¶æ€é”®
- æ²¡æœ‰ä½¿ç”¨ reducer æ¥å¤„ç†å¹¶å‘æ›´æ–°

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **ä½¿ç”¨ Annotated å’Œ reducer**
```python
from typing import Annotated
from operator import add

class ParallelState(TypedDict):
    # âœ… ä½¿ç”¨ reducer åˆå¹¶å¹¶å‘æ›´æ–°
    results: Annotated[List[str], add]
    # æˆ–ä½¿ç”¨è‡ªå®šä¹‰ reducer
    scores: Annotated[List[int], lambda x, y: x + y]

def node1(state: ParallelState) -> ParallelState:
    return {"results": ["result1"]}

def node2(state: ParallelState) -> ParallelState:
    return {"results": ["result2"]}

# ä¸¤ä¸ªèŠ‚ç‚¹å¹¶è¡Œæ‰§è¡Œæ—¶ï¼Œresults ä¼šè¢«åˆå¹¶ä¸º ["result1", "result2"]
```

2. **é¿å…å­—æ®µå†²çª**
```python
class SafeParallelState(TypedDict):
    node1_result: str  # æ¯ä¸ªèŠ‚ç‚¹ä½¿ç”¨ç‹¬ç«‹çš„å­—æ®µ
    node2_result: str
    common_data: str   # å…±äº«çš„åªè¯»æ•°æ®

def node1(state: SafeParallelState) -> SafeParallelState:
    return {"node1_result": "å¤„ç†ç»“æœ1"}

def node2(state: SafeParallelState) -> SafeParallelState:
    return {"node2_result": "å¤„ç†ç»“æœ2"}
```

3. **ä½¿ç”¨ Send API**
```python
from langgraph.graph import Send

def fan_out(state: MyState) -> List[Send]:
    return [
        Send("process_item", {"item": item, "index": i})
        for i, item in enumerate(state["items"])
    ]

def process_item(state: Dict) -> Dict:
    # æ¯ä¸ª Send éƒ½æ˜¯ç‹¬ç«‹çš„æ‰§è¡Œ
    return {"result": f"å¤„ç† {state['item']}"}
```

---

### INVALID_GRAPH_NODE_RETURN_VALUE

**é”™è¯¯æè¿°**ï¼šèŠ‚ç‚¹å‡½æ•°è¿”å›äº†éå­—å…¸ç±»å‹çš„å€¼ã€‚

**é”™è¯¯ä¿¡æ¯**ï¼š
```
InvalidNodeReturn: Node 'my_node' returned non-dict value: <class 'str'>
```

**å¸¸è§åŸå› **ï¼š
- èŠ‚ç‚¹å‡½æ•°è¿”å›äº†å­—ç¬¦ä¸²ã€None æˆ–å…¶ä»–éå­—å…¸ç±»å‹
- å¿˜è®°è¿”å›çŠ¶æ€æ›´æ–°

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **ç¡®ä¿è¿”å›å­—å…¸**
```python
def good_node(state: MyState) -> MyState:
    # âœ… æ­£ç¡®ï¼šè¿”å›å­—å…¸
    return {"message": "å¤„ç†å®Œæˆ", "status": "success"}

def bad_node(state: MyState) -> str:
    # âŒ é”™è¯¯ï¼šè¿”å›å­—ç¬¦ä¸²
    return "å¤„ç†å®Œæˆ"

def another_bad_node(state: MyState) -> None:
    # âŒ é”™è¯¯ï¼šè¿”å› None
    print("å¤„ç†ä¸­...")
    # å¿˜è®°è¿”å›çŠ¶æ€
```

2. **ä½¿ç”¨çŠ¶æ€æ‰©å±•æ¨¡å¼**
```python
def safe_node(state: MyState) -> MyState:
    try:
        result = process_data(state["input"])
        # âœ… ä½¿ç”¨å±•å¼€è¿ç®—ç¬¦ä¿ç•™ç°æœ‰çŠ¶æ€
        return {**state, "result": result}
    except Exception as e:
        # âœ… é”™è¯¯å¤„ç†ä¹Ÿè¦è¿”å›å­—å…¸
        return {**state, "error": str(e)}
```

3. **éƒ¨åˆ†çŠ¶æ€æ›´æ–°**
```python
def partial_update_node(state: MyState) -> Dict[str, Any]:
    # âœ… åªè¿”å›éœ€è¦æ›´æ–°çš„å­—æ®µ
    return {
        "processed": True,
        "timestamp": datetime.now().isoformat()
    }
    # LangGraph ä¼šè‡ªåŠ¨åˆå¹¶åˆ°ç°æœ‰çŠ¶æ€
```

---

## ğŸ’¬ çŠ¶æ€ç®¡ç†é”™è¯¯

### INVALID_CHAT_HISTORY

**é”™è¯¯æè¿°**ï¼šä¼ é€’ç»™ create_react_agent çš„æ¶ˆæ¯æ ¼å¼é”™è¯¯ã€‚

**é”™è¯¯ä¿¡æ¯**ï¼š
```
ValueError: Invalid message format in chat history
```

**å¸¸è§åŸå› **ï¼š
- æ¶ˆæ¯åˆ—è¡¨æ ¼å¼ä¸æ­£ç¡®
- å·¥å…·è°ƒç”¨å’Œå·¥å…·å“åº”ä¸åŒ¹é…
- æ¶ˆæ¯ç¼ºå°‘å¿…è¦çš„å­—æ®µ

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **æ­£ç¡®çš„æ¶ˆæ¯æ ¼å¼**
```python
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage

# âœ… æ­£ç¡®çš„æ¶ˆæ¯æ ¼å¼
messages = [
    HumanMessage(content="æœç´¢Pythonæ•™ç¨‹"),
    AIMessage(
        content="",
        tool_calls=[{
            "id": "call_123",
            "name": "search",
            "args": {"query": "Pythonæ•™ç¨‹"}
        }]
    ),
    ToolMessage(
        content="æ‰¾åˆ°5ä¸ªPythonæ•™ç¨‹",
        tool_call_id="call_123"
    )
]

# âŒ é”™è¯¯ï¼šå·¥å…·è°ƒç”¨åæ²¡æœ‰å¯¹åº”çš„å·¥å…·æ¶ˆæ¯
bad_messages = [
    HumanMessage(content="æœç´¢Pythonæ•™ç¨‹"),
    AIMessage(
        content="",
        tool_calls=[{
            "id": "call_123",
            "name": "search",
            "args": {"query": "Pythonæ•™ç¨‹"}
        }]
    )
    # ç¼ºå°‘ ToolMessage
]
```

2. **ä½¿ç”¨é¢„æ„å»ºçš„ä»£ç†éªŒè¯æ¶ˆæ¯**
```python
from langgraph.prebuilt import create_react_agent

def validate_and_invoke(agent, messages):
    try:
        result = agent.invoke({"messages": messages})
        return result
    except ValueError as e:
        print(f"æ¶ˆæ¯æ ¼å¼é”™è¯¯: {e}")
        # æ¸…ç†æˆ–é‡æ–°æ„å»ºæ¶ˆæ¯å†å²
        return None
```

---

## ğŸ”„ æ‰§è¡Œæ—¶é”™è¯¯

### MULTIPLE_SUBGRAPHS

**é”™è¯¯æè¿°**ï¼šåœ¨å¯ç”¨æ£€æŸ¥ç‚¹çš„æƒ…å†µä¸‹ï¼Œå•ä¸ªèŠ‚ç‚¹è°ƒç”¨äº†å¤šä¸ªå­å›¾ã€‚

**é”™è¯¯ä¿¡æ¯**ï¼š
```
MultipleSubgraphsError: Cannot invoke multiple subgraphs from a single node when checkpointing is enabled
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **ä¸ä½¿ç”¨æ£€æŸ¥ç‚¹ç¼–è¯‘å­å›¾**
```python
# âœ… å­å›¾ä¸ä½¿ç”¨æ£€æŸ¥ç‚¹
subgraph1 = graph1.compile()  # ä¸ä¼  checkpointer
subgraph2 = graph2.compile()

def multi_subgraph_node(state: MyState) -> MyState:
    result1 = subgraph1.invoke({"input": state["data1"]})
    result2 = subgraph2.invoke({"input": state["data2"]})
    return {**state, "results": [result1, result2]}
```

2. **ä½¿ç”¨ Send API**
```python
from langgraph.graph import Send

def fan_out_to_subgraphs(state: MyState) -> List[Send]:
    return [
        Send("subgraph1_node", {"data": state["data1"]}),
        Send("subgraph2_node", {"data": state["data2"]})
    ]

def subgraph1_node(state: Dict) -> Dict:
    return subgraph1.invoke(state)

def subgraph2_node(state: Dict) -> Dict:
    return subgraph2.invoke(state)
```

3. **é‡æ„ä¸ºå•ä¸ªå­å›¾**
```python
# å°†å¤šä¸ªå­å›¾é€»è¾‘åˆå¹¶åˆ°ä¸€ä¸ªå­å›¾ä¸­
def combined_subgraph_node(state: MyState) -> MyState:
    # åœ¨ä¸€ä¸ªå­å›¾ä¸­å¤„ç†æ‰€æœ‰é€»è¾‘
    combined_result = combined_subgraph.invoke({
        "data1": state["data1"],
        "data2": state["data2"]
    })
    return {**state, "combined_result": combined_result}
```

---

## ğŸ¢ å¹³å°ç›¸å…³é”™è¯¯

### INVALID_LICENSE

**é”™è¯¯æè¿°**ï¼šè‡ªæ‰˜ç®¡ LangGraph Platform æ—¶è®¸å¯è¯æ— æ•ˆã€‚

**é”™è¯¯ä¿¡æ¯**ï¼š
```
LicenseError: Invalid or expired license key
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **æ£€æŸ¥ç¯å¢ƒå˜é‡**
```bash
# ç¡®ä¿è®¾ç½®äº†æ­£ç¡®çš„è®¸å¯è¯
export LANGGRAPH_LICENSE_KEY="your-license-key"

# æˆ–åœ¨ Docker ä¸­
docker run -e LANGGRAPH_LICENSE_KEY="your-license-key" langgraph-server
```

2. **éªŒè¯è®¸å¯è¯æ ¼å¼**
```python
import os

license_key = os.getenv("LANGGRAPH_LICENSE_KEY")
if not license_key:
    raise ValueError("Missing LANGGRAPH_LICENSE_KEY")

if not license_key.startswith("lsv2_"):
    raise ValueError("Invalid license key format")
```

3. **è”ç³»æ”¯æŒè·å–æ–°è®¸å¯è¯**
```bash
# å¦‚æœè®¸å¯è¯è¿‡æœŸï¼Œè”ç³» LangChain æ”¯æŒ
# æˆ–æ£€æŸ¥ LangSmith æ§åˆ¶å°è·å–æœ€æ–°è®¸å¯è¯
```

---

## âš™ï¸ é…ç½®é”™è¯¯

### CONNECTION_ERROR

**é”™è¯¯æè¿°**ï¼šæ— æ³•è¿æ¥åˆ° LangGraph Platform æˆ– LLM æœåŠ¡ã€‚

**å¸¸è§è§£å†³æ–¹æ¡ˆ**ï¼š

1. **æ£€æŸ¥ç½‘ç»œè¿æ¥**
```python
import requests

def check_connection(url: str) -> bool:
    try:
        response = requests.get(url, timeout=10)
        return response.status_code == 200
    except requests.RequestException:
        return False

# æ£€æŸ¥ LangGraph Platform
if not check_connection("https://api.langgraph.dev/health"):
    print("æ— æ³•è¿æ¥åˆ° LangGraph Platform")

# æ£€æŸ¥ OpenAI API
if not check_connection("https://api.openai.com/v1/models"):
    print("æ— æ³•è¿æ¥åˆ° OpenAI API")
```

2. **éªŒè¯ API å¯†é’¥**
```python
import openai
from openai import OpenAI

def validate_openai_key(api_key: str) -> bool:
    try:
        client = OpenAI(api_key=api_key)
        client.models.list()
        return True
    except Exception as e:
        print(f"API å¯†é’¥éªŒè¯å¤±è´¥: {e}")
        return False
```

3. **é…ç½®ä»£ç†å’Œè¶…æ—¶**
```python
from langchain_openai import ChatOpenAI

# é…ç½®ä»£ç†
model = ChatOpenAI(
    model="gpt-4",
    timeout=30,
    max_retries=3,
    openai_proxy="http://proxy.company.com:8080"
)
```

---

## ğŸ› è°ƒè¯•æŠ€å·§

### å¯ç”¨è¯¦ç»†æ—¥å¿—

```python
import logging

# å¯ç”¨ LangGraph è°ƒè¯•æ—¥å¿—
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("langgraph")
logger.setLevel(logging.DEBUG)

# åœ¨èŠ‚ç‚¹ä¸­æ·»åŠ è°ƒè¯•ä¿¡æ¯
def debug_node(state: MyState) -> MyState:
    logger.debug(f"èŠ‚ç‚¹è¾“å…¥: {state}")
    result = process(state)
    logger.debug(f"èŠ‚ç‚¹è¾“å‡º: {result}")
    return result
```

### ä½¿ç”¨å›¾å¯è§†åŒ–

```python
# å¯è§†åŒ–å›¾ç»“æ„
try:
    from IPython.display import Image, display
    display(Image(app.get_graph().draw_mermaid_png()))
except Exception:
    # å¦‚æœæ— æ³•æ˜¾ç¤ºå›¾ç‰‡ï¼Œæ‰“å° Mermaid ä»£ç 
    print(app.get_graph().draw_mermaid())
```

### æ­¥è¿›è°ƒè¯•

```python
# ä½¿ç”¨æ–­ç‚¹è¿›è¡Œè°ƒè¯•
app = graph.compile(
    interrupt_before=["problematic_node"],
    debug=True
)

# æ‰§è¡Œåˆ°æ–­ç‚¹
result = app.invoke(input_data, config={"thread_id": "debug"})

# æ£€æŸ¥çŠ¶æ€
state = app.get_state(config={"thread_id": "debug"})
print(f"å½“å‰çŠ¶æ€: {state}")

# ç»§ç»­æ‰§è¡Œ
result = app.invoke(None, config={"thread_id": "debug"})
```

---

## ğŸ”— ç›¸å…³èµ„æº

- ğŸ“– [å®˜æ–¹é”™è¯¯å‚è€ƒ](https://langchain-ai.github.io/langgraph/troubleshooting/errors/)
- ğŸš€ [API é€ŸæŸ¥è¡¨](./APIé€ŸæŸ¥.md)
- ğŸ’¡ [ä»£ç ç‰‡æ®µåº“](./ä»£ç ç‰‡æ®µ.md)
- â“ [å¸¸è§é—®é¢˜ FAQ](./FAQ.md)
- ğŸ› ï¸ [LangGraph Studio è°ƒè¯•æŒ‡å—](../06-å¼€å‘å®è·µ/01-è°ƒè¯•æŠ€å·§.md)

---

*é‡åˆ°å…¶ä»–é”™è¯¯ï¼Ÿæ¬¢è¿æäº¤ Issue æˆ–æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£ï¼* ğŸ¤
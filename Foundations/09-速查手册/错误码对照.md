# LangGraph 错误码对照表

> 🚨 **故障排除**：快速诊断和解决 LangGraph 常见错误

## 📋 错误分类

- [图结构错误](#图结构错误)
- [状态管理错误](#状态管理错误)
- [执行时错误](#执行时错误)
- [平台相关错误](#平台相关错误)
- [配置错误](#配置错误)

---

## 🏗️ 图结构错误

### GRAPH_RECURSION_LIMIT

**错误描述**：图执行超过递归限制。

**错误信息**：
```
GraphRecursionError: Exceeded maximum step limit of 25
```

**常见原因**：
- 图中存在无限循环
- 条件边没有正确的终止条件
- 递归深度设置过小

**解决方案**：

1. **检查循环逻辑**
```python
def router(state: MyState) -> str:
    # ❌ 错误：没有终止条件
    if state["continue"]:
        return "loop_node"

    # ✅ 正确：添加计数器防止无限循环
    if state["continue"] and state.get("step_count", 0) < 10:
        return "loop_node"
    else:
        return "end_node"
```

2. **增加递归限制**
```python
# 编译时设置更大的限制
app = graph.compile(
    recursion_limit=100  # 默认是 25
)

# 或运行时设置
config = {"recursion_limit": 100}
result = app.invoke(input_data, config=config)
```

3. **添加步数跟踪**
```python
class SafeState(TypedDict):
    step_count: int
    max_steps: int
    data: str

def increment_step(state: SafeState) -> SafeState:
    return {
        **state,
        "step_count": state.get("step_count", 0) + 1
    }

def check_limit(state: SafeState) -> str:
    if state.get("step_count", 0) >= state.get("max_steps", 25):
        return "force_end"
    return "continue"
```

---

### INVALID_CONCURRENT_GRAPH_UPDATE

**错误描述**：多个并行节点试图更新同一状态字段。

**错误信息**：
```
InvalidUpdateError: Received multiple values for field 'result'
```

**常见原因**：
- 并行节点返回了相同的状态键
- 没有使用 reducer 来处理并发更新

**解决方案**：

1. **使用 Annotated 和 reducer**
```python
from typing import Annotated
from operator import add

class ParallelState(TypedDict):
    # ✅ 使用 reducer 合并并发更新
    results: Annotated[List[str], add]
    # 或使用自定义 reducer
    scores: Annotated[List[int], lambda x, y: x + y]

def node1(state: ParallelState) -> ParallelState:
    return {"results": ["result1"]}

def node2(state: ParallelState) -> ParallelState:
    return {"results": ["result2"]}

# 两个节点并行执行时，results 会被合并为 ["result1", "result2"]
```

2. **避免字段冲突**
```python
class SafeParallelState(TypedDict):
    node1_result: str  # 每个节点使用独立的字段
    node2_result: str
    common_data: str   # 共享的只读数据

def node1(state: SafeParallelState) -> SafeParallelState:
    return {"node1_result": "处理结果1"}

def node2(state: SafeParallelState) -> SafeParallelState:
    return {"node2_result": "处理结果2"}
```

3. **使用 Send API**
```python
from langgraph.graph import Send

def fan_out(state: MyState) -> List[Send]:
    return [
        Send("process_item", {"item": item, "index": i})
        for i, item in enumerate(state["items"])
    ]

def process_item(state: Dict) -> Dict:
    # 每个 Send 都是独立的执行
    return {"result": f"处理 {state['item']}"}
```

---

### INVALID_GRAPH_NODE_RETURN_VALUE

**错误描述**：节点函数返回了非字典类型的值。

**错误信息**：
```
InvalidNodeReturn: Node 'my_node' returned non-dict value: <class 'str'>
```

**常见原因**：
- 节点函数返回了字符串、None 或其他非字典类型
- 忘记返回状态更新

**解决方案**：

1. **确保返回字典**
```python
def good_node(state: MyState) -> MyState:
    # ✅ 正确：返回字典
    return {"message": "处理完成", "status": "success"}

def bad_node(state: MyState) -> str:
    # ❌ 错误：返回字符串
    return "处理完成"

def another_bad_node(state: MyState) -> None:
    # ❌ 错误：返回 None
    print("处理中...")
    # 忘记返回状态
```

2. **使用状态扩展模式**
```python
def safe_node(state: MyState) -> MyState:
    try:
        result = process_data(state["input"])
        # ✅ 使用展开运算符保留现有状态
        return {**state, "result": result}
    except Exception as e:
        # ✅ 错误处理也要返回字典
        return {**state, "error": str(e)}
```

3. **部分状态更新**
```python
def partial_update_node(state: MyState) -> Dict[str, Any]:
    # ✅ 只返回需要更新的字段
    return {
        "processed": True,
        "timestamp": datetime.now().isoformat()
    }
    # LangGraph 会自动合并到现有状态
```

---

## 💬 状态管理错误

### INVALID_CHAT_HISTORY

**错误描述**：传递给 create_react_agent 的消息格式错误。

**错误信息**：
```
ValueError: Invalid message format in chat history
```

**常见原因**：
- 消息列表格式不正确
- 工具调用和工具响应不匹配
- 消息缺少必要的字段

**解决方案**：

1. **正确的消息格式**
```python
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage

# ✅ 正确的消息格式
messages = [
    HumanMessage(content="搜索Python教程"),
    AIMessage(
        content="",
        tool_calls=[{
            "id": "call_123",
            "name": "search",
            "args": {"query": "Python教程"}
        }]
    ),
    ToolMessage(
        content="找到5个Python教程",
        tool_call_id="call_123"
    )
]

# ❌ 错误：工具调用后没有对应的工具消息
bad_messages = [
    HumanMessage(content="搜索Python教程"),
    AIMessage(
        content="",
        tool_calls=[{
            "id": "call_123",
            "name": "search",
            "args": {"query": "Python教程"}
        }]
    )
    # 缺少 ToolMessage
]
```

2. **使用预构建的代理验证消息**
```python
from langgraph.prebuilt import create_react_agent

def validate_and_invoke(agent, messages):
    try:
        result = agent.invoke({"messages": messages})
        return result
    except ValueError as e:
        print(f"消息格式错误: {e}")
        # 清理或重新构建消息历史
        return None
```

---

## 🔄 执行时错误

### MULTIPLE_SUBGRAPHS

**错误描述**：在启用检查点的情况下，单个节点调用了多个子图。

**错误信息**：
```
MultipleSubgraphsError: Cannot invoke multiple subgraphs from a single node when checkpointing is enabled
```

**解决方案**：

1. **不使用检查点编译子图**
```python
# ✅ 子图不使用检查点
subgraph1 = graph1.compile()  # 不传 checkpointer
subgraph2 = graph2.compile()

def multi_subgraph_node(state: MyState) -> MyState:
    result1 = subgraph1.invoke({"input": state["data1"]})
    result2 = subgraph2.invoke({"input": state["data2"]})
    return {**state, "results": [result1, result2]}
```

2. **使用 Send API**
```python
from langgraph.graph import Send

def fan_out_to_subgraphs(state: MyState) -> List[Send]:
    return [
        Send("subgraph1_node", {"data": state["data1"]}),
        Send("subgraph2_node", {"data": state["data2"]})
    ]

def subgraph1_node(state: Dict) -> Dict:
    return subgraph1.invoke(state)

def subgraph2_node(state: Dict) -> Dict:
    return subgraph2.invoke(state)
```

3. **重构为单个子图**
```python
# 将多个子图逻辑合并到一个子图中
def combined_subgraph_node(state: MyState) -> MyState:
    # 在一个子图中处理所有逻辑
    combined_result = combined_subgraph.invoke({
        "data1": state["data1"],
        "data2": state["data2"]
    })
    return {**state, "combined_result": combined_result}
```

---

## 🏢 平台相关错误

### INVALID_LICENSE

**错误描述**：自托管 LangGraph Platform 时许可证无效。

**错误信息**：
```
LicenseError: Invalid or expired license key
```

**解决方案**：

1. **检查环境变量**
```bash
# 确保设置了正确的许可证
export LANGGRAPH_LICENSE_KEY="your-license-key"

# 或在 Docker 中
docker run -e LANGGRAPH_LICENSE_KEY="your-license-key" langgraph-server
```

2. **验证许可证格式**
```python
import os

license_key = os.getenv("LANGGRAPH_LICENSE_KEY")
if not license_key:
    raise ValueError("Missing LANGGRAPH_LICENSE_KEY")

if not license_key.startswith("lsv2_"):
    raise ValueError("Invalid license key format")
```

3. **联系支持获取新许可证**
```bash
# 如果许可证过期，联系 LangChain 支持
# 或检查 LangSmith 控制台获取最新许可证
```

---

## ⚙️ 配置错误

### CONNECTION_ERROR

**错误描述**：无法连接到 LangGraph Platform 或 LLM 服务。

**常见解决方案**：

1. **检查网络连接**
```python
import requests

def check_connection(url: str) -> bool:
    try:
        response = requests.get(url, timeout=10)
        return response.status_code == 200
    except requests.RequestException:
        return False

# 检查 LangGraph Platform
if not check_connection("https://api.langgraph.dev/health"):
    print("无法连接到 LangGraph Platform")

# 检查 OpenAI API
if not check_connection("https://api.openai.com/v1/models"):
    print("无法连接到 OpenAI API")
```

2. **验证 API 密钥**
```python
import openai
from openai import OpenAI

def validate_openai_key(api_key: str) -> bool:
    try:
        client = OpenAI(api_key=api_key)
        client.models.list()
        return True
    except Exception as e:
        print(f"API 密钥验证失败: {e}")
        return False
```

3. **配置代理和超时**
```python
from langchain_openai import ChatOpenAI

# 配置代理
model = ChatOpenAI(
    model="gpt-4",
    timeout=30,
    max_retries=3,
    openai_proxy="http://proxy.company.com:8080"
)
```

---

## 🐛 调试技巧

### 启用详细日志

```python
import logging

# 启用 LangGraph 调试日志
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("langgraph")
logger.setLevel(logging.DEBUG)

# 在节点中添加调试信息
def debug_node(state: MyState) -> MyState:
    logger.debug(f"节点输入: {state}")
    result = process(state)
    logger.debug(f"节点输出: {result}")
    return result
```

### 使用图可视化

```python
# 可视化图结构
try:
    from IPython.display import Image, display
    display(Image(app.get_graph().draw_mermaid_png()))
except Exception:
    # 如果无法显示图片，打印 Mermaid 代码
    print(app.get_graph().draw_mermaid())
```

### 步进调试

```python
# 使用断点进行调试
app = graph.compile(
    interrupt_before=["problematic_node"],
    debug=True
)

# 执行到断点
result = app.invoke(input_data, config={"thread_id": "debug"})

# 检查状态
state = app.get_state(config={"thread_id": "debug"})
print(f"当前状态: {state}")

# 继续执行
result = app.invoke(None, config={"thread_id": "debug"})
```

---

## 🔗 相关资源

- 📖 [官方错误参考](https://langchain-ai.github.io/langgraph/troubleshooting/errors/)
- 🚀 [API 速查表](./API速查.md)
- 💡 [代码片段库](./代码片段.md)
- ❓ [常见问题 FAQ](./FAQ.md)
- 🛠️ [LangGraph Studio 调试指南](../06-开发实践/01-调试技巧.md)

---

*遇到其他错误？欢迎提交 Issue 或查看官方文档！* 🤝
# Python 类型系统基础

> 🎯 **学习目标**：理解 Python 类型注解的基本概念，为学习 LangGraph 的 AgentState 打下基础

## 📖 为什么需要类型注解？

在 LangGraph 中，我们经常看到这样的代码：

```python
from typing import TypedDict

class AgentState(TypedDict):
    message: str
    count: int
```

这里的 `str` 和 `int` 就是**类型注解**。让我们从最基础的概念开始理解。

## 🔤 基础类型注解

### 简单类型

```python
# 基础数据类型
name: str = "Alice"
age: int = 25
height: float = 1.75
is_student: bool = True

# 函数类型注解
def greet(name: str) -> str:
    return f"Hello, {name}!"

# 调用函数
message = greet("Bob")  # message 的类型是 str
```

### 容器类型

```python
from typing import List, Dict, Optional

# 列表类型
names: List[str] = ["Alice", "Bob", "Charlie"]
scores: List[int] = [85, 92, 78]

# 字典类型
student_grades: Dict[str, int] = {
    "Alice": 85,
    "Bob": 92,
    "Charlie": 78
}

# 可选类型（可能是 None）
middle_name: Optional[str] = None  # 相当于 Union[str, None]
```

## 🎯 为什么 LangGraph 偏爱类型注解？

### 1. 代码可读性

**没有类型注解的代码：**
```python
def process_user_input(data):
    # 😕 不知道 data 是什么类型
    # 不知道返回什么类型
    result = data["message"] + " processed"
    return {"response": result, "count": len(result)}
```

**有类型注解的代码：**
```python
from typing import Dict

def process_user_input(data: Dict[str, str]) -> Dict[str, any]:
    # ✅ 清楚知道 data 是字符串字典
    # ✅ 清楚知道返回字典类型
    result = data["message"] + " processed"
    return {"response": result, "count": len(result)}
```

### 2. 错误预防

```python
# 错误的调用
age = "25"  # 字符串而不是数字
# process_age(age)  # 类型检查器会警告这里有问题

def process_age(age: int) -> str:
    if age >= 18:
        return "成年人"
    else:
        return "未成年人"
```

## 🔍 Union 类型：多种可能性

在实际应用中，数据可能有多种类型：

```python
from typing import Union

# 用户输入可能是字符串或数字
def process_input(value: Union[str, int]) -> str:
    if isinstance(value, str):
        return f"处理字符串: {value}"
    elif isinstance(value, int):
        return f"处理数字: {value}"

# 使用示例
result1 = process_input("hello")     # ✅ 字符串
result2 = process_input(42)          # ✅ 数字
# result3 = process_input([1, 2, 3])  # ❌ 列表不被接受
```

## 🎪 实际练习：模拟 LangGraph 场景

让我们用一个简单的例子来理解：

```python
from typing import Dict, List, Optional

# 模拟聊天机器人的消息类型
def process_chat_message(
    message: str,
    user_id: int,
    conversation_history: List[str],
    metadata: Optional[Dict[str, str]] = None
) -> Dict[str, any]:
    """
    处理聊天消息

    参数:
        message: 用户输入的消息
        user_id: 用户ID
        conversation_history: 对话历史
        metadata: 可选的元数据

    返回:
        包含响应和更新后历史的字典
    """
    # 添加新消息到历史
    updated_history = conversation_history + [f"用户{user_id}: {message}"]

    # 生成响应
    response = f"我收到了你的消息: {message}"
    updated_history.append(f"机器人: {response}")

    # 构造返回结果
    result = {
        "response": response,
        "conversation_history": updated_history,
        "message_count": len(updated_history)
    }

    # 如果有元数据，添加到结果中
    if metadata:
        result["metadata"] = metadata

    return result

# 使用示例
history = ["用户1: 你好", "机器人: 你好！很高兴见到你"]
metadata = {"timestamp": "2024-01-01", "channel": "web"}

result = process_chat_message(
    message="今天天气怎么样？",
    user_id=1,
    conversation_history=history,
    metadata=metadata
)

print(result)
```

## 🔧 类型检查工具

### 使用 mypy 检查类型

```bash
# 安装 mypy
pip install mypy

# 检查 Python 文件
mypy your_file.py
```

### 在 IDE 中的优势

现代 IDE（如 VS Code、PyCharm）会利用类型注解：
- 提供更好的代码补全
- 实时显示类型错误
- 重构时更安全

## ✅ 自测练习

完成以下练习来测试你的理解：

### 练习 1：基础注解

为以下函数添加类型注解：

```python
# TODO: 添加类型注解
def calculate_average(numbers):
    return sum(numbers) / len(numbers)

def format_user_info(name, age, email):
    return f"姓名: {name}, 年龄: {age}, 邮箱: {email}"
```

<details>
<summary>🔍 查看答案</summary>

```python
from typing import List

def calculate_average(numbers: List[float]) -> float:
    return sum(numbers) / len(numbers)

def format_user_info(name: str, age: int, email: str) -> str:
    return f"姓名: {name}, 年龄: {age}, 邮箱: {email}"
```
</details>

### 练习 2：复杂类型

创建一个函数来处理学生信息：

```python
# TODO: 添加完整的类型注解
def process_student_data(student_data):
    """
    student_data 格式:
    {
        "name": "张三",
        "grades": [85, 92, 78],
        "extra_info": {"class": "A班", "teacher": "李老师"}  # 可选
    }
    """
    # 计算平均分
    avg_grade = sum(student_data["grades"]) / len(student_data["grades"])

    result = {
        "name": student_data["name"],
        "average_grade": avg_grade,
        "grade_count": len(student_data["grades"])
    }

    if "extra_info" in student_data:
        result["extra_info"] = student_data["extra_info"]

    return result
```

<details>
<summary>🔍 查看答案</summary>

```python
from typing import Dict, List, Optional, Union

def process_student_data(
    student_data: Dict[str, Union[str, List[int], Dict[str, str]]]
) -> Dict[str, Union[str, float, int, Dict[str, str]]]:
    # 或者更精确的版本：
    """
    student_data: Dict 包含:
        - "name": str
        - "grades": List[int]
        - "extra_info": Optional[Dict[str, str]]
    """
    avg_grade = sum(student_data["grades"]) / len(student_data["grades"])

    result = {
        "name": student_data["name"],
        "average_grade": avg_grade,
        "grade_count": len(student_data["grades"])
    }

    if "extra_info" in student_data:
        result["extra_info"] = student_data["extra_info"]

    return result
```
</details>

## 🚀 下一步

掌握了基础类型注解后，接下来学习：
- `02-TypedDict深入.md` - LangGraph 状态管理的核心
- `03-异步编程基础.md` - 现代 Python 应用的必备技能

## 💡 关键要点

1. **类型注解提升代码可读性**：让代码意图更清晰
2. **错误预防**：在运行前发现潜在问题
3. **IDE 支持**：更好的代码补全和重构
4. **LangGraph 基础**：理解 AgentState 设计的前提

---

*现在你已经掌握了 Python 类型系统的基础！这些知识将在学习 LangGraph 时派上大用场。* 🎉
# Python 异步编程基础

> 🎯 **学习目标**：掌握 Python 异步编程核心概念，理解 LangGraph 中的异步机制

## 🤔 为什么需要异步编程？

在 LangGraph 应用中，你经常会遇到这样的场景：

```python
# 串行处理：慢速操作
def slow_operations():
    result1 = call_llm_api("问题1")          # 需要 2 秒
    result2 = search_database("查询1")       # 需要 1 秒
    result3 = call_external_api("请求1")     # 需要 3 秒
    return [result1, result2, result3]      # 总共需要 6 秒

# 异步处理：并发执行
async def fast_operations():
    task1 = call_llm_api("问题1")           # 并发执行
    task2 = search_database("查询1")        # 并发执行
    task3 = call_external_api("请求1")      # 并发执行
    results = await asyncio.gather(task1, task2, task3)  # 总共只需要 3 秒
    return results
```

## 📖 异步编程核心概念

### 1. 协程 (Coroutine)

协程是可以暂停和恢复的函数：

```python
import asyncio

# 普通函数
def sync_function():
    print("这是同步函数")
    return "同步结果"

# 协程函数
async def async_function():
    print("这是异步函数")
    await asyncio.sleep(1)  # 模拟异步操作
    return "异步结果"

# 运行协程
async def main():
    result = await async_function()
    print(result)

# 执行
asyncio.run(main())
```

### 2. await 关键字

`await` 用于等待异步操作完成：

```python
import asyncio
import time

async def simulate_llm_call(prompt: str) -> str:
    """模拟 LLM API 调用"""
    print(f"🤖 开始处理: {prompt}")
    await asyncio.sleep(2)  # 模拟网络延迟
    print(f"✅ 处理完成: {prompt}")
    return f"回答: {prompt} 的响应"

async def simulate_database_query(query: str) -> str:
    """模拟数据库查询"""
    print(f"🗄️ 开始查询: {query}")
    await asyncio.sleep(1)  # 模拟查询时间
    print(f"✅ 查询完成: {query}")
    return f"查询结果: {query}"

# 串行执行（慢）
async def sequential_example():
    start_time = time.time()

    result1 = await simulate_llm_call("什么是 AI？")
    result2 = await simulate_database_query("用户信息")

    end_time = time.time()
    print(f"⏱️ 串行执行耗时: {end_time - start_time:.2f} 秒")
    return [result1, result2]

# 并发执行（快）
async def concurrent_example():
    start_time = time.time()

    # 同时启动多个任务
    task1 = simulate_llm_call("什么是 AI？")
    task2 = simulate_database_query("用户信息")

    # 等待所有任务完成
    results = await asyncio.gather(task1, task2)

    end_time = time.time()
    print(f"⏱️ 并发执行耗时: {end_time - start_time:.2f} 秒")
    return results

# 测试
async def main():
    print("=== 串行执行 ===")
    await sequential_example()

    print("\n=== 并发执行 ===")
    await concurrent_example()

# 运行
asyncio.run(main())
```

## 🔍 LangGraph 中的异步应用

### 1. 异步节点函数

在 LangGraph 中，节点函数可以是异步的：

```python
from typing import TypedDict
import asyncio

class ChatState(TypedDict):
    user_input: str
    llm_response: str
    search_results: str
    final_answer: str

# 异步 LLM 节点
async def llm_node(state: ChatState) -> ChatState:
    """调用 LLM 生成响应"""
    prompt = f"用户问题: {state['user_input']}"

    # 模拟异步 LLM 调用
    await asyncio.sleep(1.5)  # 模拟网络延迟
    response = f"LLM 回答: 关于 '{state['user_input']}' 的回答"

    return {
        **state,
        "llm_response": response
    }

# 异步搜索节点
async def search_node(state: ChatState) -> ChatState:
    """执行搜索操作"""
    query = state['user_input']

    # 模拟异步搜索
    await asyncio.sleep(1)  # 模拟搜索延迟
    results = f"搜索结果: 找到关于 '{query}' 的相关信息"

    return {
        **state,
        "search_results": results
    }

# 异步综合节点
async def synthesis_node(state: ChatState) -> ChatState:
    """综合 LLM 响应和搜索结果"""
    await asyncio.sleep(0.5)  # 模拟处理时间

    final_answer = f"""
    综合回答:
    - LLM 观点: {state['llm_response']}
    - 搜索补充: {state['search_results']}
    """

    return {
        **state,
        "final_answer": final_answer.strip()
    }
```

### 2. 并发处理多个任务

```python
# 并发执行多个独立的节点
async def parallel_processing_example():
    initial_state: ChatState = {
        "user_input": "什么是机器学习？",
        "llm_response": "",
        "search_results": "",
        "final_answer": ""
    }

    # 并发执行 LLM 和搜索
    print("🚀 开始并发处理...")
    start_time = time.time()

    llm_task = llm_node(initial_state)
    search_task = search_node(initial_state)

    # 等待两个任务完成
    llm_result, search_result = await asyncio.gather(llm_task, search_task)

    # 合并结果
    merged_state: ChatState = {
        "user_input": initial_state["user_input"],
        "llm_response": llm_result["llm_response"],
        "search_results": search_result["search_results"],
        "final_answer": ""
    }

    # 最后的综合处理
    final_state = await synthesis_node(merged_state)

    end_time = time.time()
    print(f"⏱️ 总耗时: {end_time - start_time:.2f} 秒")
    print(f"📝 最终结果: {final_state['final_answer']}")

# 运行示例
asyncio.run(parallel_processing_example())
```

## 🔧 实用异步模式

### 1. 异步上下文管理器

```python
import aiohttp
import asyncio

class AsyncLLMClient:
    """异步 LLM 客户端示例"""

    def __init__(self, api_url: str):
        self.api_url = api_url
        self.session = None

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def generate(self, prompt: str) -> str:
        """生成响应"""
        # 模拟 API 调用
        await asyncio.sleep(1)
        return f"生成的响应: {prompt}"

# 使用异步上下文管理器
async def use_llm_client():
    async with AsyncLLMClient("https://api.example.com") as client:
        response = await client.generate("你好，世界！")
        print(response)
```

### 2. 异步生成器

```python
async def stream_responses(prompts: list[str]):
    """流式处理多个提示"""
    for prompt in prompts:
        await asyncio.sleep(0.5)  # 模拟处理延迟
        yield f"处理完成: {prompt}"

# 使用异步生成器
async def process_stream():
    prompts = ["问题1", "问题2", "问题3"]

    async for response in stream_responses(prompts):
        print(f"📨 收到: {response}")
```

### 3. 异步队列

```python
import asyncio
from asyncio import Queue

async def producer(queue: Queue, name: str):
    """生产者：添加任务到队列"""
    for i in range(3):
        task = f"{name}-任务{i+1}"
        await queue.put(task)
        print(f"🏭 {name} 生产了: {task}")
        await asyncio.sleep(1)

async def consumer(queue: Queue, name: str):
    """消费者：从队列处理任务"""
    while True:
        try:
            task = await asyncio.wait_for(queue.get(), timeout=5)
            print(f"🔧 {name} 开始处理: {task}")
            await asyncio.sleep(2)  # 模拟处理时间
            print(f"✅ {name} 完成了: {task}")
            queue.task_done()
        except asyncio.TimeoutError:
            print(f"⏰ {name} 超时退出")
            break

# 生产者-消费者模式
async def producer_consumer_example():
    queue = Queue(maxsize=5)

    # 启动生产者和消费者
    producers = [
        asyncio.create_task(producer(queue, "生产者1")),
        asyncio.create_task(producer(queue, "生产者2"))
    ]

    consumers = [
        asyncio.create_task(consumer(queue, "消费者1")),
        asyncio.create_task(consumer(queue, "消费者2"))
    ]

    # 等待生产者完成
    await asyncio.gather(*producers)

    # 等待队列中的所有任务完成
    await queue.join()

    # 取消消费者
    for c in consumers:
        c.cancel()

    print("🎉 所有任务完成!")

# 运行示例
asyncio.run(producer_consumer_example())
```

## ⚠️ 常见陷阱与解决方案

### 1. 混合同步和异步代码

```python
import asyncio
import requests  # 同步库

# ❌ 错误：在异步函数中使用同步阻塞操作
async def bad_example():
    response = requests.get("https://httpbin.org/delay/2")  # 阻塞整个事件循环
    return response.json()

# ✅ 正确：使用异步HTTP客户端
async def good_example():
    import aiohttp
    async with aiohttp.ClientSession() as session:
        async with session.get("https://httpbin.org/delay/2") as response:
            return await response.json()

# ✅ 备选方案：使用线程池执行同步代码
async def alternative_example():
    loop = asyncio.get_event_loop()
    # 在线程池中执行同步操作
    response = await loop.run_in_executor(
        None,
        lambda: requests.get("https://httpbin.org/delay/2")
    )
    return response.json()
```

### 2. 忘记 await

```python
# ❌ 错误：忘记 await
async def bad_awaiting():
    result = simulate_llm_call("问题")  # 返回 coroutine 对象，不是结果
    print(result)  # 打印 <coroutine object ...>

# ✅ 正确：使用 await
async def good_awaiting():
    result = await simulate_llm_call("问题")  # 等待结果
    print(result)  # 打印实际结果
```

### 3. 异常处理

```python
async def safe_async_operation():
    """安全的异步操作，包含异常处理"""
    try:
        result = await simulate_llm_call("问题")
        return result
    except asyncio.TimeoutError:
        print("⏰ 操作超时")
        return "默认响应"
    except Exception as e:
        print(f"❌ 操作失败: {e}")
        return "错误响应"

# 使用超时保护
async def with_timeout():
    try:
        result = await asyncio.wait_for(
            simulate_llm_call("问题"),
            timeout=3.0
        )
        return result
    except asyncio.TimeoutError:
        return "操作超时，返回默认值"
```

## ✅ 实战练习

### 练习 1：异步数据获取

```python
async def fetch_user_data(user_id: str) -> dict:
    """
    TODO: 实现异步获取用户数据
    模拟从多个源获取数据：
    - 基本信息（1秒）
    - 偏好设置（0.5秒）
    - 历史记录（2秒）
    要求：并发获取，总耗时不超过2秒
    """
    pass

# 测试代码
async def test_fetch_user_data():
    start = time.time()
    data = await fetch_user_data("user123")
    end = time.time()
    print(f"获取数据耗时: {end - start:.2f} 秒")
    print(f"数据: {data}")
```

<details>
<summary>🔍 查看答案</summary>

```python
async def fetch_user_data(user_id: str) -> dict:
    """并发获取用户数据"""

    async def get_basic_info():
        await asyncio.sleep(1)
        return {"name": "Alice", "age": 25}

    async def get_preferences():
        await asyncio.sleep(0.5)
        return {"theme": "dark", "language": "zh"}

    async def get_history():
        await asyncio.sleep(2)
        return {"last_login": "2024-01-01", "login_count": 42}

    # 并发执行
    basic, prefs, history = await asyncio.gather(
        get_basic_info(),
        get_preferences(),
        get_history()
    )

    return {
        "user_id": user_id,
        "basic_info": basic,
        "preferences": prefs,
        "history": history
    }
```
</details>

### 练习 2：异步 LangGraph 节点

```python
from typing import TypedDict, List

class ResearchState(TypedDict):
    query: str
    web_results: List[str]
    paper_results: List[str]
    summary: str

async def web_search_node(state: ResearchState) -> ResearchState:
    """TODO: 实现异步网络搜索节点"""
    pass

async def paper_search_node(state: ResearchState) -> ResearchState:
    """TODO: 实现异步论文搜索节点"""
    pass

async def summarize_node(state: ResearchState) -> ResearchState:
    """TODO: 实现异步总结节点"""
    pass

# 研究流程
async def research_pipeline(query: str):
    """TODO: 实现完整的研究流程"""
    pass
```

## 🚀 下一步学习

掌握异步编程后，接下来学习：
- `04-装饰器与高阶函数.md` - 函数式编程在 LangGraph 中的应用
- `../02-图论与状态机/01-图的基本概念.md` - 理解 LangGraph 的数学基础

## 💡 关键要点

1. **异步提升性能**：通过并发执行减少等待时间
2. **LangGraph 原生支持**：节点函数可以是异步的
3. **避免阻塞**：在异步函数中避免同步阻塞操作
4. **错误处理**：异步代码需要特别注意异常和超时处理
5. **工具选择**：使用异步库（如 aiohttp）而不是同步库

---

*现在你已经掌握了现代 Python 应用开发的核心技能！* 🚀
# è£…é¥°å™¨ä¸é«˜é˜¶å‡½æ•°

> ğŸ¯ **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡ Python è£…é¥°å™¨å’Œé«˜é˜¶å‡½æ•°ï¼Œç†è§£ LangGraph ä¸­çš„å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼

## ğŸ¤” ä¸ºä»€ä¹ˆéœ€è¦è£…é¥°å™¨ï¼Ÿ

åœ¨ LangGraph åº”ç”¨ä¸­ï¼Œä½ ç»å¸¸éœ€è¦ä¸ºèŠ‚ç‚¹å‡½æ•°æ·»åŠ é¢å¤–åŠŸèƒ½ï¼š

```python
# æ²¡æœ‰è£…é¥°å™¨çš„é‡å¤ä»£ç 
def llm_node(state):
    print(f"ğŸš€ å¼€å§‹æ‰§è¡Œ llm_node, çŠ¶æ€: {state}")
    start_time = time.time()

    # æ ¸å¿ƒé€»è¾‘
    result = call_llm(state["message"])

    end_time = time.time()
    print(f"âœ… llm_node å®Œæˆï¼Œè€—æ—¶: {end_time - start_time:.2f}s")
    return {"message": result}

def search_node(state):
    print(f"ğŸš€ å¼€å§‹æ‰§è¡Œ search_node, çŠ¶æ€: {state}")
    start_time = time.time()

    # æ ¸å¿ƒé€»è¾‘
    result = search_web(state["query"])

    end_time = time.time()
    print(f"âœ… search_node å®Œæˆï¼Œè€—æ—¶: {end_time - start_time:.2f}s")
    return {"search_results": result}

# ä½¿ç”¨è£…é¥°å™¨çš„ç®€æ´ä»£ç 
@timing_logger
@state_logger
def llm_node(state):
    result = call_llm(state["message"])
    return {"message": result}

@timing_logger
@state_logger
def search_node(state):
    result = search_web(state["query"])
    return {"search_results": result}
```

## ğŸ“– å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘

åœ¨ Python ä¸­ï¼Œå‡½æ•°æ˜¯"ä¸€ç­‰å…¬æ°‘"ï¼Œå¯ä»¥åƒå˜é‡ä¸€æ ·ä¼ é€’ï¼š

```python
# å‡½æ•°å¯ä»¥èµ‹å€¼ç»™å˜é‡
def greet(name: str) -> str:
    return f"Hello, {name}!"

# èµ‹å€¼ç»™å˜é‡
my_func = greet
print(my_func("Alice"))  # "Hello, Alice!"

# å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’
def apply_twice(func, arg):
    """å¯¹å‚æ•°åº”ç”¨å‡½æ•°ä¸¤æ¬¡"""
    result = func(arg)
    return func(result)

def add_exclamation(text: str) -> str:
    return text + "!"

result = apply_twice(add_exclamation, "Hi")
print(result)  # "Hi!!"

# å‡½æ•°å¯ä»¥è¿”å›å‡½æ•°
def create_multiplier(factor: int):
    """åˆ›å»ºä¸€ä¸ªä¹˜æ³•å™¨å‡½æ•°"""
    def multiplier(x: int) -> int:
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

## ğŸ¯ è£…é¥°å™¨åŸºç¡€

### 1. ç®€å•è£…é¥°å™¨

```python
import time
from functools import wraps

def timing_decorator(func):
    """è®¡æ—¶è£…é¥°å™¨"""
    @wraps(func)  # ä¿æŒåŸå‡½æ•°çš„å…ƒæ•°æ®
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"â±ï¸ {func.__name__} è€—æ—¶: {end_time - start_time:.2f}s")
        return result
    return wrapper

# ä½¿ç”¨è£…é¥°å™¨
@timing_decorator
def slow_calculation(n: int) -> int:
    """æ¨¡æ‹Ÿæ…¢é€Ÿè®¡ç®—"""
    time.sleep(1)  # æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    return n * n

# æµ‹è¯•
result = slow_calculation(5)  # è¾“å‡º: â±ï¸ slow_calculation è€—æ—¶: 1.00s
print(f"ç»“æœ: {result}")      # è¾“å‡º: ç»“æœ: 25
```

### 2. å¸¦å‚æ•°çš„è£…é¥°å™¨

```python
def retry_decorator(max_attempts: int = 3, delay: float = 1.0):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"âŒ ç¬¬ {attempt + 1} æ¬¡å°è¯•å¤±è´¥: {e}")
                    if attempt == max_attempts - 1:
                        raise
                    time.sleep(delay)
        return wrapper
    return decorator

# ä½¿ç”¨å¸¦å‚æ•°çš„è£…é¥°å™¨
@retry_decorator(max_attempts=3, delay=0.5)
def unreliable_api_call(data: str) -> str:
    """æ¨¡æ‹Ÿä¸ç¨³å®šçš„ API è°ƒç”¨"""
    import random
    if random.random() < 0.7:  # 70% æ¦‚ç‡å¤±è´¥
        raise ConnectionError("ç½‘ç»œè¿æ¥å¤±è´¥")
    return f"å¤„ç†å®Œæˆ: {data}"

# æµ‹è¯•
try:
    result = unreliable_api_call("test data")
    print(f"âœ… æˆåŠŸ: {result}")
except Exception as e:
    print(f"ğŸ’¥ æœ€ç»ˆå¤±è´¥: {e}")
```

### 3. ç±»è£…é¥°å™¨

```python
class CountCalls:
    """è®¡æ•°å™¨è£…é¥°å™¨"""
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"ğŸ“Š {self.func.__name__} è¢«è°ƒç”¨ç¬¬ {self.count} æ¬¡")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello(name: str):
    return f"Hello, {name}!"

# æµ‹è¯•
say_hello("Alice")  # ğŸ“Š say_hello è¢«è°ƒç”¨ç¬¬ 1 æ¬¡
say_hello("Bob")    # ğŸ“Š say_hello è¢«è°ƒç”¨ç¬¬ 2 æ¬¡
print(f"æ€»è°ƒç”¨æ¬¡æ•°: {say_hello.count}")  # æ€»è°ƒç”¨æ¬¡æ•°: 2
```

## ğŸ” LangGraph ä¸­çš„è£…é¥°å™¨åº”ç”¨

### 1. èŠ‚ç‚¹å‡½æ•°è£…é¥°å™¨

```python
from typing import TypedDict, Any, Callable
import json

class AgentState(TypedDict):
    message: str
    step_count: int
    execution_log: list[str]

def node_logger(func: Callable[[AgentState], AgentState]):
    """è®°å½•èŠ‚ç‚¹æ‰§è¡Œä¿¡æ¯çš„è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(state: AgentState) -> AgentState:
        # è®°å½•å¼€å§‹
        start_msg = f"ğŸš€ å¼€å§‹æ‰§è¡ŒèŠ‚ç‚¹: {func.__name__}"
        print(start_msg)

        # æ›´æ–°æ‰§è¡Œæ—¥å¿—
        new_log = state.get("execution_log", []) + [start_msg]
        state_with_log = {**state, "execution_log": new_log}

        # æ‰§è¡ŒèŠ‚ç‚¹å‡½æ•°
        result = func(state_with_log)

        # è®°å½•å®Œæˆ
        end_msg = f"âœ… å®Œæˆæ‰§è¡ŒèŠ‚ç‚¹: {func.__name__}"
        print(end_msg)

        # æ›´æ–°æ­¥éª¤è®¡æ•°å’Œæ—¥å¿—
        final_result = {
            **result,
            "step_count": state.get("step_count", 0) + 1,
            "execution_log": result.get("execution_log", []) + [end_msg]
        }

        return final_result
    return wrapper

def error_handler(func: Callable[[AgentState], AgentState]):
    """é”™è¯¯å¤„ç†è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(state: AgentState) -> AgentState:
        try:
            return func(state)
        except Exception as e:
            error_msg = f"âŒ èŠ‚ç‚¹ {func.__name__} æ‰§è¡Œå¤±è´¥: {str(e)}"
            print(error_msg)

            # è¿”å›åŒ…å«é”™è¯¯ä¿¡æ¯çš„çŠ¶æ€
            return {
                **state,
                "error": error_msg,
                "execution_log": state.get("execution_log", []) + [error_msg]
            }
    return wrapper

# ä½¿ç”¨è£…é¥°å™¨çš„èŠ‚ç‚¹å‡½æ•°
@node_logger
@error_handler
def llm_thinking_node(state: AgentState) -> AgentState:
    """LLM æ€è€ƒèŠ‚ç‚¹"""
    message = state["message"]

    # æ¨¡æ‹Ÿ LLM å¤„ç†
    if "error" in message.lower():
        raise ValueError("æ¨¡æ‹Ÿå¤„ç†é”™è¯¯")

    response = f"æ€è€ƒç»“æœ: {message} -> è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é—®é¢˜"

    return {
        **state,
        "message": response
    }

@node_logger
@error_handler
def knowledge_search_node(state: AgentState) -> AgentState:
    """çŸ¥è¯†æœç´¢èŠ‚ç‚¹"""
    query = state["message"]

    # æ¨¡æ‹ŸçŸ¥è¯†åº“æœç´¢
    knowledge = f"çŸ¥è¯†åº“ç»“æœ: æ‰¾åˆ°å…³äº '{query}' çš„ç›¸å…³ä¿¡æ¯"

    return {
        **state,
        "message": knowledge
    }

# æµ‹è¯•èŠ‚ç‚¹
def test_decorated_nodes():
    initial_state: AgentState = {
        "message": "ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ",
        "step_count": 0,
        "execution_log": []
    }

    # æ‰§è¡Œæµç¨‹
    state1 = llm_thinking_node(initial_state)
    state2 = knowledge_search_node(state1)

    print("\nğŸ“‹ æœ€ç»ˆçŠ¶æ€:")
    print(f"æ­¥éª¤æ•°: {state2['step_count']}")
    print(f"æœ€ç»ˆæ¶ˆæ¯: {state2['message']}")
    print("æ‰§è¡Œæ—¥å¿—:")
    for log in state2['execution_log']:
        print(f"  {log}")

test_decorated_nodes()
```

### 2. çŠ¶æ€éªŒè¯è£…é¥°å™¨

```python
def validate_state(required_fields: list[str]):
    """çŠ¶æ€éªŒè¯è£…é¥°å™¨"""
    def decorator(func: Callable[[dict], dict]):
        @wraps(func)
        def wrapper(state: dict) -> dict:
            # éªŒè¯å¿…éœ€å­—æ®µ
            missing_fields = []
            for field in required_fields:
                if field not in state:
                    missing_fields.append(field)

            if missing_fields:
                raise ValueError(f"çŠ¶æ€ç¼ºå°‘å¿…éœ€å­—æ®µ: {missing_fields}")

            # æ‰§è¡Œå‡½æ•°
            result = func(state)

            # éªŒè¯è¿”å›ç»“æœä¹ŸåŒ…å«å¿…éœ€å­—æ®µ
            for field in required_fields:
                if field not in result:
                    print(f"âš ï¸ è­¦å‘Š: èŠ‚ç‚¹ {func.__name__} æœªè¿”å›å­—æ®µ {field}")

            return result
        return wrapper
    return decorator

# ä½¿ç”¨çŠ¶æ€éªŒè¯
@validate_state(["message", "user_id"])
def user_greeting_node(state: dict) -> dict:
    """ç”¨æˆ·é—®å€™èŠ‚ç‚¹"""
    user_id = state["user_id"]
    message = state["message"]

    greeting = f"ä½ å¥½ï¼Œç”¨æˆ· {user_id}ï¼ä½ çš„æ¶ˆæ¯æ˜¯: {message}"

    return {
        **state,
        "message": greeting
    }

# æµ‹è¯•
try:
    result = user_greeting_node({
        "message": "Hello",
        "user_id": "user123"
    })
    print("âœ… éªŒè¯é€šè¿‡:", result)
except ValueError as e:
    print("âŒ éªŒè¯å¤±è´¥:", e)
```

### 3. ç¼“å­˜è£…é¥°å™¨

```python
from functools import lru_cache
import hashlib

def state_cache(max_size: int = 128):
    """çŠ¶æ€ç¼“å­˜è£…é¥°å™¨"""
    cache = {}

    def decorator(func):
        @wraps(func)
        def wrapper(state: dict) -> dict:
            # åˆ›å»ºçŠ¶æ€çš„å“ˆå¸Œä½œä¸ºç¼“å­˜é”®
            state_str = json.dumps(state, sort_keys=True)
            cache_key = hashlib.md5(state_str.encode()).hexdigest()

            # æ£€æŸ¥ç¼“å­˜
            if cache_key in cache:
                print(f"ğŸ¯ ç¼“å­˜å‘½ä¸­: {func.__name__}")
                return cache[cache_key]

            # æ‰§è¡Œå‡½æ•°
            result = func(state)

            # å­˜å‚¨åˆ°ç¼“å­˜
            if len(cache) < max_size:
                cache[cache_key] = result
                print(f"ğŸ’¾ ç¼“å­˜å­˜å‚¨: {func.__name__}")

            return result
        return wrapper
    return decorator

@state_cache(max_size=10)
def expensive_computation_node(state: dict) -> dict:
    """æ˜‚è´µè®¡ç®—èŠ‚ç‚¹"""
    time.sleep(2)  # æ¨¡æ‹Ÿæ˜‚è´µè®¡ç®—

    value = state.get("value", 0)
    result = value ** 2 + value * 10

    return {
        **state,
        "computed_result": result
    }

# æµ‹è¯•ç¼“å­˜
test_state = {"value": 5}

print("ç¬¬ä¸€æ¬¡è°ƒç”¨:")
result1 = expensive_computation_node(test_state)

print("ç¬¬äºŒæ¬¡è°ƒç”¨ (ç›¸åŒçŠ¶æ€):")
result2 = expensive_computation_node(test_state)  # åº”è¯¥ä½¿ç”¨ç¼“å­˜
```

## ğŸ”§ é«˜é˜¶å‡½æ•°æ¨¡å¼

### 1. å‡½æ•°ç»„åˆ

```python
from typing import Callable, TypeVar

T = TypeVar('T')

def compose(*functions: Callable[[T], T]) -> Callable[[T], T]:
    """ç»„åˆå¤šä¸ªå‡½æ•°"""
    def composed_function(arg: T) -> T:
        result = arg
        for func in reversed(functions):
            result = func(result)
        return result
    return composed_function

# å®šä¹‰åŸºç¡€è½¬æ¢å‡½æ•°
def add_greeting(state: dict) -> dict:
    return {**state, "message": f"ä½ å¥½! {state['message']}"}

def add_timestamp(state: dict) -> dict:
    import datetime
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return {**state, "timestamp": timestamp}

def add_signature(state: dict) -> dict:
    return {**state, "message": f"{state['message']} - AIåŠ©æ‰‹"}

# ç»„åˆå‡½æ•°
process_message = compose(
    add_greeting,
    add_timestamp,
    add_signature
)

# æµ‹è¯•
result = process_message({"message": "è¿™æ˜¯ä¸€æ¡æ¶ˆæ¯"})
print(result)
```

### 2. ç®¡é“æ¨¡å¼

```python
class Pipeline:
    """å‡½æ•°ç®¡é“"""
    def __init__(self):
        self.steps = []

    def add_step(self, func: Callable[[dict], dict]) -> 'Pipeline':
        """æ·»åŠ å¤„ç†æ­¥éª¤"""
        self.steps.append(func)
        return self

    def execute(self, initial_state: dict) -> dict:
        """æ‰§è¡Œç®¡é“"""
        state = initial_state
        for i, step in enumerate(self.steps):
            print(f"ğŸ”„ æ‰§è¡Œæ­¥éª¤ {i+1}: {step.__name__}")
            state = step(state)
        return state

# åˆ›å»ºå¤„ç†ç®¡é“
pipeline = (Pipeline()
    .add_step(add_greeting)
    .add_step(add_timestamp)
    .add_step(add_signature))

# æ‰§è¡Œ
result = pipeline.execute({"message": "æµ‹è¯•æ¶ˆæ¯"})
print("ğŸ“‹ æœ€ç»ˆç»“æœ:", result)
```

### 3. æ¡ä»¶æ‰§è¡Œè£…é¥°å™¨

```python
def conditional_execution(condition_func: Callable[[dict], bool]):
    """æ¡ä»¶æ‰§è¡Œè£…é¥°å™¨"""
    def decorator(func: Callable[[dict], dict]):
        @wraps(func)
        def wrapper(state: dict) -> dict:
            if condition_func(state):
                print(f"âœ… æ¡ä»¶æ»¡è¶³ï¼Œæ‰§è¡Œ {func.__name__}")
                return func(state)
            else:
                print(f"âŒ æ¡ä»¶ä¸æ»¡è¶³ï¼Œè·³è¿‡ {func.__name__}")
                return state
        return wrapper
    return decorator

# å®šä¹‰æ¡ä»¶å‡½æ•°
def has_user_input(state: dict) -> bool:
    return "user_input" in state and state["user_input"].strip()

def is_question(state: dict) -> bool:
    return state.get("user_input", "").strip().endswith("?")

# ä½¿ç”¨æ¡ä»¶è£…é¥°å™¨
@conditional_execution(has_user_input)
def input_validation_node(state: dict) -> dict:
    """è¾“å…¥éªŒè¯èŠ‚ç‚¹"""
    return {**state, "input_valid": True}

@conditional_execution(is_question)
def question_answering_node(state: dict) -> dict:
    """é—®ç­”èŠ‚ç‚¹"""
    answer = f"è¿™æ˜¯å¯¹é—®é¢˜ '{state['user_input']}' çš„å›ç­”"
    return {**state, "answer": answer}

# æµ‹è¯•
test_cases = [
    {"user_input": "ä½ å¥½"},           # æœ‰è¾“å…¥ï¼Œä¸æ˜¯é—®é¢˜
    {"user_input": "ä»€ä¹ˆæ˜¯AIï¼Ÿ"},      # æœ‰è¾“å…¥ï¼Œæ˜¯é—®é¢˜
    {"user_input": ""},              # æ— è¾“å…¥
]

for i, test_state in enumerate(test_cases):
    print(f"\nğŸ“ æµ‹è¯•ç”¨ä¾‹ {i+1}: {test_state}")
    state1 = input_validation_node(test_state)
    state2 = question_answering_node(state1)
    print(f"ğŸ æœ€ç»ˆçŠ¶æ€: {state2}")
```

## âœ… å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹  1ï¼šåˆ›å»ºæ€§èƒ½ç›‘æ§è£…é¥°å™¨

```python
def performance_monitor(include_memory: bool = False):
    """
    TODO: åˆ›å»ºæ€§èƒ½ç›‘æ§è£…é¥°å™¨
    è¦æ±‚ï¼š
    1. è®°å½•å‡½æ•°æ‰§è¡Œæ—¶é—´
    2. å¯é€‰è®°å½•å†…å­˜ä½¿ç”¨é‡
    3. è®°å½•è°ƒç”¨æ¬¡æ•°
    4. è¾“å‡ºæ€§èƒ½æŠ¥å‘Š
    """
    pass

# ä½¿ç”¨ç¤ºä¾‹
@performance_monitor(include_memory=True)
def data_processing_node(state: dict) -> dict:
    # æ¨¡æ‹Ÿæ•°æ®å¤„ç†
    import time
    time.sleep(0.1)

    data = [i**2 for i in range(1000)]  # æ¶ˆè€—ä¸€äº›å†…å­˜

    return {**state, "processed_data": len(data)}

# æµ‹è¯•
for i in range(5):
    data_processing_node({"input": f"test_{i}"})
```

### ç»ƒä¹  2ï¼šå®ç°é‡è¯•å’Œé™çº§è£…é¥°å™¨

```python
def retry_with_fallback(max_retries: int = 3, fallback_func=None):
    """
    TODO: å®ç°é‡è¯•å’Œé™çº§è£…é¥°å™¨
    è¦æ±‚ï¼š
    1. å¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•
    2. è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°åä½¿ç”¨é™çº§å‡½æ•°
    3. è®°å½•é‡è¯•å†å²
    """
    pass

# é™çº§å‡½æ•°
def fallback_response(state: dict) -> dict:
    return {**state, "message": "æŠ±æ­‰ï¼ŒæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•"}

# ä½¿ç”¨ç¤ºä¾‹
@retry_with_fallback(max_retries=2, fallback_func=fallback_response)
def unreliable_service_node(state: dict) -> dict:
    import random
    if random.random() < 0.8:  # 80% æ¦‚ç‡å¤±è´¥
        raise Exception("æœåŠ¡è°ƒç”¨å¤±è´¥")
    return {**state, "message": "æœåŠ¡è°ƒç”¨æˆåŠŸ"}
```

## ğŸš€ ä¸‹ä¸€æ­¥å­¦ä¹ 

æŒæ¡è£…é¥°å™¨å’Œé«˜é˜¶å‡½æ•°åï¼Œæ¥ä¸‹æ¥å­¦ä¹ ï¼š
- `../02-å›¾è®ºä¸çŠ¶æ€æœº/01-å›¾çš„åŸºæœ¬æ¦‚å¿µ.md` - ç†è§£ LangGraph çš„æ•°å­¦åŸºç¡€
- `../03-LangGraphåŸºç¡€/01-ä¸ºä»€ä¹ˆéœ€è¦LangGraph.md` - å¼€å§‹ LangGraph æ ¸å¿ƒæ¦‚å¿µ

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **è£…é¥°å™¨å¢å¼ºå‡½æ•°åŠŸèƒ½**ï¼šä¸ä¿®æ”¹åŸå‡½æ•°ä»£ç çš„æƒ…å†µä¸‹æ·»åŠ æ–°åŠŸèƒ½
2. **é«˜é˜¶å‡½æ•°æä¾›æŠ½è±¡**ï¼šå‡½æ•°ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼ï¼Œå®ç°æ›´é«˜å±‚æ¬¡çš„æŠ½è±¡
3. **LangGraph åº”ç”¨å¹¿æ³›**ï¼šæ—¥å¿—ã€é”™è¯¯å¤„ç†ã€ç¼“å­˜ã€æ€§èƒ½ç›‘æ§éƒ½å¯ä»¥ç”¨è£…é¥°å™¨
4. **ç»„åˆèƒœè¿‡ç»§æ‰¿**ï¼šé€šè¿‡å‡½æ•°ç»„åˆå’Œè£…é¥°å™¨å åŠ å®ç°å¤æ‚åŠŸèƒ½
5. **ä¿æŒå‡½æ•°çº¯å‡€**ï¼šè£…é¥°å™¨å¤„ç†æ¨ªåˆ‡å…³æ³¨ç‚¹ï¼Œä¿æŒæ ¸å¿ƒé€»è¾‘ç®€æ´

---

*ç°åœ¨ä½ å·²ç»æŒæ¡äº† Python å‡½æ•°å¼ç¼–ç¨‹çš„ç²¾é«“ï¼è¿™äº›æŠ€èƒ½å°†è®©ä½ çš„ LangGraph ä»£ç æ›´åŠ ä¼˜é›…å’Œå¯ç»´æŠ¤ã€‚* âœ¨
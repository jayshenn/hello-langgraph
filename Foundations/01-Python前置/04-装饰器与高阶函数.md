# 装饰器与高阶函数

> 🎯 **学习目标**：掌握 Python 装饰器和高阶函数，理解 LangGraph 中的函数式编程模式

## 🤔 为什么需要装饰器？

在 LangGraph 应用中，你经常需要为节点函数添加额外功能：

```python
# 没有装饰器的重复代码
def llm_node(state):
    print(f"🚀 开始执行 llm_node, 状态: {state}")
    start_time = time.time()

    # 核心逻辑
    result = call_llm(state["message"])

    end_time = time.time()
    print(f"✅ llm_node 完成，耗时: {end_time - start_time:.2f}s")
    return {"message": result}

def search_node(state):
    print(f"🚀 开始执行 search_node, 状态: {state}")
    start_time = time.time()

    # 核心逻辑
    result = search_web(state["query"])

    end_time = time.time()
    print(f"✅ search_node 完成，耗时: {end_time - start_time:.2f}s")
    return {"search_results": result}

# 使用装饰器的简洁代码
@timing_logger
@state_logger
def llm_node(state):
    result = call_llm(state["message"])
    return {"message": result}

@timing_logger
@state_logger
def search_node(state):
    result = search_web(state["query"])
    return {"search_results": result}
```

## 📖 函数作为一等公民

在 Python 中，函数是"一等公民"，可以像变量一样传递：

```python
# 函数可以赋值给变量
def greet(name: str) -> str:
    return f"Hello, {name}!"

# 赋值给变量
my_func = greet
print(my_func("Alice"))  # "Hello, Alice!"

# 函数可以作为参数传递
def apply_twice(func, arg):
    """对参数应用函数两次"""
    result = func(arg)
    return func(result)

def add_exclamation(text: str) -> str:
    return text + "!"

result = apply_twice(add_exclamation, "Hi")
print(result)  # "Hi!!"

# 函数可以返回函数
def create_multiplier(factor: int):
    """创建一个乘法器函数"""
    def multiplier(x: int) -> int:
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

## 🎯 装饰器基础

### 1. 简单装饰器

```python
import time
from functools import wraps

def timing_decorator(func):
    """计时装饰器"""
    @wraps(func)  # 保持原函数的元数据
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"⏱️ {func.__name__} 耗时: {end_time - start_time:.2f}s")
        return result
    return wrapper

# 使用装饰器
@timing_decorator
def slow_calculation(n: int) -> int:
    """模拟慢速计算"""
    time.sleep(1)  # 模拟耗时操作
    return n * n

# 测试
result = slow_calculation(5)  # 输出: ⏱️ slow_calculation 耗时: 1.00s
print(f"结果: {result}")      # 输出: 结果: 25
```

### 2. 带参数的装饰器

```python
def retry_decorator(max_attempts: int = 3, delay: float = 1.0):
    """重试装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"❌ 第 {attempt + 1} 次尝试失败: {e}")
                    if attempt == max_attempts - 1:
                        raise
                    time.sleep(delay)
        return wrapper
    return decorator

# 使用带参数的装饰器
@retry_decorator(max_attempts=3, delay=0.5)
def unreliable_api_call(data: str) -> str:
    """模拟不稳定的 API 调用"""
    import random
    if random.random() < 0.7:  # 70% 概率失败
        raise ConnectionError("网络连接失败")
    return f"处理完成: {data}"

# 测试
try:
    result = unreliable_api_call("test data")
    print(f"✅ 成功: {result}")
except Exception as e:
    print(f"💥 最终失败: {e}")
```

### 3. 类装饰器

```python
class CountCalls:
    """计数器装饰器"""
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"📊 {self.func.__name__} 被调用第 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello(name: str):
    return f"Hello, {name}!"

# 测试
say_hello("Alice")  # 📊 say_hello 被调用第 1 次
say_hello("Bob")    # 📊 say_hello 被调用第 2 次
print(f"总调用次数: {say_hello.count}")  # 总调用次数: 2
```

## 🔍 LangGraph 中的装饰器应用

### 1. 节点函数装饰器

```python
from typing import TypedDict, Any, Callable
import json

class AgentState(TypedDict):
    message: str
    step_count: int
    execution_log: list[str]

def node_logger(func: Callable[[AgentState], AgentState]):
    """记录节点执行信息的装饰器"""
    @wraps(func)
    def wrapper(state: AgentState) -> AgentState:
        # 记录开始
        start_msg = f"🚀 开始执行节点: {func.__name__}"
        print(start_msg)

        # 更新执行日志
        new_log = state.get("execution_log", []) + [start_msg]
        state_with_log = {**state, "execution_log": new_log}

        # 执行节点函数
        result = func(state_with_log)

        # 记录完成
        end_msg = f"✅ 完成执行节点: {func.__name__}"
        print(end_msg)

        # 更新步骤计数和日志
        final_result = {
            **result,
            "step_count": state.get("step_count", 0) + 1,
            "execution_log": result.get("execution_log", []) + [end_msg]
        }

        return final_result
    return wrapper

def error_handler(func: Callable[[AgentState], AgentState]):
    """错误处理装饰器"""
    @wraps(func)
    def wrapper(state: AgentState) -> AgentState:
        try:
            return func(state)
        except Exception as e:
            error_msg = f"❌ 节点 {func.__name__} 执行失败: {str(e)}"
            print(error_msg)

            # 返回包含错误信息的状态
            return {
                **state,
                "error": error_msg,
                "execution_log": state.get("execution_log", []) + [error_msg]
            }
    return wrapper

# 使用装饰器的节点函数
@node_logger
@error_handler
def llm_thinking_node(state: AgentState) -> AgentState:
    """LLM 思考节点"""
    message = state["message"]

    # 模拟 LLM 处理
    if "error" in message.lower():
        raise ValueError("模拟处理错误")

    response = f"思考结果: {message} -> 这是一个很好的问题"

    return {
        **state,
        "message": response
    }

@node_logger
@error_handler
def knowledge_search_node(state: AgentState) -> AgentState:
    """知识搜索节点"""
    query = state["message"]

    # 模拟知识库搜索
    knowledge = f"知识库结果: 找到关于 '{query}' 的相关信息"

    return {
        **state,
        "message": knowledge
    }

# 测试节点
def test_decorated_nodes():
    initial_state: AgentState = {
        "message": "什么是机器学习？",
        "step_count": 0,
        "execution_log": []
    }

    # 执行流程
    state1 = llm_thinking_node(initial_state)
    state2 = knowledge_search_node(state1)

    print("\n📋 最终状态:")
    print(f"步骤数: {state2['step_count']}")
    print(f"最终消息: {state2['message']}")
    print("执行日志:")
    for log in state2['execution_log']:
        print(f"  {log}")

test_decorated_nodes()
```

### 2. 状态验证装饰器

```python
def validate_state(required_fields: list[str]):
    """状态验证装饰器"""
    def decorator(func: Callable[[dict], dict]):
        @wraps(func)
        def wrapper(state: dict) -> dict:
            # 验证必需字段
            missing_fields = []
            for field in required_fields:
                if field not in state:
                    missing_fields.append(field)

            if missing_fields:
                raise ValueError(f"状态缺少必需字段: {missing_fields}")

            # 执行函数
            result = func(state)

            # 验证返回结果也包含必需字段
            for field in required_fields:
                if field not in result:
                    print(f"⚠️ 警告: 节点 {func.__name__} 未返回字段 {field}")

            return result
        return wrapper
    return decorator

# 使用状态验证
@validate_state(["message", "user_id"])
def user_greeting_node(state: dict) -> dict:
    """用户问候节点"""
    user_id = state["user_id"]
    message = state["message"]

    greeting = f"你好，用户 {user_id}！你的消息是: {message}"

    return {
        **state,
        "message": greeting
    }

# 测试
try:
    result = user_greeting_node({
        "message": "Hello",
        "user_id": "user123"
    })
    print("✅ 验证通过:", result)
except ValueError as e:
    print("❌ 验证失败:", e)
```

### 3. 缓存装饰器

```python
from functools import lru_cache
import hashlib

def state_cache(max_size: int = 128):
    """状态缓存装饰器"""
    cache = {}

    def decorator(func):
        @wraps(func)
        def wrapper(state: dict) -> dict:
            # 创建状态的哈希作为缓存键
            state_str = json.dumps(state, sort_keys=True)
            cache_key = hashlib.md5(state_str.encode()).hexdigest()

            # 检查缓存
            if cache_key in cache:
                print(f"🎯 缓存命中: {func.__name__}")
                return cache[cache_key]

            # 执行函数
            result = func(state)

            # 存储到缓存
            if len(cache) < max_size:
                cache[cache_key] = result
                print(f"💾 缓存存储: {func.__name__}")

            return result
        return wrapper
    return decorator

@state_cache(max_size=10)
def expensive_computation_node(state: dict) -> dict:
    """昂贵计算节点"""
    time.sleep(2)  # 模拟昂贵计算

    value = state.get("value", 0)
    result = value ** 2 + value * 10

    return {
        **state,
        "computed_result": result
    }

# 测试缓存
test_state = {"value": 5}

print("第一次调用:")
result1 = expensive_computation_node(test_state)

print("第二次调用 (相同状态):")
result2 = expensive_computation_node(test_state)  # 应该使用缓存
```

## 🔧 高阶函数模式

### 1. 函数组合

```python
from typing import Callable, TypeVar

T = TypeVar('T')

def compose(*functions: Callable[[T], T]) -> Callable[[T], T]:
    """组合多个函数"""
    def composed_function(arg: T) -> T:
        result = arg
        for func in reversed(functions):
            result = func(result)
        return result
    return composed_function

# 定义基础转换函数
def add_greeting(state: dict) -> dict:
    return {**state, "message": f"你好! {state['message']}"}

def add_timestamp(state: dict) -> dict:
    import datetime
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return {**state, "timestamp": timestamp}

def add_signature(state: dict) -> dict:
    return {**state, "message": f"{state['message']} - AI助手"}

# 组合函数
process_message = compose(
    add_greeting,
    add_timestamp,
    add_signature
)

# 测试
result = process_message({"message": "这是一条消息"})
print(result)
```

### 2. 管道模式

```python
class Pipeline:
    """函数管道"""
    def __init__(self):
        self.steps = []

    def add_step(self, func: Callable[[dict], dict]) -> 'Pipeline':
        """添加处理步骤"""
        self.steps.append(func)
        return self

    def execute(self, initial_state: dict) -> dict:
        """执行管道"""
        state = initial_state
        for i, step in enumerate(self.steps):
            print(f"🔄 执行步骤 {i+1}: {step.__name__}")
            state = step(state)
        return state

# 创建处理管道
pipeline = (Pipeline()
    .add_step(add_greeting)
    .add_step(add_timestamp)
    .add_step(add_signature))

# 执行
result = pipeline.execute({"message": "测试消息"})
print("📋 最终结果:", result)
```

### 3. 条件执行装饰器

```python
def conditional_execution(condition_func: Callable[[dict], bool]):
    """条件执行装饰器"""
    def decorator(func: Callable[[dict], dict]):
        @wraps(func)
        def wrapper(state: dict) -> dict:
            if condition_func(state):
                print(f"✅ 条件满足，执行 {func.__name__}")
                return func(state)
            else:
                print(f"❌ 条件不满足，跳过 {func.__name__}")
                return state
        return wrapper
    return decorator

# 定义条件函数
def has_user_input(state: dict) -> bool:
    return "user_input" in state and state["user_input"].strip()

def is_question(state: dict) -> bool:
    return state.get("user_input", "").strip().endswith("?")

# 使用条件装饰器
@conditional_execution(has_user_input)
def input_validation_node(state: dict) -> dict:
    """输入验证节点"""
    return {**state, "input_valid": True}

@conditional_execution(is_question)
def question_answering_node(state: dict) -> dict:
    """问答节点"""
    answer = f"这是对问题 '{state['user_input']}' 的回答"
    return {**state, "answer": answer}

# 测试
test_cases = [
    {"user_input": "你好"},           # 有输入，不是问题
    {"user_input": "什么是AI？"},      # 有输入，是问题
    {"user_input": ""},              # 无输入
]

for i, test_state in enumerate(test_cases):
    print(f"\n📝 测试用例 {i+1}: {test_state}")
    state1 = input_validation_node(test_state)
    state2 = question_answering_node(state1)
    print(f"🏁 最终状态: {state2}")
```

## ✅ 实战练习

### 练习 1：创建性能监控装饰器

```python
def performance_monitor(include_memory: bool = False):
    """
    TODO: 创建性能监控装饰器
    要求：
    1. 记录函数执行时间
    2. 可选记录内存使用量
    3. 记录调用次数
    4. 输出性能报告
    """
    pass

# 使用示例
@performance_monitor(include_memory=True)
def data_processing_node(state: dict) -> dict:
    # 模拟数据处理
    import time
    time.sleep(0.1)

    data = [i**2 for i in range(1000)]  # 消耗一些内存

    return {**state, "processed_data": len(data)}

# 测试
for i in range(5):
    data_processing_node({"input": f"test_{i}"})
```

### 练习 2：实现重试和降级装饰器

```python
def retry_with_fallback(max_retries: int = 3, fallback_func=None):
    """
    TODO: 实现重试和降级装饰器
    要求：
    1. 失败时自动重试
    2. 达到最大重试次数后使用降级函数
    3. 记录重试历史
    """
    pass

# 降级函数
def fallback_response(state: dict) -> dict:
    return {**state, "message": "抱歉，服务暂时不可用，请稍后再试"}

# 使用示例
@retry_with_fallback(max_retries=2, fallback_func=fallback_response)
def unreliable_service_node(state: dict) -> dict:
    import random
    if random.random() < 0.8:  # 80% 概率失败
        raise Exception("服务调用失败")
    return {**state, "message": "服务调用成功"}
```

## 🚀 下一步学习

掌握装饰器和高阶函数后，接下来学习：
- `../02-图论与状态机/01-图的基本概念.md` - 理解 LangGraph 的数学基础
- `../03-LangGraph基础/01-为什么需要LangGraph.md` - 开始 LangGraph 核心概念

## 💡 关键要点

1. **装饰器增强函数功能**：不修改原函数代码的情况下添加新功能
2. **高阶函数提供抽象**：函数作为参数和返回值，实现更高层次的抽象
3. **LangGraph 应用广泛**：日志、错误处理、缓存、性能监控都可以用装饰器
4. **组合胜过继承**：通过函数组合和装饰器叠加实现复杂功能
5. **保持函数纯净**：装饰器处理横切关注点，保持核心逻辑简洁

---

*现在你已经掌握了 Python 函数式编程的精髓！这些技能将让你的 LangGraph 代码更加优雅和可维护。* ✨
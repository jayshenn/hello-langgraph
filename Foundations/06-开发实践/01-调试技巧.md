# LangGraph 调试技巧

> 🎯 **学习目标**：掌握 LangGraph 应用的调试方法，学会使用可视化工具和日志技巧快速定位问题

## 🔍 调试环境搭建

### 1. LangGraph Studio 可视化调试

LangGraph Studio 是官方提供的可视化调试工具，是调试的第一选择。

```bash
# 安装 LangGraph CLI
pip install langgraph-cli

# 启动本地开发服务器
langgraph dev

# 在浏览器中打开 LangGraph Studio
# 地址：http://localhost:2024
```

**Studio 的调试功能：**
- 📊 图形化展示节点执行流程
- 🔄 实时查看状态变化
- ⏸️ 断点设置和单步执行
- 📝 输入输出数据检查
- 🕐 执行时间分析

### 2. 环境变量配置

```python
import os
import logging

# 启用详细日志
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_ENDPOINT"] = "https://api.smith.langchain.com"
os.environ["LANGCHAIN_API_KEY"] = "your-api-key"

# 设置 Python 日志级别
logging.basicConfig(level=logging.DEBUG)
```

## 🛠️ 基础调试技巧

### 1. 状态跟踪调试

```python
from typing import TypedDict, List
from langgraph import StateGraph
import json

class DebugState(TypedDict):
    messages: List[str]
    step_count: int
    debug_info: dict

def debug_node(state: DebugState) -> DebugState:
    """带调试信息的节点"""
    print(f"🔍 [DEBUG] 进入节点，当前状态:")
    print(f"   - 消息数量: {len(state['messages'])}")
    print(f"   - 步骤计数: {state['step_count']}")
    print(f"   - 调试信息: {json.dumps(state['debug_info'], indent=2, ensure_ascii=False)}")

    # 节点逻辑
    new_message = f"处理第 {state['step_count'] + 1} 步"

    # 更新调试信息
    debug_info = state['debug_info'].copy()
    debug_info[f"step_{state['step_count'] + 1}"] = {
        "timestamp": __import__('datetime').datetime.now().isoformat(),
        "action": "处理消息",
        "input_length": len(state['messages'])
    }

    result = {
        "messages": state['messages'] + [new_message],
        "step_count": state['step_count'] + 1,
        "debug_info": debug_info
    }

    print(f"✅ [DEBUG] 节点执行完毕，新状态:")
    print(f"   - 新增消息: {new_message}")
    print(f"   - 更新后步骤: {result['step_count']}")

    return result
```

### 2. 流式输出调试

```python
from langgraph import StateGraph, START, END

def create_debug_graph():
    """创建可调试的图"""
    graph = StateGraph(DebugState)

    graph.add_node("debug_node", debug_node)
    graph.add_edge(START, "debug_node")
    graph.add_edge("debug_node", END)

    return graph.compile()

# 流式执行并调试
app = create_debug_graph()

initial_state = {
    "messages": ["初始消息"],
    "step_count": 0,
    "debug_info": {"start_time": __import__('datetime').datetime.now().isoformat()}
}

print("🚀 开始流式执行...")
for event in app.stream(initial_state):
    print(f"📦 事件: {event}")
    for node_name, state_update in event.items():
        print(f"   节点 '{node_name}' 更新:")
        for key, value in state_update.items():
            if key == "debug_info":
                print(f"     {key}: {json.dumps(value, indent=6, ensure_ascii=False)}")
            else:
                print(f"     {key}: {value}")
    print("-" * 50)
```

### 3. 断点调试技巧

```python
from langgraph import StateGraph
import pdb

def breakpoint_node(state: DebugState) -> DebugState:
    """包含断点的节点"""
    print(f"🛑 到达断点，当前状态: {state}")

    # 设置断点（可以在调试时注释掉）
    # pdb.set_trace()

    # 或者使用条件断点
    if len(state['messages']) > 5:
        print("⚠️  消息数量过多，触发断点")
        # pdb.set_trace()

    # 继续执行
    return {
        "messages": state['messages'] + ["断点节点处理"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }
```

## 🔧 高级调试方法

### 1. 自定义日志装饰器

```python
import functools
import time
from typing import Callable, Any

def debug_log(func: Callable) -> Callable:
    """节点函数调试装饰器"""

    @functools.wraps(func)
    def wrapper(state: dict) -> dict:
        start_time = time.time()
        func_name = func.__name__

        print(f"⏰ [{func_name}] 开始执行 - {time.strftime('%H:%M:%S')}")
        print(f"📥 [{func_name}] 输入状态: {_format_state(state)}")

        try:
            result = func(state)
            execution_time = time.time() - start_time

            print(f"📤 [{func_name}] 输出状态: {_format_state(result)}")
            print(f"✅ [{func_name}] 执行完成 - 耗时: {execution_time:.3f}s")

            return result

        except Exception as e:
            execution_time = time.time() - start_time
            print(f"❌ [{func_name}] 执行失败 - 耗时: {execution_time:.3f}s")
            print(f"💥 [{func_name}] 错误信息: {str(e)}")
            raise

    return wrapper

def _format_state(state: dict) -> str:
    """格式化状态显示"""
    if not state:
        return "{}"

    formatted = {}
    for key, value in state.items():
        if isinstance(value, list) and len(value) > 2:
            formatted[key] = f"[...{len(value)} items...]"
        elif isinstance(value, str) and len(value) > 50:
            formatted[key] = value[:47] + "..."
        else:
            formatted[key] = value

    return str(formatted)

# 使用装饰器
@debug_log
def processing_node(state: DebugState) -> DebugState:
    """处理节点"""
    # 模拟一些处理时间
    time.sleep(0.1)

    return {
        "messages": state['messages'] + ["已处理"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }
```

### 2. 状态检查点保存

```python
import json
import os
from datetime import datetime

class StateCheckpoint:
    """状态检查点管理器"""

    def __init__(self, checkpoint_dir: str = "debug_checkpoints"):
        self.checkpoint_dir = checkpoint_dir
        os.makedirs(checkpoint_dir, exist_ok=True)

    def save_checkpoint(self, state: dict, node_name: str, step: int):
        """保存状态检查点"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{step:03d}_{node_name}_{timestamp}.json"
        filepath = os.path.join(self.checkpoint_dir, filename)

        checkpoint_data = {
            "timestamp": timestamp,
            "node_name": node_name,
            "step": step,
            "state": state
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(checkpoint_data, f, indent=2, ensure_ascii=False)

        print(f"💾 检查点已保存: {filepath}")
        return filepath

    def load_checkpoint(self, filepath: str) -> dict:
        """加载状态检查点"""
        with open(filepath, 'r', encoding='utf-8') as f:
            checkpoint_data = json.load(f)

        print(f"📁 检查点已加载: {filepath}")
        return checkpoint_data["state"]

# 使用检查点
checkpoint_manager = StateCheckpoint()

def checkpoint_node(state: DebugState) -> DebugState:
    """带检查点的节点"""
    # 保存输入状态
    checkpoint_manager.save_checkpoint(
        state,
        "checkpoint_node_input",
        state['step_count']
    )

    # 执行处理
    result = {
        "messages": state['messages'] + ["检查点处理"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    # 保存输出状态
    checkpoint_manager.save_checkpoint(
        result,
        "checkpoint_node_output",
        result['step_count']
    )

    return result
```

### 3. 错误追踪和恢复

```python
class ErrorTracker:
    """错误追踪器"""

    def __init__(self):
        self.errors = []
        self.recovery_attempts = {}

    def log_error(self, node_name: str, error: Exception, state: dict):
        """记录错误"""
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "node_name": node_name,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "state_snapshot": state.copy()
        }

        self.errors.append(error_info)
        print(f"🚨 错误已记录: {node_name} - {error_info['error_type']}")

    def attempt_recovery(self, node_name: str, state: dict, max_attempts: int = 3):
        """尝试错误恢复"""
        attempt_key = f"{node_name}_{id(state)}"
        attempts = self.recovery_attempts.get(attempt_key, 0)

        if attempts >= max_attempts:
            print(f"💀 恢复失败: {node_name} 已达到最大重试次数 {max_attempts}")
            return None

        self.recovery_attempts[attempt_key] = attempts + 1
        print(f"🔄 尝试恢复: {node_name} (第 {attempts + 1} 次)")

        return state

# 全局错误追踪器
error_tracker = ErrorTracker()

def robust_node(state: DebugState) -> DebugState:
    """具有错误处理的节点"""
    try:
        # 模拟可能出错的操作
        if len(state['messages']) > 10:
            raise ValueError("消息数量过多")

        return {
            "messages": state['messages'] + ["健壮处理"],
            "step_count": state['step_count'] + 1,
            "debug_info": state['debug_info']
        }

    except Exception as e:
        error_tracker.log_error("robust_node", e, state)

        # 尝试恢复
        recovery_state = error_tracker.attempt_recovery("robust_node", state)
        if recovery_state:
            # 返回一个安全的状态
            return {
                "messages": state['messages'] + ["错误恢复"],
                "step_count": state['step_count'] + 1,
                "debug_info": {**state['debug_info'], "error_recovered": True}
            }
        else:
            # 重新抛出异常
            raise
```

## 📊 调试输出格式化

### 1. 美化控制台输出

```python
class DebugFormatter:
    """调试输出格式化器"""

    @staticmethod
    def print_state(state: dict, title: str = "状态"):
        """美化打印状态"""
        print(f"\n{'='*20} {title} {'='*20}")
        for key, value in state.items():
            if isinstance(value, dict):
                print(f"📋 {key}:")
                for sub_key, sub_value in value.items():
                    print(f"    {sub_key}: {sub_value}")
            elif isinstance(value, list):
                print(f"📝 {key} ({len(value)} 项):")
                for i, item in enumerate(value[-3:]):  # 只显示最后3项
                    print(f"    [{i}] {item}")
                if len(value) > 3:
                    print(f"    ... (还有 {len(value)-3} 项)")
            else:
                print(f"🔤 {key}: {value}")
        print("="*50 + "\n")

    @staticmethod
    def print_execution_flow(node_name: str, step: int, status: str = "执行中"):
        """打印执行流程"""
        status_emoji = {
            "开始": "🚀",
            "执行中": "⚙️",
            "完成": "✅",
            "错误": "❌"
        }

        emoji = status_emoji.get(status, "🔄")
        print(f"{emoji} 步骤 {step}: {node_name} - {status}")

# 使用格式化器
def formatted_debug_node(state: DebugState) -> DebugState:
    """使用格式化输出的调试节点"""
    DebugFormatter.print_execution_flow("formatted_debug_node", state['step_count'], "开始")
    DebugFormatter.print_state(state, "输入状态")

    # 处理逻辑
    result = {
        "messages": state['messages'] + ["格式化处理"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    DebugFormatter.print_state(result, "输出状态")
    DebugFormatter.print_execution_flow("formatted_debug_node", result['step_count'], "完成")

    return result
```

## 🎯 调试最佳实践

### 1. 分层调试策略

```python
# 1. 开发阶段：详细调试
DEBUG_LEVEL = "VERBOSE"  # VERBOSE | NORMAL | MINIMAL

def conditional_debug(message: str, level: str = "NORMAL"):
    """条件调试输出"""
    levels = {"VERBOSE": 3, "NORMAL": 2, "MINIMAL": 1}
    current_level = levels.get(DEBUG_LEVEL, 2)
    msg_level = levels.get(level, 2)

    if msg_level <= current_level:
        print(f"🐛 [{level}] {message}")

# 2. 在节点中使用
def smart_debug_node(state: DebugState) -> DebugState:
    conditional_debug("节点开始执行", "VERBOSE")
    conditional_debug(f"处理 {len(state['messages'])} 条消息", "NORMAL")

    # 处理逻辑
    result = {
        "messages": state['messages'] + ["智能调试"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    conditional_debug("节点执行完成", "MINIMAL")
    return result
```

### 2. 性能监控

```python
import psutil
import tracemalloc

class PerformanceMonitor:
    """性能监控器"""

    def __init__(self):
        self.start_memory = None
        tracemalloc.start()

    def start_monitoring(self):
        """开始监控"""
        self.start_memory = tracemalloc.take_snapshot()
        print(f"💻 CPU使用率: {psutil.cpu_percent()}%")
        print(f"🧠 内存使用: {psutil.virtual_memory().percent}%")

    def check_performance(self, checkpoint_name: str):
        """检查性能"""
        current_memory = tracemalloc.take_snapshot()
        top_stats = current_memory.compare_to(self.start_memory, 'lineno')

        print(f"\n📈 性能检查点: {checkpoint_name}")
        print(f"💻 当前CPU: {psutil.cpu_percent()}%")
        print(f"🧠 当前内存: {psutil.virtual_memory().percent}%")

        print("🔝 内存增长最多的3个位置:")
        for stat in top_stats[:3]:
            print(f"  {stat}")

# 使用性能监控
perf_monitor = PerformanceMonitor()

def performance_aware_node(state: DebugState) -> DebugState:
    """性能监控节点"""
    perf_monitor.start_monitoring()

    # 执行处理（模拟一些工作）
    import time
    time.sleep(0.1)

    result = {
        "messages": state['messages'] + ["性能监控处理"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    perf_monitor.check_performance("performance_aware_node")
    return result
```

## 📚 延伸阅读

- [LangGraph Studio 官方文档](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/)
- [LangSmith 追踪和调试](https://docs.smith.langchain.com/)
- [Python 调试最佳实践](https://realpython.com/python-debugging-pdb/)

## 📝 练习任务

1. **基础调试**：为 `Exercises/Exercise_Graph1.ipynb` 添加调试输出
2. **状态追踪**：实现一个状态变化的可视化工具
3. **错误处理**：创建一个包含错误恢复机制的复杂图
4. **性能分析**：对现有的图进行性能分析和优化

---

💡 **小贴士**：调试是开发过程中最重要的技能之一。善用这些工具和技巧，能让你的 LangGraph 开发事半功倍！
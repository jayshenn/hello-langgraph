# LangGraph è°ƒè¯•æŠ€å·§

> ğŸ¯ **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡ LangGraph åº”ç”¨çš„è°ƒè¯•æ–¹æ³•ï¼Œå­¦ä¼šä½¿ç”¨å¯è§†åŒ–å·¥å…·å’Œæ—¥å¿—æŠ€å·§å¿«é€Ÿå®šä½é—®é¢˜

## ğŸ” è°ƒè¯•ç¯å¢ƒæ­å»º

### 1. LangGraph Studio å¯è§†åŒ–è°ƒè¯•

LangGraph Studio æ˜¯å®˜æ–¹æä¾›çš„å¯è§†åŒ–è°ƒè¯•å·¥å…·ï¼Œæ˜¯è°ƒè¯•çš„ç¬¬ä¸€é€‰æ‹©ã€‚

```bash
# å®‰è£… LangGraph CLI
pip install langgraph-cli

# å¯åŠ¨æœ¬åœ°å¼€å‘æœåŠ¡å™¨
langgraph dev

# åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ LangGraph Studio
# åœ°å€ï¼šhttp://localhost:2024
```

**Studio çš„è°ƒè¯•åŠŸèƒ½ï¼š**
- ğŸ“Š å›¾å½¢åŒ–å±•ç¤ºèŠ‚ç‚¹æ‰§è¡Œæµç¨‹
- ğŸ”„ å®æ—¶æŸ¥çœ‹çŠ¶æ€å˜åŒ–
- â¸ï¸ æ–­ç‚¹è®¾ç½®å’Œå•æ­¥æ‰§è¡Œ
- ğŸ“ è¾“å…¥è¾“å‡ºæ•°æ®æ£€æŸ¥
- ğŸ• æ‰§è¡Œæ—¶é—´åˆ†æ

### 2. ç¯å¢ƒå˜é‡é…ç½®

```python
import os
import logging

# å¯ç”¨è¯¦ç»†æ—¥å¿—
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_ENDPOINT"] = "https://api.smith.langchain.com"
os.environ["LANGCHAIN_API_KEY"] = "your-api-key"

# è®¾ç½® Python æ—¥å¿—çº§åˆ«
logging.basicConfig(level=logging.DEBUG)
```

## ğŸ› ï¸ åŸºç¡€è°ƒè¯•æŠ€å·§

### 1. çŠ¶æ€è·Ÿè¸ªè°ƒè¯•

```python
from typing import TypedDict, List
from langgraph import StateGraph
import json

class DebugState(TypedDict):
    messages: List[str]
    step_count: int
    debug_info: dict

def debug_node(state: DebugState) -> DebugState:
    """å¸¦è°ƒè¯•ä¿¡æ¯çš„èŠ‚ç‚¹"""
    print(f"ğŸ” [DEBUG] è¿›å…¥èŠ‚ç‚¹ï¼Œå½“å‰çŠ¶æ€:")
    print(f"   - æ¶ˆæ¯æ•°é‡: {len(state['messages'])}")
    print(f"   - æ­¥éª¤è®¡æ•°: {state['step_count']}")
    print(f"   - è°ƒè¯•ä¿¡æ¯: {json.dumps(state['debug_info'], indent=2, ensure_ascii=False)}")

    # èŠ‚ç‚¹é€»è¾‘
    new_message = f"å¤„ç†ç¬¬ {state['step_count'] + 1} æ­¥"

    # æ›´æ–°è°ƒè¯•ä¿¡æ¯
    debug_info = state['debug_info'].copy()
    debug_info[f"step_{state['step_count'] + 1}"] = {
        "timestamp": __import__('datetime').datetime.now().isoformat(),
        "action": "å¤„ç†æ¶ˆæ¯",
        "input_length": len(state['messages'])
    }

    result = {
        "messages": state['messages'] + [new_message],
        "step_count": state['step_count'] + 1,
        "debug_info": debug_info
    }

    print(f"âœ… [DEBUG] èŠ‚ç‚¹æ‰§è¡Œå®Œæ¯•ï¼Œæ–°çŠ¶æ€:")
    print(f"   - æ–°å¢æ¶ˆæ¯: {new_message}")
    print(f"   - æ›´æ–°åæ­¥éª¤: {result['step_count']}")

    return result
```

### 2. æµå¼è¾“å‡ºè°ƒè¯•

```python
from langgraph import StateGraph, START, END

def create_debug_graph():
    """åˆ›å»ºå¯è°ƒè¯•çš„å›¾"""
    graph = StateGraph(DebugState)

    graph.add_node("debug_node", debug_node)
    graph.add_edge(START, "debug_node")
    graph.add_edge("debug_node", END)

    return graph.compile()

# æµå¼æ‰§è¡Œå¹¶è°ƒè¯•
app = create_debug_graph()

initial_state = {
    "messages": ["åˆå§‹æ¶ˆæ¯"],
    "step_count": 0,
    "debug_info": {"start_time": __import__('datetime').datetime.now().isoformat()}
}

print("ğŸš€ å¼€å§‹æµå¼æ‰§è¡Œ...")
for event in app.stream(initial_state):
    print(f"ğŸ“¦ äº‹ä»¶: {event}")
    for node_name, state_update in event.items():
        print(f"   èŠ‚ç‚¹ '{node_name}' æ›´æ–°:")
        for key, value in state_update.items():
            if key == "debug_info":
                print(f"     {key}: {json.dumps(value, indent=6, ensure_ascii=False)}")
            else:
                print(f"     {key}: {value}")
    print("-" * 50)
```

### 3. æ–­ç‚¹è°ƒè¯•æŠ€å·§

```python
from langgraph import StateGraph
import pdb

def breakpoint_node(state: DebugState) -> DebugState:
    """åŒ…å«æ–­ç‚¹çš„èŠ‚ç‚¹"""
    print(f"ğŸ›‘ åˆ°è¾¾æ–­ç‚¹ï¼Œå½“å‰çŠ¶æ€: {state}")

    # è®¾ç½®æ–­ç‚¹ï¼ˆå¯ä»¥åœ¨è°ƒè¯•æ—¶æ³¨é‡Šæ‰ï¼‰
    # pdb.set_trace()

    # æˆ–è€…ä½¿ç”¨æ¡ä»¶æ–­ç‚¹
    if len(state['messages']) > 5:
        print("âš ï¸  æ¶ˆæ¯æ•°é‡è¿‡å¤šï¼Œè§¦å‘æ–­ç‚¹")
        # pdb.set_trace()

    # ç»§ç»­æ‰§è¡Œ
    return {
        "messages": state['messages'] + ["æ–­ç‚¹èŠ‚ç‚¹å¤„ç†"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }
```

## ğŸ”§ é«˜çº§è°ƒè¯•æ–¹æ³•

### 1. è‡ªå®šä¹‰æ—¥å¿—è£…é¥°å™¨

```python
import functools
import time
from typing import Callable, Any

def debug_log(func: Callable) -> Callable:
    """èŠ‚ç‚¹å‡½æ•°è°ƒè¯•è£…é¥°å™¨"""

    @functools.wraps(func)
    def wrapper(state: dict) -> dict:
        start_time = time.time()
        func_name = func.__name__

        print(f"â° [{func_name}] å¼€å§‹æ‰§è¡Œ - {time.strftime('%H:%M:%S')}")
        print(f"ğŸ“¥ [{func_name}] è¾“å…¥çŠ¶æ€: {_format_state(state)}")

        try:
            result = func(state)
            execution_time = time.time() - start_time

            print(f"ğŸ“¤ [{func_name}] è¾“å‡ºçŠ¶æ€: {_format_state(result)}")
            print(f"âœ… [{func_name}] æ‰§è¡Œå®Œæˆ - è€—æ—¶: {execution_time:.3f}s")

            return result

        except Exception as e:
            execution_time = time.time() - start_time
            print(f"âŒ [{func_name}] æ‰§è¡Œå¤±è´¥ - è€—æ—¶: {execution_time:.3f}s")
            print(f"ğŸ’¥ [{func_name}] é”™è¯¯ä¿¡æ¯: {str(e)}")
            raise

    return wrapper

def _format_state(state: dict) -> str:
    """æ ¼å¼åŒ–çŠ¶æ€æ˜¾ç¤º"""
    if not state:
        return "{}"

    formatted = {}
    for key, value in state.items():
        if isinstance(value, list) and len(value) > 2:
            formatted[key] = f"[...{len(value)} items...]"
        elif isinstance(value, str) and len(value) > 50:
            formatted[key] = value[:47] + "..."
        else:
            formatted[key] = value

    return str(formatted)

# ä½¿ç”¨è£…é¥°å™¨
@debug_log
def processing_node(state: DebugState) -> DebugState:
    """å¤„ç†èŠ‚ç‚¹"""
    # æ¨¡æ‹Ÿä¸€äº›å¤„ç†æ—¶é—´
    time.sleep(0.1)

    return {
        "messages": state['messages'] + ["å·²å¤„ç†"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }
```

### 2. çŠ¶æ€æ£€æŸ¥ç‚¹ä¿å­˜

```python
import json
import os
from datetime import datetime

class StateCheckpoint:
    """çŠ¶æ€æ£€æŸ¥ç‚¹ç®¡ç†å™¨"""

    def __init__(self, checkpoint_dir: str = "debug_checkpoints"):
        self.checkpoint_dir = checkpoint_dir
        os.makedirs(checkpoint_dir, exist_ok=True)

    def save_checkpoint(self, state: dict, node_name: str, step: int):
        """ä¿å­˜çŠ¶æ€æ£€æŸ¥ç‚¹"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{step:03d}_{node_name}_{timestamp}.json"
        filepath = os.path.join(self.checkpoint_dir, filename)

        checkpoint_data = {
            "timestamp": timestamp,
            "node_name": node_name,
            "step": step,
            "state": state
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(checkpoint_data, f, indent=2, ensure_ascii=False)

        print(f"ğŸ’¾ æ£€æŸ¥ç‚¹å·²ä¿å­˜: {filepath}")
        return filepath

    def load_checkpoint(self, filepath: str) -> dict:
        """åŠ è½½çŠ¶æ€æ£€æŸ¥ç‚¹"""
        with open(filepath, 'r', encoding='utf-8') as f:
            checkpoint_data = json.load(f)

        print(f"ğŸ“ æ£€æŸ¥ç‚¹å·²åŠ è½½: {filepath}")
        return checkpoint_data["state"]

# ä½¿ç”¨æ£€æŸ¥ç‚¹
checkpoint_manager = StateCheckpoint()

def checkpoint_node(state: DebugState) -> DebugState:
    """å¸¦æ£€æŸ¥ç‚¹çš„èŠ‚ç‚¹"""
    # ä¿å­˜è¾“å…¥çŠ¶æ€
    checkpoint_manager.save_checkpoint(
        state,
        "checkpoint_node_input",
        state['step_count']
    )

    # æ‰§è¡Œå¤„ç†
    result = {
        "messages": state['messages'] + ["æ£€æŸ¥ç‚¹å¤„ç†"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    # ä¿å­˜è¾“å‡ºçŠ¶æ€
    checkpoint_manager.save_checkpoint(
        result,
        "checkpoint_node_output",
        result['step_count']
    )

    return result
```

### 3. é”™è¯¯è¿½è¸ªå’Œæ¢å¤

```python
class ErrorTracker:
    """é”™è¯¯è¿½è¸ªå™¨"""

    def __init__(self):
        self.errors = []
        self.recovery_attempts = {}

    def log_error(self, node_name: str, error: Exception, state: dict):
        """è®°å½•é”™è¯¯"""
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "node_name": node_name,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "state_snapshot": state.copy()
        }

        self.errors.append(error_info)
        print(f"ğŸš¨ é”™è¯¯å·²è®°å½•: {node_name} - {error_info['error_type']}")

    def attempt_recovery(self, node_name: str, state: dict, max_attempts: int = 3):
        """å°è¯•é”™è¯¯æ¢å¤"""
        attempt_key = f"{node_name}_{id(state)}"
        attempts = self.recovery_attempts.get(attempt_key, 0)

        if attempts >= max_attempts:
            print(f"ğŸ’€ æ¢å¤å¤±è´¥: {node_name} å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° {max_attempts}")
            return None

        self.recovery_attempts[attempt_key] = attempts + 1
        print(f"ğŸ”„ å°è¯•æ¢å¤: {node_name} (ç¬¬ {attempts + 1} æ¬¡)")

        return state

# å…¨å±€é”™è¯¯è¿½è¸ªå™¨
error_tracker = ErrorTracker()

def robust_node(state: DebugState) -> DebugState:
    """å…·æœ‰é”™è¯¯å¤„ç†çš„èŠ‚ç‚¹"""
    try:
        # æ¨¡æ‹Ÿå¯èƒ½å‡ºé”™çš„æ“ä½œ
        if len(state['messages']) > 10:
            raise ValueError("æ¶ˆæ¯æ•°é‡è¿‡å¤š")

        return {
            "messages": state['messages'] + ["å¥å£®å¤„ç†"],
            "step_count": state['step_count'] + 1,
            "debug_info": state['debug_info']
        }

    except Exception as e:
        error_tracker.log_error("robust_node", e, state)

        # å°è¯•æ¢å¤
        recovery_state = error_tracker.attempt_recovery("robust_node", state)
        if recovery_state:
            # è¿”å›ä¸€ä¸ªå®‰å…¨çš„çŠ¶æ€
            return {
                "messages": state['messages'] + ["é”™è¯¯æ¢å¤"],
                "step_count": state['step_count'] + 1,
                "debug_info": {**state['debug_info'], "error_recovered": True}
            }
        else:
            # é‡æ–°æŠ›å‡ºå¼‚å¸¸
            raise
```

## ğŸ“Š è°ƒè¯•è¾“å‡ºæ ¼å¼åŒ–

### 1. ç¾åŒ–æ§åˆ¶å°è¾“å‡º

```python
class DebugFormatter:
    """è°ƒè¯•è¾“å‡ºæ ¼å¼åŒ–å™¨"""

    @staticmethod
    def print_state(state: dict, title: str = "çŠ¶æ€"):
        """ç¾åŒ–æ‰“å°çŠ¶æ€"""
        print(f"\n{'='*20} {title} {'='*20}")
        for key, value in state.items():
            if isinstance(value, dict):
                print(f"ğŸ“‹ {key}:")
                for sub_key, sub_value in value.items():
                    print(f"    {sub_key}: {sub_value}")
            elif isinstance(value, list):
                print(f"ğŸ“ {key} ({len(value)} é¡¹):")
                for i, item in enumerate(value[-3:]):  # åªæ˜¾ç¤ºæœ€å3é¡¹
                    print(f"    [{i}] {item}")
                if len(value) > 3:
                    print(f"    ... (è¿˜æœ‰ {len(value)-3} é¡¹)")
            else:
                print(f"ğŸ”¤ {key}: {value}")
        print("="*50 + "\n")

    @staticmethod
    def print_execution_flow(node_name: str, step: int, status: str = "æ‰§è¡Œä¸­"):
        """æ‰“å°æ‰§è¡Œæµç¨‹"""
        status_emoji = {
            "å¼€å§‹": "ğŸš€",
            "æ‰§è¡Œä¸­": "âš™ï¸",
            "å®Œæˆ": "âœ…",
            "é”™è¯¯": "âŒ"
        }

        emoji = status_emoji.get(status, "ğŸ”„")
        print(f"{emoji} æ­¥éª¤ {step}: {node_name} - {status}")

# ä½¿ç”¨æ ¼å¼åŒ–å™¨
def formatted_debug_node(state: DebugState) -> DebugState:
    """ä½¿ç”¨æ ¼å¼åŒ–è¾“å‡ºçš„è°ƒè¯•èŠ‚ç‚¹"""
    DebugFormatter.print_execution_flow("formatted_debug_node", state['step_count'], "å¼€å§‹")
    DebugFormatter.print_state(state, "è¾“å…¥çŠ¶æ€")

    # å¤„ç†é€»è¾‘
    result = {
        "messages": state['messages'] + ["æ ¼å¼åŒ–å¤„ç†"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    DebugFormatter.print_state(result, "è¾“å‡ºçŠ¶æ€")
    DebugFormatter.print_execution_flow("formatted_debug_node", result['step_count'], "å®Œæˆ")

    return result
```

## ğŸ¯ è°ƒè¯•æœ€ä½³å®è·µ

### 1. åˆ†å±‚è°ƒè¯•ç­–ç•¥

```python
# 1. å¼€å‘é˜¶æ®µï¼šè¯¦ç»†è°ƒè¯•
DEBUG_LEVEL = "VERBOSE"  # VERBOSE | NORMAL | MINIMAL

def conditional_debug(message: str, level: str = "NORMAL"):
    """æ¡ä»¶è°ƒè¯•è¾“å‡º"""
    levels = {"VERBOSE": 3, "NORMAL": 2, "MINIMAL": 1}
    current_level = levels.get(DEBUG_LEVEL, 2)
    msg_level = levels.get(level, 2)

    if msg_level <= current_level:
        print(f"ğŸ› [{level}] {message}")

# 2. åœ¨èŠ‚ç‚¹ä¸­ä½¿ç”¨
def smart_debug_node(state: DebugState) -> DebugState:
    conditional_debug("èŠ‚ç‚¹å¼€å§‹æ‰§è¡Œ", "VERBOSE")
    conditional_debug(f"å¤„ç† {len(state['messages'])} æ¡æ¶ˆæ¯", "NORMAL")

    # å¤„ç†é€»è¾‘
    result = {
        "messages": state['messages'] + ["æ™ºèƒ½è°ƒè¯•"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    conditional_debug("èŠ‚ç‚¹æ‰§è¡Œå®Œæˆ", "MINIMAL")
    return result
```

### 2. æ€§èƒ½ç›‘æ§

```python
import psutil
import tracemalloc

class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""

    def __init__(self):
        self.start_memory = None
        tracemalloc.start()

    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§"""
        self.start_memory = tracemalloc.take_snapshot()
        print(f"ğŸ’» CPUä½¿ç”¨ç‡: {psutil.cpu_percent()}%")
        print(f"ğŸ§  å†…å­˜ä½¿ç”¨: {psutil.virtual_memory().percent}%")

    def check_performance(self, checkpoint_name: str):
        """æ£€æŸ¥æ€§èƒ½"""
        current_memory = tracemalloc.take_snapshot()
        top_stats = current_memory.compare_to(self.start_memory, 'lineno')

        print(f"\nğŸ“ˆ æ€§èƒ½æ£€æŸ¥ç‚¹: {checkpoint_name}")
        print(f"ğŸ’» å½“å‰CPU: {psutil.cpu_percent()}%")
        print(f"ğŸ§  å½“å‰å†…å­˜: {psutil.virtual_memory().percent}%")

        print("ğŸ” å†…å­˜å¢é•¿æœ€å¤šçš„3ä¸ªä½ç½®:")
        for stat in top_stats[:3]:
            print(f"  {stat}")

# ä½¿ç”¨æ€§èƒ½ç›‘æ§
perf_monitor = PerformanceMonitor()

def performance_aware_node(state: DebugState) -> DebugState:
    """æ€§èƒ½ç›‘æ§èŠ‚ç‚¹"""
    perf_monitor.start_monitoring()

    # æ‰§è¡Œå¤„ç†ï¼ˆæ¨¡æ‹Ÿä¸€äº›å·¥ä½œï¼‰
    import time
    time.sleep(0.1)

    result = {
        "messages": state['messages'] + ["æ€§èƒ½ç›‘æ§å¤„ç†"],
        "step_count": state['step_count'] + 1,
        "debug_info": state['debug_info']
    }

    perf_monitor.check_performance("performance_aware_node")
    return result
```

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [LangGraph Studio å®˜æ–¹æ–‡æ¡£](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/)
- [LangSmith è¿½è¸ªå’Œè°ƒè¯•](https://docs.smith.langchain.com/)
- [Python è°ƒè¯•æœ€ä½³å®è·µ](https://realpython.com/python-debugging-pdb/)

## ğŸ“ ç»ƒä¹ ä»»åŠ¡

1. **åŸºç¡€è°ƒè¯•**ï¼šä¸º `Exercises/Exercise_Graph1.ipynb` æ·»åŠ è°ƒè¯•è¾“å‡º
2. **çŠ¶æ€è¿½è¸ª**ï¼šå®ç°ä¸€ä¸ªçŠ¶æ€å˜åŒ–çš„å¯è§†åŒ–å·¥å…·
3. **é”™è¯¯å¤„ç†**ï¼šåˆ›å»ºä¸€ä¸ªåŒ…å«é”™è¯¯æ¢å¤æœºåˆ¶çš„å¤æ‚å›¾
4. **æ€§èƒ½åˆ†æ**ï¼šå¯¹ç°æœ‰çš„å›¾è¿›è¡Œæ€§èƒ½åˆ†æå’Œä¼˜åŒ–

---

ğŸ’¡ **å°è´´å£«**ï¼šè°ƒè¯•æ˜¯å¼€å‘è¿‡ç¨‹ä¸­æœ€é‡è¦çš„æŠ€èƒ½ä¹‹ä¸€ã€‚å–„ç”¨è¿™äº›å·¥å…·å’ŒæŠ€å·§ï¼Œèƒ½è®©ä½ çš„ LangGraph å¼€å‘äº‹åŠåŠŸå€ï¼
# LangGraph 测试策略

> 🎯 **学习目标**：掌握 LangGraph 应用的全面测试方法，包括单元测试、集成测试、LLM 评估等

## 🧪 测试环境搭建

### 1. 测试框架选择

```python
import unittest
import pytest
import asyncio
from unittest.mock import Mock, patch, MagicMock
from typing import TypedDict, List, Dict, Any
from langgraph import StateGraph, START, END

# 测试用的状态定义
class TestState(TypedDict):
    input_data: str
    processed_data: str
    step_count: int
    test_results: Dict[str, Any]

# 基础测试类
class LangGraphTestCase(unittest.TestCase):
    """LangGraph 测试基类"""

    def setUp(self):
        """测试前准备"""
        self.test_state = {
            "input_data": "测试输入",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

    def tearDown(self):
        """测试后清理"""
        # 清理任何全局状态
        pass

    def create_test_graph(self, nodes: Dict[str, callable]) -> StateGraph:
        """创建测试图的辅助方法"""
        graph = StateGraph(TestState)

        for node_name, node_func in nodes.items():
            graph.add_node(node_name, node_func)

        return graph

    def assert_state_contains(self, state: dict, expected_keys: List[str]):
        """断言状态包含指定键"""
        for key in expected_keys:
            self.assertIn(key, state, f"状态中缺少键: {key}")

    def assert_state_values(self, state: dict, expected_values: Dict[str, Any]):
        """断言状态值"""
        for key, expected_value in expected_values.items():
            self.assertEqual(
                state.get(key),
                expected_value,
                f"键 {key} 的值不匹配: 期望 {expected_value}, 实际 {state.get(key)}"
            )
```

### 2. 测试数据管理

```python
import json
import os
from pathlib import Path

class TestDataManager:
    """测试数据管理器"""

    def __init__(self, data_dir: str = "test_data"):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)

    def load_test_data(self, filename: str) -> dict:
        """加载测试数据"""
        filepath = self.data_dir / filename
        if not filepath.exists():
            raise FileNotFoundError(f"测试数据文件不存在: {filepath}")

        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)

    def save_test_data(self, filename: str, data: dict):
        """保存测试数据"""
        filepath = self.data_dir / filename
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def create_test_cases(self, scenario: str) -> List[dict]:
        """创建测试用例"""
        test_cases = {
            "basic_processing": [
                {
                    "name": "正常输入",
                    "input": {"input_data": "正常数据", "step_count": 0},
                    "expected": {"processed_data": "正常数据_已处理", "step_count": 1}
                },
                {
                    "name": "空输入",
                    "input": {"input_data": "", "step_count": 0},
                    "expected": {"processed_data": "_已处理", "step_count": 1}
                },
                {
                    "name": "长文本输入",
                    "input": {"input_data": "很长的文本" * 100, "step_count": 0},
                    "expected": {"step_count": 1}
                }
            ],
            "error_scenarios": [
                {
                    "name": "无效输入类型",
                    "input": {"input_data": 123, "step_count": 0},
                    "should_raise": TypeError
                },
                {
                    "name": "缺少必需字段",
                    "input": {"step_count": 0},
                    "should_raise": KeyError
                }
            ]
        }

        return test_cases.get(scenario, [])

# 全局测试数据管理器
test_data_manager = TestDataManager()
```

## 🔬 单元测试

### 1. 节点函数测试

```python
def simple_processing_node(state: TestState) -> TestState:
    """简单处理节点"""
    return {
        "input_data": state["input_data"],
        "processed_data": f"{state['input_data']}_已处理",
        "step_count": state["step_count"] + 1,
        "test_results": state["test_results"]
    }

def conditional_node(state: TestState) -> TestState:
    """条件处理节点"""
    if len(state["input_data"]) > 10:
        processed = f"长文本:{state['input_data'][:10]}..."
    else:
        processed = f"短文本:{state['input_data']}"

    return {
        "input_data": state["input_data"],
        "processed_data": processed,
        "step_count": state["step_count"] + 1,
        "test_results": state["test_results"]
    }

class TestNodeFunctions(LangGraphTestCase):
    """节点函数测试"""

    def test_simple_processing_node(self):
        """测试简单处理节点"""
        # 准备测试数据
        input_state = {
            "input_data": "测试数据",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        # 执行节点
        result = simple_processing_node(input_state)

        # 验证结果
        self.assertEqual(result["processed_data"], "测试数据_已处理")
        self.assertEqual(result["step_count"], 1)
        self.assertEqual(result["input_data"], "测试数据")

    def test_conditional_node_short_text(self):
        """测试条件节点 - 短文本"""
        input_state = {
            "input_data": "短文本",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = conditional_node(input_state)

        self.assertEqual(result["processed_data"], "短文本:短文本")

    def test_conditional_node_long_text(self):
        """测试条件节点 - 长文本"""
        input_state = {
            "input_data": "这是一个很长的文本输入用于测试",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = conditional_node(input_state)

        self.assertEqual(result["processed_data"], "长文本:这是一个很长的文本...")

    def test_node_with_invalid_input(self):
        """测试无效输入"""
        input_state = {
            "input_data": None,  # 无效输入
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        with self.assertRaises(TypeError):
            conditional_node(input_state)

    @pytest.mark.parametrize("input_text,expected_prefix", [
        ("short", "短文本:"),
        ("this is a very long text", "长文本:"),
        ("", "短文本:")
    ])
    def test_conditional_node_parametrized(self, input_text, expected_prefix):
        """参数化测试条件节点"""
        input_state = {
            "input_data": input_text,
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = conditional_node(input_state)
        self.assertTrue(result["processed_data"].startswith(expected_prefix))
```

### 2. 模拟和桩测试

```python
def external_api_node(state: TestState) -> TestState:
    """调用外部API的节点"""
    import requests

    try:
        # 模拟API调用
        response = requests.get("https://api.example.com/process",
                              json={"data": state["input_data"]})
        api_result = response.json()

        return {
            "input_data": state["input_data"],
            "processed_data": api_result["result"],
            "step_count": state["step_count"] + 1,
            "test_results": {"api_status": "success"}
        }
    except Exception as e:
        return {
            "input_data": state["input_data"],
            "processed_data": "API调用失败",
            "step_count": state["step_count"] + 1,
            "test_results": {"api_status": "failed", "error": str(e)}
        }

class TestExternalAPICalls(LangGraphTestCase):
    """外部API调用测试"""

    @patch('requests.get')
    def test_external_api_success(self, mock_get):
        """测试API调用成功"""
        # 设置模拟响应
        mock_response = Mock()
        mock_response.json.return_value = {"result": "API处理结果"}
        mock_get.return_value = mock_response

        input_state = {
            "input_data": "测试数据",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = external_api_node(input_state)

        # 验证API被正确调用
        mock_get.assert_called_once_with(
            "https://api.example.com/process",
            json={"data": "测试数据"}
        )

        # 验证结果
        self.assertEqual(result["processed_data"], "API处理结果")
        self.assertEqual(result["test_results"]["api_status"], "success")

    @patch('requests.get')
    def test_external_api_failure(self, mock_get):
        """测试API调用失败"""
        # 设置模拟异常
        mock_get.side_effect = requests.exceptions.ConnectionError("连接失败")

        input_state = {
            "input_data": "测试数据",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = external_api_node(input_state)

        # 验证错误处理
        self.assertEqual(result["processed_data"], "API调用失败")
        self.assertEqual(result["test_results"]["api_status"], "failed")
        self.assertIn("连接失败", result["test_results"]["error"])

    def test_api_node_with_mock_context(self):
        """使用上下文管理器的模拟测试"""
        with patch('requests.get') as mock_get:
            # 设置多次调用的不同响应
            mock_get.side_effect = [
                Mock(json=lambda: {"result": "第一次调用"}),
                Mock(json=lambda: {"result": "第二次调用"})
            ]

            # 第一次调用
            result1 = external_api_node(self.test_state)
            self.assertEqual(result1["processed_data"], "第一次调用")

            # 第二次调用
            result2 = external_api_node(self.test_state)
            self.assertEqual(result2["processed_data"], "第二次调用")

            # 验证调用次数
            self.assertEqual(mock_get.call_count, 2)
```

## 🔧 集成测试

### 1. 图执行测试

```python
def create_processing_graph():
    """创建处理图"""
    graph = StateGraph(TestState)

    graph.add_node("process", simple_processing_node)
    graph.add_node("condition", conditional_node)

    graph.add_edge(START, "process")
    graph.add_edge("process", "condition")
    graph.add_edge("condition", END)

    return graph.compile()

class TestGraphExecution(LangGraphTestCase):
    """图执行测试"""

    def setUp(self):
        super().setUp()
        self.app = create_processing_graph()

    def test_complete_graph_execution(self):
        """测试完整图执行"""
        initial_state = {
            "input_data": "集成测试",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = self.app.invoke(initial_state)

        # 验证整个流程
        self.assertEqual(result["step_count"], 2)  # 两个节点都执行了
        self.assertIn("已处理", result["processed_data"])
        self.assertIn("短文本:", result["processed_data"])

    def test_graph_with_different_inputs(self):
        """测试不同输入的图执行"""
        test_cases = [
            {
                "input": "短输入",
                "expected_contains": ["短文本:", "已处理"]
            },
            {
                "input": "这是一个很长的输入数据用于测试图的执行",
                "expected_contains": ["长文本:", "已处理"]
            }
        ]

        for case in test_cases:
            with self.subTest(input_data=case["input"]):
                initial_state = {
                    "input_data": case["input"],
                    "processed_data": "",
                    "step_count": 0,
                    "test_results": {}
                }

                result = self.app.invoke(initial_state)

                for expected in case["expected_contains"]:
                    self.assertIn(expected, result["processed_data"])

    def test_graph_streaming(self):
        """测试图的流式执行"""
        initial_state = {
            "input_data": "流式测试",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        events = list(self.app.stream(initial_state))

        # 验证流式输出
        self.assertGreater(len(events), 0)

        # 验证每个事件
        node_names = []
        for event in events:
            self.assertIsInstance(event, dict)
            node_names.extend(event.keys())

        self.assertIn("process", node_names)
        self.assertIn("condition", node_names)

    async def test_async_graph_execution(self):
        """测试异步图执行"""
        initial_state = {
            "input_data": "异步测试",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = await self.app.ainvoke(initial_state)

        self.assertEqual(result["step_count"], 2)
        self.assertIn("已处理", result["processed_data"])
```

### 2. 条件路由测试

```python
def routing_condition(state: TestState) -> str:
    """路由条件函数"""
    if state["step_count"] < 2:
        return "continue"
    elif len(state["input_data"]) > 10:
        return "long_processing"
    else:
        return "short_processing"

def long_processing_node(state: TestState) -> TestState:
    """长文本处理节点"""
    return {
        **state,
        "processed_data": f"长文本处理: {state['input_data'][:20]}...",
        "step_count": state["step_count"] + 1
    }

def short_processing_node(state: TestState) -> TestState:
    """短文本处理节点"""
    return {
        **state,
        "processed_data": f"短文本处理: {state['input_data']}",
        "step_count": state["step_count"] + 1
    }

def create_conditional_graph():
    """创建条件路由图"""
    graph = StateGraph(TestState)

    graph.add_node("initial", simple_processing_node)
    graph.add_node("long_proc", long_processing_node)
    graph.add_node("short_proc", short_processing_node)

    graph.add_edge(START, "initial")
    graph.add_conditional_edges(
        "initial",
        routing_condition,
        {
            "continue": "initial",  # 循环
            "long_processing": "long_proc",
            "short_processing": "short_proc"
        }
    )
    graph.add_edge("long_proc", END)
    graph.add_edge("short_proc", END)

    return graph.compile()

class TestConditionalRouting(LangGraphTestCase):
    """条件路由测试"""

    def setUp(self):
        super().setUp()
        self.app = create_conditional_graph()

    def test_short_text_routing(self):
        """测试短文本路由"""
        initial_state = {
            "input_data": "短文本",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = self.app.invoke(initial_state)

        self.assertIn("短文本处理:", result["processed_data"])
        self.assertEqual(result["step_count"], 3)  # initial执行2次 + short_proc执行1次

    def test_long_text_routing(self):
        """测试长文本路由"""
        initial_state = {
            "input_data": "这是一个很长的文本用于测试条件路由功能",
            "processed_data": "",
            "step_count": 0,
            "test_results": {}
        }

        result = self.app.invoke(initial_state)

        self.assertIn("长文本处理:", result["processed_data"])
        self.assertEqual(result["step_count"], 3)

    def test_routing_condition_directly(self):
        """直接测试路由条件函数"""
        # 测试不同的路由条件
        test_cases = [
            {
                "state": {"step_count": 0, "input_data": "test"},
                "expected": "continue"
            },
            {
                "state": {"step_count": 1, "input_data": "test"},
                "expected": "continue"
            },
            {
                "state": {"step_count": 2, "input_data": "short"},
                "expected": "short_processing"
            },
            {
                "state": {"step_count": 2, "input_data": "very long text for testing"},
                "expected": "long_processing"
            }
        ]

        for case in test_cases:
            with self.subTest(state=case["state"]):
                result = routing_condition(case["state"])
                self.assertEqual(result, case["expected"])
```

## 🤖 LLM 集成测试

### 1. 模拟 LLM 响应

```python
from langchain_core.messages import HumanMessage, AIMessage
from unittest.mock import AsyncMock

class MockLLM:
    """模拟 LLM"""

    def __init__(self, responses: List[str]):
        self.responses = responses
        self.call_count = 0

    def invoke(self, messages):
        """同步调用"""
        if self.call_count < len(self.responses):
            response = self.responses[self.call_count]
            self.call_count += 1
            return AIMessage(content=response)
        else:
            return AIMessage(content="默认响应")

    async def ainvoke(self, messages):
        """异步调用"""
        return self.invoke(messages)

def llm_processing_node(state: TestState) -> TestState:
    """LLM 处理节点"""
    from langchain_openai import ChatOpenAI

    # 在实际使用中会是真实的LLM
    # llm = ChatOpenAI(model="gpt-3.5-turbo")

    # 测试中使用模拟LLM
    llm = state.get("mock_llm")
    if not llm:
        raise ValueError("测试中需要提供mock_llm")

    messages = [HumanMessage(content=f"处理这个文本: {state['input_data']}")]
    response = llm.invoke(messages)

    return {
        **state,
        "processed_data": response.content,
        "step_count": state["step_count"] + 1
    }

class TestLLMIntegration(LangGraphTestCase):
    """LLM 集成测试"""

    def test_llm_node_with_mock(self):
        """测试带模拟LLM的节点"""
        mock_llm = MockLLM(["这是模拟的LLM响应"])

        input_state = {
            "input_data": "测试输入",
            "processed_data": "",
            "step_count": 0,
            "test_results": {},
            "mock_llm": mock_llm
        }

        result = llm_processing_node(input_state)

        self.assertEqual(result["processed_data"], "这是模拟的LLM响应")
        self.assertEqual(mock_llm.call_count, 1)

    def test_llm_node_multiple_calls(self):
        """测试多次LLM调用"""
        mock_llm = MockLLM([
            "第一次响应",
            "第二次响应",
            "第三次响应"
        ])

        base_state = {
            "input_data": "测试",
            "processed_data": "",
            "step_count": 0,
            "test_results": {},
            "mock_llm": mock_llm
        }

        # 多次调用
        for i, expected_response in enumerate(["第一次响应", "第二次响应", "第三次响应"]):
            with self.subTest(call_number=i+1):
                result = llm_processing_node(base_state)
                self.assertEqual(result["processed_data"], expected_response)

    @patch('langchain_openai.ChatOpenAI')
    def test_llm_with_real_integration(self, mock_openai):
        """测试与真实LLM的集成（使用patch）"""
        # 设置模拟的ChatOpenAI
        mock_instance = Mock()
        mock_instance.invoke.return_value = AIMessage(content="真实集成测试响应")
        mock_openai.return_value = mock_instance

        # 修改节点以使用真实LLM
        def real_llm_node(state: TestState) -> TestState:
            from langchain_openai import ChatOpenAI
            llm = ChatOpenAI(model="gpt-3.5-turbo")
            messages = [HumanMessage(content=f"处理: {state['input_data']}")]
            response = llm.invoke(messages)

            return {
                **state,
                "processed_data": response.content,
                "step_count": state["step_count"] + 1
            }

        result = real_llm_node(self.test_state)

        # 验证ChatOpenAI被正确调用
        mock_openai.assert_called_once_with(model="gpt-3.5-turbo")
        self.assertEqual(result["processed_data"], "真实集成测试响应")
```

### 2. LLM 响应质量测试

```python
import re
from typing import List, Dict

class LLMResponseValidator:
    """LLM响应验证器"""

    @staticmethod
    def validate_response_format(response: str, expected_format: str) -> bool:
        """验证响应格式"""
        format_patterns = {
            "json": r'^\s*\{.*\}\s*$',
            "list": r'^\s*\[.*\]\s*$',
            "numbered_list": r'^\s*\d+\..*',
            "bullet_list": r'^\s*[-*•].*'
        }

        pattern = format_patterns.get(expected_format)
        if not pattern:
            return True  # 未知格式，跳过验证

        return bool(re.search(pattern, response, re.DOTALL))

    @staticmethod
    def validate_response_content(response: str, required_keywords: List[str]) -> Dict[str, bool]:
        """验证响应内容"""
        results = {}
        response_lower = response.lower()

        for keyword in required_keywords:
            results[keyword] = keyword.lower() in response_lower

        return results

    @staticmethod
    def validate_response_length(response: str, min_length: int = 10, max_length: int = 1000) -> bool:
        """验证响应长度"""
        return min_length <= len(response) <= max_length

def llm_quality_test_node(state: TestState) -> TestState:
    """LLM质量测试节点"""
    mock_llm = state.get("mock_llm")
    validator = LLMResponseValidator()

    messages = [HumanMessage(content=f"分析这个文本: {state['input_data']}")]
    response = mock_llm.invoke(messages)

    # 质量验证
    quality_results = {
        "format_valid": validator.validate_response_format(response.content, "text"),
        "length_valid": validator.validate_response_length(response.content),
        "content_check": validator.validate_response_content(
            response.content,
            ["分析", "文本", "结果"]
        )
    }

    return {
        **state,
        "processed_data": response.content,
        "test_results": {"quality": quality_results},
        "step_count": state["step_count"] + 1
    }

class TestLLMResponseQuality(LangGraphTestCase):
    """LLM响应质量测试"""

    def test_response_format_validation(self):
        """测试响应格式验证"""
        validator = LLMResponseValidator()

        test_cases = [
            ("{'key': 'value'}", "json", True),
            ("[1, 2, 3]", "list", True),
            ("1. 第一项\\n2. 第二项", "numbered_list", True),
            ("• 项目一\\n• 项目二", "bullet_list", True),
            ("普通文本", "json", False)
        ]

        for response, format_type, expected in test_cases:
            with self.subTest(response=response, format_type=format_type):
                result = validator.validate_response_format(response, format_type)
                self.assertEqual(result, expected)

    def test_response_content_validation(self):
        """测试响应内容验证"""
        validator = LLMResponseValidator()

        response = "这是一个关于文本分析的详细结果报告"
        required_keywords = ["文本", "分析", "结果", "报告"]

        results = validator.validate_response_content(response, required_keywords)

        # 验证所有关键词都被找到
        for keyword in required_keywords:
            self.assertTrue(results[keyword], f"关键词 '{keyword}' 未找到")

    def test_llm_quality_node(self):
        """测试LLM质量节点"""
        mock_llm = MockLLM([
            "这是一个详细的文本分析结果，包含了多项重要信息"
        ])

        input_state = {
            "input_data": "待分析的文本",
            "processed_data": "",
            "step_count": 0,
            "test_results": {},
            "mock_llm": mock_llm
        }

        result = llm_quality_test_node(input_state)

        # 验证质量检查结果
        quality = result["test_results"]["quality"]
        self.assertTrue(quality["format_valid"])
        self.assertTrue(quality["length_valid"])

        # 验证内容检查
        content_check = quality["content_check"]
        self.assertTrue(content_check["分析"])
        self.assertTrue(content_check["文本"])
        self.assertTrue(content_check["结果"])
```

## 📊 性能测试

### 1. 执行时间测试

```python
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

class PerformanceTestCase(LangGraphTestCase):
    """性能测试基类"""

    def time_execution(self, func, *args, **kwargs):
        """测量执行时间"""
        start_time = time.time()
        result = func(*args, **kwargs)
        execution_time = time.time() - start_time
        return result, execution_time

    def assert_execution_time(self, func, max_time: float, *args, **kwargs):
        """断言执行时间"""
        result, execution_time = self.time_execution(func, *args, **kwargs)
        self.assertLessEqual(
            execution_time,
            max_time,
            f"执行时间 {execution_time:.3f}s 超过限制 {max_time}s"
        )
        return result

class TestGraphPerformance(PerformanceTestCase):
    """图性能测试"""

    def test_single_execution_performance(self):
        """测试单次执行性能"""
        app = create_processing_graph()

        def execute_graph():
            return app.invoke({
                "input_data": "性能测试数据",
                "processed_data": "",
                "step_count": 0,
                "test_results": {}
            })

        # 执行时间应该在1秒内
        result = self.assert_execution_time(execute_graph, 1.0)
        self.assertEqual(result["step_count"], 2)

    def test_batch_execution_performance(self):
        """测试批量执行性能"""
        app = create_processing_graph()

        def execute_batch(batch_size: int):
            results = []
            for i in range(batch_size):
                result = app.invoke({
                    "input_data": f"测试数据_{i}",
                    "processed_data": "",
                    "step_count": 0,
                    "test_results": {}
                })
                results.append(result)
            return results

        # 10次执行应该在5秒内完成
        results = self.assert_execution_time(execute_batch, 5.0, 10)
        self.assertEqual(len(results), 10)

    def test_concurrent_execution_performance(self):
        """测试并发执行性能"""
        app = create_processing_graph()

        def single_execution(index: int):
            return app.invoke({
                "input_data": f"并发测试_{index}",
                "processed_data": "",
                "step_count": 0,
                "test_results": {}
            })

        def concurrent_execution(num_threads: int):
            with ThreadPoolExecutor(max_workers=num_threads) as executor:
                futures = [executor.submit(single_execution, i) for i in range(num_threads)]
                results = [future.result() for future in as_completed(futures)]
            return results

        # 5个并发执行应该在3秒内完成
        results = self.assert_execution_time(concurrent_execution, 3.0, 5)
        self.assertEqual(len(results), 5)
```

### 2. 内存使用测试

```python
import psutil
import gc

class MemoryTestCase(LangGraphTestCase):
    """内存测试基类"""

    def setUp(self):
        super().setUp()
        gc.collect()  # 强制垃圾回收
        self.initial_memory = self.get_memory_usage()

    def get_memory_usage(self) -> float:
        """获取当前内存使用量（MB）"""
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def assert_memory_increase(self, func, max_increase_mb: float, *args, **kwargs):
        """断言内存增长"""
        memory_before = self.get_memory_usage()
        result = func(*args, **kwargs)
        gc.collect()
        memory_after = self.get_memory_usage()

        memory_increase = memory_after - memory_before
        self.assertLessEqual(
            memory_increase,
            max_increase_mb,
            f"内存增长 {memory_increase:.2f}MB 超过限制 {max_increase_mb}MB"
        )
        return result

class TestGraphMemoryUsage(MemoryTestCase):
    """图内存使用测试"""

    def test_single_execution_memory(self):
        """测试单次执行内存使用"""
        app = create_processing_graph()

        def execute_with_large_data():
            large_data = "大数据" * 10000  # 创建较大的数据
            return app.invoke({
                "input_data": large_data,
                "processed_data": "",
                "step_count": 0,
                "test_results": {}
            })

        # 内存增长应该不超过10MB
        result = self.assert_memory_increase(execute_with_large_data, 10.0)
        self.assertIn("已处理", result["processed_data"])

    def test_repeated_execution_memory_leak(self):
        """测试重复执行的内存泄漏"""
        app = create_processing_graph()

        def repeated_execution(count: int):
            results = []
            for i in range(count):
                result = app.invoke({
                    "input_data": f"重复测试_{i}",
                    "processed_data": "",
                    "step_count": 0,
                    "test_results": {}
                })
                results.append(result)

                # 定期清理
                if i % 10 == 0:
                    gc.collect()

            return results

        # 100次重复执行，内存增长应该控制在20MB内
        results = self.assert_memory_increase(repeated_execution, 20.0, 100)
        self.assertEqual(len(results), 100)
```

## 🚀 持续集成测试

### 1. 测试配置文件

```python
# pytest.ini 配置
"""
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    --verbose
    --tb=short
    --cov=src
    --cov-report=html
    --cov-report=term
    --asyncio-mode=auto
markers =
    unit: 单元测试
    integration: 集成测试
    performance: 性能测试
    llm: LLM相关测试
"""

# conftest.py - pytest配置
import pytest
import asyncio
from typing import Generator

@pytest.fixture(scope="session")
def event_loop() -> Generator:
    """创建事件循环"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def test_data_manager():
    """测试数据管理器夹具"""
    return TestDataManager()

@pytest.fixture
def mock_llm():
    """模拟LLM夹具"""
    return MockLLM(["默认测试响应"])

@pytest.fixture(autouse=True)
def setup_test_environment():
    """自动设置测试环境"""
    # 测试前设置
    import os
    os.environ["TESTING"] = "true"

    yield

    # 测试后清理
    if "TESTING" in os.environ:
        del os.environ["TESTING"]
```

### 2. GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: LangGraph Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9, 3.10, 3.11]

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov pytest-asyncio
        pip install -r requirements.txt

    - name: Run unit tests
      run: |
        pytest tests/unit -m "unit" --cov=src --cov-report=xml

    - name: Run integration tests
      run: |
        pytest tests/integration -m "integration"

    - name: Run performance tests
      run: |
        pytest tests/performance -m "performance" --timeout=60

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
```

## 📈 测试指标和报告

### 1. 测试覆盖率分析

```python
import coverage
import json
from pathlib import Path

class TestCoverageAnalyzer:
    """测试覆盖率分析器"""

    def __init__(self):
        self.cov = coverage.Coverage()

    def start_coverage(self):
        """开始覆盖率测量"""
        self.cov.start()

    def stop_coverage(self):
        """停止覆盖率测量"""
        self.cov.stop()
        self.cov.save()

    def generate_report(self, output_dir: str = "coverage_report"):
        """生成覆盖率报告"""
        Path(output_dir).mkdir(exist_ok=True)

        # HTML报告
        self.cov.html_report(directory=output_dir)

        # JSON报告
        json_file = Path(output_dir) / "coverage.json"
        with open(json_file, 'w') as f:
            json.dump(self.cov.get_data().to_json(), f, indent=2)

        # 控制台报告
        print("\n📊 测试覆盖率报告:")
        self.cov.report()

    def get_coverage_summary(self) -> dict:
        """获取覆盖率摘要"""
        report = self.cov.report(show_missing=False)
        return {
            "statements": self.cov.get_data().line_counts(),
            "missing": self.cov.get_data().missing_lines(),
            "coverage_percent": report
        }

# 使用示例
def run_tests_with_coverage():
    """运行带覆盖率的测试"""
    analyzer = TestCoverageAnalyzer()

    analyzer.start_coverage()

    try:
        # 运行所有测试
        import unittest
        loader = unittest.TestLoader()
        suite = loader.discover('tests')
        runner = unittest.TextTestRunner(verbosity=2)
        result = runner.run(suite)

    finally:
        analyzer.stop_coverage()
        analyzer.generate_report()
        summary = analyzer.get_coverage_summary()
        print(f"总体覆盖率: {summary['coverage_percent']}%")
```

### 2. 测试报告生成

```python
import json
import html
from datetime import datetime
from typing import List, Dict

class TestReportGenerator:
    """测试报告生成器"""

    def __init__(self):
        self.test_results = []
        self.start_time = None
        self.end_time = None

    def start_test_run(self):
        """开始测试运行"""
        self.start_time = datetime.now()
        self.test_results = []

    def add_test_result(self, test_name: str, status: str, duration: float,
                       error_message: str = None, details: dict = None):
        """添加测试结果"""
        result = {
            "test_name": test_name,
            "status": status,  # "passed", "failed", "skipped"
            "duration": duration,
            "timestamp": datetime.now().isoformat(),
            "error_message": error_message,
            "details": details or {}
        }
        self.test_results.append(result)

    def end_test_run(self):
        """结束测试运行"""
        self.end_time = datetime.now()

    def generate_html_report(self, output_file: str = "test_report.html"):
        """生成HTML测试报告"""
        total_tests = len(self.test_results)
        passed_tests = len([r for r in self.test_results if r["status"] == "passed"])
        failed_tests = len([r for r in self.test_results if r["status"] == "failed"])
        skipped_tests = len([r for r in self.test_results if r["status"] == "skipped"])

        total_duration = sum(r["duration"] for r in self.test_results)
        run_duration = (self.end_time - self.start_time).total_seconds() if self.end_time else 0

        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>LangGraph 测试报告</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .summary {{ background-color: #f0f0f0; padding: 15px; margin-bottom: 20px; }}
                .passed {{ color: green; }}
                .failed {{ color: red; }}
                .skipped {{ color: orange; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                .error {{ background-color: #ffe6e6; }}
            </style>
        </head>
        <body>
            <h1>LangGraph 测试报告</h1>

            <div class="summary">
                <h2>测试摘要</h2>
                <p><strong>总测试数:</strong> {total_tests}</p>
                <p><strong class="passed">通过:</strong> {passed_tests}</p>
                <p><strong class="failed">失败:</strong> {failed_tests}</p>
                <p><strong class="skipped">跳过:</strong> {skipped_tests}</p>
                <p><strong>成功率:</strong> {(passed_tests/total_tests*100):.1f}%</p>
                <p><strong>总执行时间:</strong> {total_duration:.2f}s</p>
                <p><strong>运行时间:</strong> {run_duration:.2f}s</p>
                <p><strong>开始时间:</strong> {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p><strong>结束时间:</strong> {self.end_time.strftime('%Y-%m-%d %H:%M:%S') if self.end_time else 'N/A'}</p>
            </div>

            <h2>详细结果</h2>
            <table>
                <tr>
                    <th>测试名称</th>
                    <th>状态</th>
                    <th>执行时间 (s)</th>
                    <th>错误信息</th>
                </tr>
        """

        for result in self.test_results:
            status_class = result["status"]
            error_display = html.escape(result["error_message"] or "") if result["error_message"] else ""

            html_content += f"""
                <tr class="{status_class}">
                    <td>{html.escape(result['test_name'])}</td>
                    <td><strong class="{status_class}">{result['status'].upper()}</strong></td>
                    <td>{result['duration']:.3f}</td>
                    <td class="{'error' if result['error_message'] else ''}">{error_display}</td>
                </tr>
            """

        html_content += """
            </table>
        </body>
        </html>
        """

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

        print(f"📄 HTML报告已生成: {output_file}")

    def generate_json_report(self, output_file: str = "test_report.json"):
        """生成JSON测试报告"""
        report = {
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "total_duration": (self.end_time - self.start_time).total_seconds() if self.end_time and self.start_time else 0,
            "summary": {
                "total": len(self.test_results),
                "passed": len([r for r in self.test_results if r["status"] == "passed"]),
                "failed": len([r for r in self.test_results if r["status"] == "failed"]),
                "skipped": len([r for r in self.test_results if r["status"] == "skipped"])
            },
            "results": self.test_results
        }

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)

        print(f"📊 JSON报告已生成: {output_file}")
```

## 🎯 测试最佳实践总结

### 1. 测试策略检查清单

```python
def testing_strategy_checklist():
    """测试策略检查清单"""
    checklist = [
        "✅ 每个节点函数都有单元测试",
        "✅ 图的执行路径都有集成测试",
        "✅ 条件路由逻辑都有测试覆盖",
        "✅ 外部依赖都使用了模拟",
        "✅ LLM响应质量有验证机制",
        "✅ 性能关键路径有性能测试",
        "✅ 内存使用有监控和限制",
        "✅ 错误情况都有测试覆盖",
        "✅ 异步执行有专门测试",
        "✅ 测试数据管理规范化",
        "✅ 持续集成配置完善",
        "✅ 测试报告自动生成"
    ]

    print("🧪 测试策略检查清单:")
    for item in checklist:
        print(f"  {item}")

testing_strategy_checklist()
```

## 📚 延伸阅读

- [pytest 官方文档](https://docs.pytest.org/)
- [Python unittest 指南](https://docs.python.org/3/library/unittest.html)
- [LangSmith 评估文档](https://docs.smith.langchain.com/)
- [软件测试最佳实践](https://testing.googleblog.com/)

---

💡 **小贴士**：好的测试是代码质量的保证。投入时间编写全面的测试，会在长期开发中节省大量调试时间！
# LangGraph 错误处理

> 🎯 **学习目标**：掌握 LangGraph 中常见错误的识别、处理和预防，构建健壮的应用程序

## 🚨 常见错误类型

### 1. GRAPH_RECURSION_LIMIT 错误

这是最常见的错误之一，通常由无限循环引起。

```python
from langgraph import StateGraph, START, END
from typing import TypedDict

class LoopState(TypedDict):
    counter: int
    max_count: int

def problematic_node(state: LoopState) -> LoopState:
    """容易产生无限循环的节点"""
    return {
        "counter": state["counter"] + 1,
        "max_count": state["max_count"]
    }

def should_continue(state: LoopState) -> str:
    """错误的条件函数 - 永远返回 continue"""
    # ❌ 错误：没有终止条件
    return "continue"

# ❌ 这会导致 GRAPH_RECURSION_LIMIT 错误
def create_infinite_loop_graph():
    graph = StateGraph(LoopState)
    graph.add_node("loop_node", problematic_node)
    graph.add_conditional_edges(
        "loop_node",
        should_continue,
        {
            "continue": "loop_node",
            "end": END
        }
    )
    graph.set_entry_point("loop_node")
    return graph.compile()

# ✅ 正确的解决方案
def fixed_should_continue(state: LoopState) -> str:
    """正确的条件函数 - 有明确的终止条件"""
    if state["counter"] >= state["max_count"]:
        return "end"
    return "continue"

def create_safe_loop_graph():
    """安全的循环图"""
    graph = StateGraph(LoopState)
    graph.add_node("loop_node", problematic_node)
    graph.add_conditional_edges(
        "loop_node",
        fixed_should_continue,  # 使用修复后的条件函数
        {
            "continue": "loop_node",
            "end": END
        }
    )
    graph.set_entry_point("loop_node")

    # 设置递归限制作为安全措施
    return graph.compile(debug=True)

# 安全的执行方式
try:
    app = create_safe_loop_graph()
    result = app.invoke({
        "counter": 0,
        "max_count": 5  # 明确的终止条件
    })
    print(f"✅ 执行成功: {result}")
except RecursionError as e:
    print(f"❌ 递归错误: {e}")
    print("💡 检查循环条件是否有明确的终止逻辑")
```

### 2. INVALID_CONCURRENT_GRAPH_UPDATE 错误

当多个节点同时更新同一个状态字段时会出现此错误。

```python
from typing import TypedDict, List, Annotated
from langgraph import StateGraph
from operator import add

class ConcurrentState(TypedDict):
    messages: List[str]
    counter: int
    parallel_results: Annotated[List[str], add]  # 使用 reducer

def node_a(state: ConcurrentState) -> ConcurrentState:
    """节点 A"""
    return {
        "messages": state["messages"],
        "counter": state["counter"] + 1,  # ❌ 这里会冲突
        "parallel_results": ["A的结果"]
    }

def node_b(state: ConcurrentState) -> ConcurrentState:
    """节点 B"""
    return {
        "messages": state["messages"],
        "counter": state["counter"] + 2,  # ❌ 这里会冲突
        "parallel_results": ["B的结果"]
    }

# ❌ 错误的图设计 - 会导致并发更新冲突
def create_problematic_parallel_graph():
    graph = StateGraph(ConcurrentState)
    graph.add_node("node_a", node_a)
    graph.add_node("node_b", node_b)

    # 同时执行两个节点
    graph.add_edge(START, "node_a")
    graph.add_edge(START, "node_b")
    graph.add_edge("node_a", END)
    graph.add_edge("node_b", END)

    return graph.compile()

# ✅ 解决方案 1：使用 reducer
class SafeConcurrentState(TypedDict):
    messages: List[str]
    counter: Annotated[int, add]  # 使用 add reducer
    parallel_results: Annotated[List[str], add]

def safe_node_a(state: SafeConcurrentState) -> SafeConcurrentState:
    """安全的节点 A"""
    return {
        "messages": state["messages"],
        "counter": 1,  # ✅ 会被累加
        "parallel_results": ["A的结果"]
    }

def safe_node_b(state: SafeConcurrentState) -> SafeConcurrentState:
    """安全的节点 B"""
    return {
        "messages": state["messages"],
        "counter": 2,  # ✅ 会被累加
        "parallel_results": ["B的结果"]
    }

def create_safe_parallel_graph():
    """安全的并行图"""
    graph = StateGraph(SafeConcurrentState)
    graph.add_node("safe_node_a", safe_node_a)
    graph.add_node("safe_node_b", safe_node_b)

    graph.add_edge(START, "safe_node_a")
    graph.add_edge(START, "safe_node_b")
    graph.add_edge("safe_node_a", END)
    graph.add_edge("safe_node_b", END)

    return graph.compile()

# ✅ 解决方案 2：避免并发更新同一字段
def alternative_safe_node_a(state: ConcurrentState) -> ConcurrentState:
    """只更新不冲突的字段"""
    return {
        "parallel_results": ["A的结果"]
        # 不更新 counter，避免冲突
    }

def alternative_safe_node_b(state: ConcurrentState) -> ConcurrentState:
    """只更新不冲突的字段"""
    return {
        "parallel_results": ["B的结果"]
        # 不更新 counter，避免冲突
    }
```

### 3. INVALID_GRAPH_NODE_RETURN_VALUE 错误

节点必须返回字典类型。

```python
from typing import TypedDict

class SimpleState(TypedDict):
    value: str

# ❌ 错误的节点返回值
def bad_node_string(state: SimpleState) -> str:
    """错误：返回字符串而不是字典"""
    return "这是错误的返回值"

def bad_node_none(state: SimpleState) -> None:
    """错误：返回 None"""
    print("处理中...")
    # 没有返回值

def bad_node_tuple(state: SimpleState) -> tuple:
    """错误：返回元组"""
    return ("value", "processed")

# ✅ 正确的节点返回值
def good_node(state: SimpleState) -> SimpleState:
    """正确：返回字典"""
    return {
        "value": f"处理后的: {state['value']}"
    }

def good_node_partial_update(state: SimpleState) -> dict:
    """正确：返回部分状态更新"""
    return {
        "value": f"部分更新: {state['value']}"
    }

# 错误处理包装器
def safe_node_wrapper(node_func):
    """节点安全包装器"""
    def wrapper(state):
        try:
            result = node_func(state)

            # 验证返回值类型
            if not isinstance(result, dict):
                raise ValueError(f"节点 {node_func.__name__} 必须返回字典，但返回了 {type(result)}")

            return result

        except Exception as e:
            print(f"❌ 节点 {node_func.__name__} 执行失败: {e}")
            # 返回一个安全的默认状态
            return state

    return wrapper

# 使用安全包装器
@safe_node_wrapper
def potentially_problematic_node(state: SimpleState) -> SimpleState:
    """可能有问题的节点"""
    if len(state["value"]) > 100:
        # 这里可能会出错
        raise ValueError("值太长")

    return {
        "value": f"安全处理: {state['value']}"
    }
```

### 4. INVALID_CHAT_HISTORY 错误

在使用 `create_react_agent` 时，消息格式不正确。

```python
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langgraph.prebuilt import create_react_agent
from langchain_openai import ChatOpenAI

# ❌ 错误的消息格式
def create_bad_chat_history():
    """错误的聊天历史格式"""
    return [
        "Hello",  # ❌ 应该是 Message 对象
        {"role": "user", "content": "Hi"},  # ❌ 字典格式不对
        HumanMessage(content=""),  # ❌ 空内容
    ]

# ✅ 正确的消息格式
def create_good_chat_history():
    """正确的聊天历史格式"""
    return [
        SystemMessage(content="你是一个有帮助的助手"),
        HumanMessage(content="你好"),
        AIMessage(content="你好！我可以为你做什么？"),
        HumanMessage(content="帮我解决一个问题")
    ]

# 消息验证器
class MessageValidator:
    """消息格式验证器"""

    @staticmethod
    def validate_message(message) -> bool:
        """验证单个消息格式"""
        from langchain_core.messages import BaseMessage

        if not isinstance(message, BaseMessage):
            print(f"❌ 消息类型错误: {type(message)}，应该是 BaseMessage 的子类")
            return False

        if not message.content or not message.content.strip():
            print(f"❌ 消息内容为空: {message}")
            return False

        return True

    @staticmethod
    def validate_chat_history(messages) -> bool:
        """验证聊天历史"""
        if not isinstance(messages, list):
            print(f"❌ 聊天历史应该是列表，但是: {type(messages)}")
            return False

        if not messages:
            print("⚠️  聊天历史为空")
            return True

        for i, message in enumerate(messages):
            if not MessageValidator.validate_message(message):
                print(f"❌ 第 {i} 条消息验证失败")
                return False

        return True

    @staticmethod
    def fix_chat_history(messages) -> list:
        """修复聊天历史格式"""
        fixed_messages = []

        for message in messages:
            if isinstance(message, str):
                # 字符串转为 HumanMessage
                if message.strip():
                    fixed_messages.append(HumanMessage(content=message))
            elif isinstance(message, dict):
                # 字典转为相应的 Message 对象
                role = message.get("role", "user")
                content = message.get("content", "")

                if content.strip():
                    if role == "system":
                        fixed_messages.append(SystemMessage(content=content))
                    elif role == "assistant":
                        fixed_messages.append(AIMessage(content=content))
                    else:
                        fixed_messages.append(HumanMessage(content=content))
            else:
                # 已经是正确格式的消息
                if hasattr(message, 'content') and message.content.strip():
                    fixed_messages.append(message)

        return fixed_messages

# 使用验证器
def safe_create_react_agent():
    """安全创建 React Agent"""
    try:
        # 准备消息
        messages = create_good_chat_history()

        # 验证消息格式
        if not MessageValidator.validate_chat_history(messages):
            print("🔧 修复消息格式...")
            messages = MessageValidator.fix_chat_history(messages)

        # 创建 LLM
        llm = ChatOpenAI(model="gpt-3.5-turbo")

        # 创建 agent
        agent = create_react_agent(llm, tools=[])

        return agent

    except Exception as e:
        print(f"❌ 创建 React Agent 失败: {e}")
        return None
```

## 🛡️ 防御性编程

### 1. 输入验证

```python
from typing import TypedDict, Any, Optional
import json

class ValidationState(TypedDict):
    input_data: Any
    validated_data: Optional[dict]
    errors: list

def input_validator(state: ValidationState) -> ValidationState:
    """输入验证节点"""
    errors = []
    validated_data = None

    try:
        input_data = state["input_data"]

        # 验证输入不为空
        if input_data is None:
            errors.append("输入数据不能为空")

        # 验证数据类型
        elif not isinstance(input_data, (dict, str)):
            errors.append(f"输入数据类型错误: {type(input_data)}")

        # 如果是字符串，尝试解析为 JSON
        elif isinstance(input_data, str):
            try:
                validated_data = json.loads(input_data)
            except json.JSONDecodeError as e:
                errors.append(f"JSON 解析错误: {e}")

        # 如果是字典，直接使用
        else:
            validated_data = input_data

        # 验证必需字段
        if validated_data:
            required_fields = ["id", "content"]
            for field in required_fields:
                if field not in validated_data:
                    errors.append(f"缺少必需字段: {field}")

    except Exception as e:
        errors.append(f"验证过程出错: {e}")

    return {
        "input_data": state["input_data"],
        "validated_data": validated_data,
        "errors": errors
    }

def processing_node(state: ValidationState) -> ValidationState:
    """处理节点 - 只处理验证通过的数据"""
    if state["errors"]:
        print(f"⚠️  跳过处理，存在验证错误: {state['errors']}")
        return state

    if not state["validated_data"]:
        print("⚠️  没有有效数据可处理")
        return state

    # 安全处理数据
    try:
        processed_content = f"已处理: {state['validated_data']['content']}"

        return {
            "input_data": state["input_data"],
            "validated_data": {
                **state["validated_data"],
                "content": processed_content,
                "processed": True
            },
            "errors": state["errors"]
        }

    except Exception as e:
        return {
            "input_data": state["input_data"],
            "validated_data": state["validated_data"],
            "errors": state["errors"] + [f"处理错误: {e}"]
        }
```

### 2. 超时和重试机制

```python
import time
import random
from functools import wraps

def retry_with_backoff(max_retries: int = 3, backoff_factor: float = 1.0):
    """重试装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e

                    if attempt == max_retries:
                        print(f"❌ 最终失败 (尝试 {attempt + 1} 次): {e}")
                        raise e

                    # 计算退避时间
                    backoff_time = backoff_factor * (2 ** attempt) + random.uniform(0, 1)
                    print(f"🔄 重试 {attempt + 1}/{max_retries}，等待 {backoff_time:.2f}s: {e}")
                    time.sleep(backoff_time)

            raise last_exception

        return wrapper
    return decorator

def timeout_handler(timeout_seconds: int = 30):
    """超时处理装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            import signal

            def timeout_signal_handler(signum, frame):
                raise TimeoutError(f"函数 {func.__name__} 执行超时 ({timeout_seconds}s)")

            # 设置超时信号
            old_handler = signal.signal(signal.SIGALRM, timeout_signal_handler)
            signal.alarm(timeout_seconds)

            try:
                result = func(*args, **kwargs)
                signal.alarm(0)  # 取消超时
                return result
            except TimeoutError:
                print(f"⏰ 函数 {func.__name__} 执行超时")
                raise
            finally:
                signal.signal(signal.SIGALRM, old_handler)

        return wrapper
    return decorator

# 使用重试和超时
@retry_with_backoff(max_retries=3, backoff_factor=0.5)
@timeout_handler(timeout_seconds=10)
def unreliable_api_call(data: dict) -> dict:
    """模拟不可靠的 API 调用"""
    # 模拟随机失败
    if random.random() < 0.7:  # 70% 失败率
        raise ConnectionError("API 连接失败")

    # 模拟处理时间
    time.sleep(2)

    return {"result": f"处理成功: {data}"}

def robust_api_node(state: dict) -> dict:
    """具有重试和超时的 API 节点"""
    try:
        result = unreliable_api_call(state.get("api_data", {}))

        return {
            **state,
            "api_result": result,
            "api_status": "success"
        }

    except TimeoutError:
        return {
            **state,
            "api_result": None,
            "api_status": "timeout"
        }

    except Exception as e:
        return {
            **state,
            "api_result": None,
            "api_status": f"error: {e}"
        }
```

### 3. 资源管理和清理

```python
import tempfile
import os
from contextlib import contextmanager

class ResourceManager:
    """资源管理器"""

    def __init__(self):
        self.resources = []

    @contextmanager
    def managed_resource(self, resource_factory, cleanup_func=None):
        """管理资源的上下文管理器"""
        resource = None
        try:
            resource = resource_factory()
            self.resources.append((resource, cleanup_func))
            yield resource
        finally:
            if resource and cleanup_func:
                try:
                    cleanup_func(resource)
                except Exception as e:
                    print(f"⚠️  清理资源时出错: {e}")

    def cleanup_all(self):
        """清理所有资源"""
        for resource, cleanup_func in self.resources:
            if cleanup_func:
                try:
                    cleanup_func(resource)
                except Exception as e:
                    print(f"⚠️  清理资源时出错: {e}")
        self.resources.clear()

# 全局资源管理器
resource_manager = ResourceManager()

def file_processing_node(state: dict) -> dict:
    """文件处理节点 - 带资源管理"""

    def create_temp_file():
        """创建临时文件"""
        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False)
        temp_file.write(str(state.get("data", "")))
        temp_file.close()
        return temp_file.name

    def cleanup_temp_file(file_path):
        """清理临时文件"""
        if os.path.exists(file_path):
            os.unlink(file_path)

    try:
        with resource_manager.managed_resource(
            create_temp_file,
            cleanup_temp_file
        ) as temp_file_path:

            # 处理文件
            with open(temp_file_path, 'r') as f:
                content = f.read()

            processed_content = f"文件处理结果: {content}"

            return {
                **state,
                "processed_content": processed_content,
                "temp_file_used": temp_file_path
            }

    except Exception as e:
        return {
            **state,
            "error": f"文件处理失败: {e}"
        }
```

## 🔧 错误恢复策略

### 1. 断路器模式

```python
import time
from enum import Enum

class CircuitBreakerState(Enum):
    CLOSED = "closed"      # 正常状态
    OPEN = "open"         # 断路状态
    HALF_OPEN = "half_open"  # 半开状态

class CircuitBreaker:
    """断路器实现"""

    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitBreakerState.CLOSED

    def call(self, func, *args, **kwargs):
        """通过断路器调用函数"""
        if self.state == CircuitBreakerState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitBreakerState.HALF_OPEN
                print("🔄 断路器进入半开状态")
            else:
                raise Exception("💥 断路器开启，拒绝调用")

        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e

    def _on_success(self):
        """成功时的处理"""
        self.failure_count = 0
        if self.state == CircuitBreakerState.HALF_OPEN:
            self.state = CircuitBreakerState.CLOSED
            print("✅ 断路器恢复到关闭状态")

    def _on_failure(self):
        """失败时的处理"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = CircuitBreakerState.OPEN
            print(f"⚡ 断路器开启 (失败 {self.failure_count} 次)")

# 使用断路器
api_circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30)

def circuit_breaker_node(state: dict) -> dict:
    """使用断路器的节点"""
    try:
        # 通过断路器调用不可靠的服务
        result = api_circuit_breaker.call(unreliable_api_call, state.get("data", {}))

        return {
            **state,
            "api_result": result,
            "circuit_breaker_state": api_circuit_breaker.state.value
        }

    except Exception as e:
        return {
            **state,
            "api_result": None,
            "error": str(e),
            "circuit_breaker_state": api_circuit_breaker.state.value
        }
```

## 📝 错误日志和监控

### 1. 结构化日志

```python
import logging
import json
from datetime import datetime

class StructuredLogger:
    """结构化日志记录器"""

    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)

        # 创建处理器
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def log_node_execution(self, node_name: str, state: dict, status: str, error: str = None):
        """记录节点执行日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "node_name": node_name,
            "status": status,
            "state_keys": list(state.keys()) if state else [],
            "state_size": len(str(state)) if state else 0
        }

        if error:
            log_entry["error"] = error
            self.logger.error(json.dumps(log_entry, ensure_ascii=False))
        else:
            self.logger.info(json.dumps(log_entry, ensure_ascii=False))

    def log_graph_execution(self, graph_name: str, input_state: dict, output_state: dict,
                          execution_time: float, success: bool):
        """记录图执行日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "graph_name": graph_name,
            "success": success,
            "execution_time": execution_time,
            "input_keys": list(input_state.keys()) if input_state else [],
            "output_keys": list(output_state.keys()) if output_state else []
        }

        if success:
            self.logger.info(f"GRAPH_SUCCESS: {json.dumps(log_entry, ensure_ascii=False)}")
        else:
            self.logger.error(f"GRAPH_FAILURE: {json.dumps(log_entry, ensure_ascii=False)}")

# 全局日志器
app_logger = StructuredLogger("langgraph_app")

def logged_node(node_name: str):
    """节点日志装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(state):
            try:
                app_logger.log_node_execution(node_name, state, "started")
                result = func(state)
                app_logger.log_node_execution(node_name, result, "completed")
                return result
            except Exception as e:
                app_logger.log_node_execution(node_name, state, "failed", str(e))
                raise
        return wrapper
    return decorator

# 使用日志装饰器
@logged_node("example_node")
def example_node(state: dict) -> dict:
    """示例节点"""
    return {
        **state,
        "processed": True
    }
```

## 🎯 最佳实践总结

### 1. 错误处理检查清单

```python
def error_handling_checklist():
    """错误处理检查清单"""
    checklist = [
        "✅ 所有节点都返回字典类型",
        "✅ 循环条件有明确的终止逻辑",
        "✅ 并发节点避免更新相同字段或使用 reducer",
        "✅ 输入数据进行了验证",
        "✅ 外部调用有超时和重试机制",
        "✅ 资源使用后进行了清理",
        "✅ 错误信息被正确记录",
        "✅ 有降级和恢复策略",
        "✅ 关键路径有监控和告警"
    ]

    print("🔍 错误处理检查清单:")
    for item in checklist:
        print(f"  {item}")

error_handling_checklist()
```

### 2. 错误处理模板

```python
def create_robust_node(node_name: str, process_func, validator_func=None):
    """创建健壮节点的模板"""

    @logged_node(node_name)
    @retry_with_backoff(max_retries=2)
    def robust_node(state: dict) -> dict:
        try:
            # 1. 输入验证
            if validator_func:
                validation_result = validator_func(state)
                if not validation_result["is_valid"]:
                    return {
                        **state,
                        "error": f"输入验证失败: {validation_result['errors']}"
                    }

            # 2. 执行处理
            result = process_func(state)

            # 3. 输出验证
            if not isinstance(result, dict):
                raise ValueError(f"节点必须返回字典，但返回了 {type(result)}")

            return result

        except Exception as e:
            # 4. 错误处理
            error_msg = f"{node_name} 执行失败: {e}"
            app_logger.log_node_execution(node_name, state, "failed", error_msg)

            # 返回安全的状态
            return {
                **state,
                "error": error_msg,
                f"{node_name}_failed": True
            }

    return robust_node
```

## 📚 延伸阅读

- [LangGraph 错误参考](https://langchain-ai.github.io/langgraph/troubleshooting/errors/)
- [Python 异常处理最佳实践](https://realpython.com/python-exceptions-handling/)
- [断路器模式详解](https://martinfowler.com/bliki/CircuitBreaker.html)

---

💡 **小贴士**：预防胜于治疗。在设计阶段就考虑可能的失败情况，比事后修复要有效得多！
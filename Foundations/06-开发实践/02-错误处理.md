# LangGraph é”™è¯¯å¤„ç†

> ğŸ¯ **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡ LangGraph ä¸­å¸¸è§é”™è¯¯çš„è¯†åˆ«ã€å¤„ç†å’Œé¢„é˜²ï¼Œæ„å»ºå¥å£®çš„åº”ç”¨ç¨‹åº

## ğŸš¨ å¸¸è§é”™è¯¯ç±»å‹

### 1. GRAPH_RECURSION_LIMIT é”™è¯¯

è¿™æ˜¯æœ€å¸¸è§çš„é”™è¯¯ä¹‹ä¸€ï¼Œé€šå¸¸ç”±æ— é™å¾ªç¯å¼•èµ·ã€‚

```python
from langgraph import StateGraph, START, END
from typing import TypedDict

class LoopState(TypedDict):
    counter: int
    max_count: int

def problematic_node(state: LoopState) -> LoopState:
    """å®¹æ˜“äº§ç”Ÿæ— é™å¾ªç¯çš„èŠ‚ç‚¹"""
    return {
        "counter": state["counter"] + 1,
        "max_count": state["max_count"]
    }

def should_continue(state: LoopState) -> str:
    """é”™è¯¯çš„æ¡ä»¶å‡½æ•° - æ°¸è¿œè¿”å› continue"""
    # âŒ é”™è¯¯ï¼šæ²¡æœ‰ç»ˆæ­¢æ¡ä»¶
    return "continue"

# âŒ è¿™ä¼šå¯¼è‡´ GRAPH_RECURSION_LIMIT é”™è¯¯
def create_infinite_loop_graph():
    graph = StateGraph(LoopState)
    graph.add_node("loop_node", problematic_node)
    graph.add_conditional_edges(
        "loop_node",
        should_continue,
        {
            "continue": "loop_node",
            "end": END
        }
    )
    graph.set_entry_point("loop_node")
    return graph.compile()

# âœ… æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆ
def fixed_should_continue(state: LoopState) -> str:
    """æ­£ç¡®çš„æ¡ä»¶å‡½æ•° - æœ‰æ˜ç¡®çš„ç»ˆæ­¢æ¡ä»¶"""
    if state["counter"] >= state["max_count"]:
        return "end"
    return "continue"

def create_safe_loop_graph():
    """å®‰å…¨çš„å¾ªç¯å›¾"""
    graph = StateGraph(LoopState)
    graph.add_node("loop_node", problematic_node)
    graph.add_conditional_edges(
        "loop_node",
        fixed_should_continue,  # ä½¿ç”¨ä¿®å¤åçš„æ¡ä»¶å‡½æ•°
        {
            "continue": "loop_node",
            "end": END
        }
    )
    graph.set_entry_point("loop_node")

    # è®¾ç½®é€’å½’é™åˆ¶ä½œä¸ºå®‰å…¨æªæ–½
    return graph.compile(debug=True)

# å®‰å…¨çš„æ‰§è¡Œæ–¹å¼
try:
    app = create_safe_loop_graph()
    result = app.invoke({
        "counter": 0,
        "max_count": 5  # æ˜ç¡®çš„ç»ˆæ­¢æ¡ä»¶
    })
    print(f"âœ… æ‰§è¡ŒæˆåŠŸ: {result}")
except RecursionError as e:
    print(f"âŒ é€’å½’é”™è¯¯: {e}")
    print("ğŸ’¡ æ£€æŸ¥å¾ªç¯æ¡ä»¶æ˜¯å¦æœ‰æ˜ç¡®çš„ç»ˆæ­¢é€»è¾‘")
```

### 2. INVALID_CONCURRENT_GRAPH_UPDATE é”™è¯¯

å½“å¤šä¸ªèŠ‚ç‚¹åŒæ—¶æ›´æ–°åŒä¸€ä¸ªçŠ¶æ€å­—æ®µæ—¶ä¼šå‡ºç°æ­¤é”™è¯¯ã€‚

```python
from typing import TypedDict, List, Annotated
from langgraph import StateGraph
from operator import add

class ConcurrentState(TypedDict):
    messages: List[str]
    counter: int
    parallel_results: Annotated[List[str], add]  # ä½¿ç”¨ reducer

def node_a(state: ConcurrentState) -> ConcurrentState:
    """èŠ‚ç‚¹ A"""
    return {
        "messages": state["messages"],
        "counter": state["counter"] + 1,  # âŒ è¿™é‡Œä¼šå†²çª
        "parallel_results": ["Açš„ç»“æœ"]
    }

def node_b(state: ConcurrentState) -> ConcurrentState:
    """èŠ‚ç‚¹ B"""
    return {
        "messages": state["messages"],
        "counter": state["counter"] + 2,  # âŒ è¿™é‡Œä¼šå†²çª
        "parallel_results": ["Bçš„ç»“æœ"]
    }

# âŒ é”™è¯¯çš„å›¾è®¾è®¡ - ä¼šå¯¼è‡´å¹¶å‘æ›´æ–°å†²çª
def create_problematic_parallel_graph():
    graph = StateGraph(ConcurrentState)
    graph.add_node("node_a", node_a)
    graph.add_node("node_b", node_b)

    # åŒæ—¶æ‰§è¡Œä¸¤ä¸ªèŠ‚ç‚¹
    graph.add_edge(START, "node_a")
    graph.add_edge(START, "node_b")
    graph.add_edge("node_a", END)
    graph.add_edge("node_b", END)

    return graph.compile()

# âœ… è§£å†³æ–¹æ¡ˆ 1ï¼šä½¿ç”¨ reducer
class SafeConcurrentState(TypedDict):
    messages: List[str]
    counter: Annotated[int, add]  # ä½¿ç”¨ add reducer
    parallel_results: Annotated[List[str], add]

def safe_node_a(state: SafeConcurrentState) -> SafeConcurrentState:
    """å®‰å…¨çš„èŠ‚ç‚¹ A"""
    return {
        "messages": state["messages"],
        "counter": 1,  # âœ… ä¼šè¢«ç´¯åŠ 
        "parallel_results": ["Açš„ç»“æœ"]
    }

def safe_node_b(state: SafeConcurrentState) -> SafeConcurrentState:
    """å®‰å…¨çš„èŠ‚ç‚¹ B"""
    return {
        "messages": state["messages"],
        "counter": 2,  # âœ… ä¼šè¢«ç´¯åŠ 
        "parallel_results": ["Bçš„ç»“æœ"]
    }

def create_safe_parallel_graph():
    """å®‰å…¨çš„å¹¶è¡Œå›¾"""
    graph = StateGraph(SafeConcurrentState)
    graph.add_node("safe_node_a", safe_node_a)
    graph.add_node("safe_node_b", safe_node_b)

    graph.add_edge(START, "safe_node_a")
    graph.add_edge(START, "safe_node_b")
    graph.add_edge("safe_node_a", END)
    graph.add_edge("safe_node_b", END)

    return graph.compile()

# âœ… è§£å†³æ–¹æ¡ˆ 2ï¼šé¿å…å¹¶å‘æ›´æ–°åŒä¸€å­—æ®µ
def alternative_safe_node_a(state: ConcurrentState) -> ConcurrentState:
    """åªæ›´æ–°ä¸å†²çªçš„å­—æ®µ"""
    return {
        "parallel_results": ["Açš„ç»“æœ"]
        # ä¸æ›´æ–° counterï¼Œé¿å…å†²çª
    }

def alternative_safe_node_b(state: ConcurrentState) -> ConcurrentState:
    """åªæ›´æ–°ä¸å†²çªçš„å­—æ®µ"""
    return {
        "parallel_results": ["Bçš„ç»“æœ"]
        # ä¸æ›´æ–° counterï¼Œé¿å…å†²çª
    }
```

### 3. INVALID_GRAPH_NODE_RETURN_VALUE é”™è¯¯

èŠ‚ç‚¹å¿…é¡»è¿”å›å­—å…¸ç±»å‹ã€‚

```python
from typing import TypedDict

class SimpleState(TypedDict):
    value: str

# âŒ é”™è¯¯çš„èŠ‚ç‚¹è¿”å›å€¼
def bad_node_string(state: SimpleState) -> str:
    """é”™è¯¯ï¼šè¿”å›å­—ç¬¦ä¸²è€Œä¸æ˜¯å­—å…¸"""
    return "è¿™æ˜¯é”™è¯¯çš„è¿”å›å€¼"

def bad_node_none(state: SimpleState) -> None:
    """é”™è¯¯ï¼šè¿”å› None"""
    print("å¤„ç†ä¸­...")
    # æ²¡æœ‰è¿”å›å€¼

def bad_node_tuple(state: SimpleState) -> tuple:
    """é”™è¯¯ï¼šè¿”å›å…ƒç»„"""
    return ("value", "processed")

# âœ… æ­£ç¡®çš„èŠ‚ç‚¹è¿”å›å€¼
def good_node(state: SimpleState) -> SimpleState:
    """æ­£ç¡®ï¼šè¿”å›å­—å…¸"""
    return {
        "value": f"å¤„ç†åçš„: {state['value']}"
    }

def good_node_partial_update(state: SimpleState) -> dict:
    """æ­£ç¡®ï¼šè¿”å›éƒ¨åˆ†çŠ¶æ€æ›´æ–°"""
    return {
        "value": f"éƒ¨åˆ†æ›´æ–°: {state['value']}"
    }

# é”™è¯¯å¤„ç†åŒ…è£…å™¨
def safe_node_wrapper(node_func):
    """èŠ‚ç‚¹å®‰å…¨åŒ…è£…å™¨"""
    def wrapper(state):
        try:
            result = node_func(state)

            # éªŒè¯è¿”å›å€¼ç±»å‹
            if not isinstance(result, dict):
                raise ValueError(f"èŠ‚ç‚¹ {node_func.__name__} å¿…é¡»è¿”å›å­—å…¸ï¼Œä½†è¿”å›äº† {type(result)}")

            return result

        except Exception as e:
            print(f"âŒ èŠ‚ç‚¹ {node_func.__name__} æ‰§è¡Œå¤±è´¥: {e}")
            # è¿”å›ä¸€ä¸ªå®‰å…¨çš„é»˜è®¤çŠ¶æ€
            return state

    return wrapper

# ä½¿ç”¨å®‰å…¨åŒ…è£…å™¨
@safe_node_wrapper
def potentially_problematic_node(state: SimpleState) -> SimpleState:
    """å¯èƒ½æœ‰é—®é¢˜çš„èŠ‚ç‚¹"""
    if len(state["value"]) > 100:
        # è¿™é‡Œå¯èƒ½ä¼šå‡ºé”™
        raise ValueError("å€¼å¤ªé•¿")

    return {
        "value": f"å®‰å…¨å¤„ç†: {state['value']}"
    }
```

### 4. INVALID_CHAT_HISTORY é”™è¯¯

åœ¨ä½¿ç”¨ `create_react_agent` æ—¶ï¼Œæ¶ˆæ¯æ ¼å¼ä¸æ­£ç¡®ã€‚

```python
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langgraph.prebuilt import create_react_agent
from langchain_openai import ChatOpenAI

# âŒ é”™è¯¯çš„æ¶ˆæ¯æ ¼å¼
def create_bad_chat_history():
    """é”™è¯¯çš„èŠå¤©å†å²æ ¼å¼"""
    return [
        "Hello",  # âŒ åº”è¯¥æ˜¯ Message å¯¹è±¡
        {"role": "user", "content": "Hi"},  # âŒ å­—å…¸æ ¼å¼ä¸å¯¹
        HumanMessage(content=""),  # âŒ ç©ºå†…å®¹
    ]

# âœ… æ­£ç¡®çš„æ¶ˆæ¯æ ¼å¼
def create_good_chat_history():
    """æ­£ç¡®çš„èŠå¤©å†å²æ ¼å¼"""
    return [
        SystemMessage(content="ä½ æ˜¯ä¸€ä¸ªæœ‰å¸®åŠ©çš„åŠ©æ‰‹"),
        HumanMessage(content="ä½ å¥½"),
        AIMessage(content="ä½ å¥½ï¼æˆ‘å¯ä»¥ä¸ºä½ åšä»€ä¹ˆï¼Ÿ"),
        HumanMessage(content="å¸®æˆ‘è§£å†³ä¸€ä¸ªé—®é¢˜")
    ]

# æ¶ˆæ¯éªŒè¯å™¨
class MessageValidator:
    """æ¶ˆæ¯æ ¼å¼éªŒè¯å™¨"""

    @staticmethod
    def validate_message(message) -> bool:
        """éªŒè¯å•ä¸ªæ¶ˆæ¯æ ¼å¼"""
        from langchain_core.messages import BaseMessage

        if not isinstance(message, BaseMessage):
            print(f"âŒ æ¶ˆæ¯ç±»å‹é”™è¯¯: {type(message)}ï¼Œåº”è¯¥æ˜¯ BaseMessage çš„å­ç±»")
            return False

        if not message.content or not message.content.strip():
            print(f"âŒ æ¶ˆæ¯å†…å®¹ä¸ºç©º: {message}")
            return False

        return True

    @staticmethod
    def validate_chat_history(messages) -> bool:
        """éªŒè¯èŠå¤©å†å²"""
        if not isinstance(messages, list):
            print(f"âŒ èŠå¤©å†å²åº”è¯¥æ˜¯åˆ—è¡¨ï¼Œä½†æ˜¯: {type(messages)}")
            return False

        if not messages:
            print("âš ï¸  èŠå¤©å†å²ä¸ºç©º")
            return True

        for i, message in enumerate(messages):
            if not MessageValidator.validate_message(message):
                print(f"âŒ ç¬¬ {i} æ¡æ¶ˆæ¯éªŒè¯å¤±è´¥")
                return False

        return True

    @staticmethod
    def fix_chat_history(messages) -> list:
        """ä¿®å¤èŠå¤©å†å²æ ¼å¼"""
        fixed_messages = []

        for message in messages:
            if isinstance(message, str):
                # å­—ç¬¦ä¸²è½¬ä¸º HumanMessage
                if message.strip():
                    fixed_messages.append(HumanMessage(content=message))
            elif isinstance(message, dict):
                # å­—å…¸è½¬ä¸ºç›¸åº”çš„ Message å¯¹è±¡
                role = message.get("role", "user")
                content = message.get("content", "")

                if content.strip():
                    if role == "system":
                        fixed_messages.append(SystemMessage(content=content))
                    elif role == "assistant":
                        fixed_messages.append(AIMessage(content=content))
                    else:
                        fixed_messages.append(HumanMessage(content=content))
            else:
                # å·²ç»æ˜¯æ­£ç¡®æ ¼å¼çš„æ¶ˆæ¯
                if hasattr(message, 'content') and message.content.strip():
                    fixed_messages.append(message)

        return fixed_messages

# ä½¿ç”¨éªŒè¯å™¨
def safe_create_react_agent():
    """å®‰å…¨åˆ›å»º React Agent"""
    try:
        # å‡†å¤‡æ¶ˆæ¯
        messages = create_good_chat_history()

        # éªŒè¯æ¶ˆæ¯æ ¼å¼
        if not MessageValidator.validate_chat_history(messages):
            print("ğŸ”§ ä¿®å¤æ¶ˆæ¯æ ¼å¼...")
            messages = MessageValidator.fix_chat_history(messages)

        # åˆ›å»º LLM
        llm = ChatOpenAI(model="gpt-3.5-turbo")

        # åˆ›å»º agent
        agent = create_react_agent(llm, tools=[])

        return agent

    except Exception as e:
        print(f"âŒ åˆ›å»º React Agent å¤±è´¥: {e}")
        return None
```

## ğŸ›¡ï¸ é˜²å¾¡æ€§ç¼–ç¨‹

### 1. è¾“å…¥éªŒè¯

```python
from typing import TypedDict, Any, Optional
import json

class ValidationState(TypedDict):
    input_data: Any
    validated_data: Optional[dict]
    errors: list

def input_validator(state: ValidationState) -> ValidationState:
    """è¾“å…¥éªŒè¯èŠ‚ç‚¹"""
    errors = []
    validated_data = None

    try:
        input_data = state["input_data"]

        # éªŒè¯è¾“å…¥ä¸ä¸ºç©º
        if input_data is None:
            errors.append("è¾“å…¥æ•°æ®ä¸èƒ½ä¸ºç©º")

        # éªŒè¯æ•°æ®ç±»å‹
        elif not isinstance(input_data, (dict, str)):
            errors.append(f"è¾“å…¥æ•°æ®ç±»å‹é”™è¯¯: {type(input_data)}")

        # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æä¸º JSON
        elif isinstance(input_data, str):
            try:
                validated_data = json.loads(input_data)
            except json.JSONDecodeError as e:
                errors.append(f"JSON è§£æé”™è¯¯: {e}")

        # å¦‚æœæ˜¯å­—å…¸ï¼Œç›´æ¥ä½¿ç”¨
        else:
            validated_data = input_data

        # éªŒè¯å¿…éœ€å­—æ®µ
        if validated_data:
            required_fields = ["id", "content"]
            for field in required_fields:
                if field not in validated_data:
                    errors.append(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")

    except Exception as e:
        errors.append(f"éªŒè¯è¿‡ç¨‹å‡ºé”™: {e}")

    return {
        "input_data": state["input_data"],
        "validated_data": validated_data,
        "errors": errors
    }

def processing_node(state: ValidationState) -> ValidationState:
    """å¤„ç†èŠ‚ç‚¹ - åªå¤„ç†éªŒè¯é€šè¿‡çš„æ•°æ®"""
    if state["errors"]:
        print(f"âš ï¸  è·³è¿‡å¤„ç†ï¼Œå­˜åœ¨éªŒè¯é”™è¯¯: {state['errors']}")
        return state

    if not state["validated_data"]:
        print("âš ï¸  æ²¡æœ‰æœ‰æ•ˆæ•°æ®å¯å¤„ç†")
        return state

    # å®‰å…¨å¤„ç†æ•°æ®
    try:
        processed_content = f"å·²å¤„ç†: {state['validated_data']['content']}"

        return {
            "input_data": state["input_data"],
            "validated_data": {
                **state["validated_data"],
                "content": processed_content,
                "processed": True
            },
            "errors": state["errors"]
        }

    except Exception as e:
        return {
            "input_data": state["input_data"],
            "validated_data": state["validated_data"],
            "errors": state["errors"] + [f"å¤„ç†é”™è¯¯: {e}"]
        }
```

### 2. è¶…æ—¶å’Œé‡è¯•æœºåˆ¶

```python
import time
import random
from functools import wraps

def retry_with_backoff(max_retries: int = 3, backoff_factor: float = 1.0):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e

                    if attempt == max_retries:
                        print(f"âŒ æœ€ç»ˆå¤±è´¥ (å°è¯• {attempt + 1} æ¬¡): {e}")
                        raise e

                    # è®¡ç®—é€€é¿æ—¶é—´
                    backoff_time = backoff_factor * (2 ** attempt) + random.uniform(0, 1)
                    print(f"ğŸ”„ é‡è¯• {attempt + 1}/{max_retries}ï¼Œç­‰å¾… {backoff_time:.2f}s: {e}")
                    time.sleep(backoff_time)

            raise last_exception

        return wrapper
    return decorator

def timeout_handler(timeout_seconds: int = 30):
    """è¶…æ—¶å¤„ç†è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            import signal

            def timeout_signal_handler(signum, frame):
                raise TimeoutError(f"å‡½æ•° {func.__name__} æ‰§è¡Œè¶…æ—¶ ({timeout_seconds}s)")

            # è®¾ç½®è¶…æ—¶ä¿¡å·
            old_handler = signal.signal(signal.SIGALRM, timeout_signal_handler)
            signal.alarm(timeout_seconds)

            try:
                result = func(*args, **kwargs)
                signal.alarm(0)  # å–æ¶ˆè¶…æ—¶
                return result
            except TimeoutError:
                print(f"â° å‡½æ•° {func.__name__} æ‰§è¡Œè¶…æ—¶")
                raise
            finally:
                signal.signal(signal.SIGALRM, old_handler)

        return wrapper
    return decorator

# ä½¿ç”¨é‡è¯•å’Œè¶…æ—¶
@retry_with_backoff(max_retries=3, backoff_factor=0.5)
@timeout_handler(timeout_seconds=10)
def unreliable_api_call(data: dict) -> dict:
    """æ¨¡æ‹Ÿä¸å¯é çš„ API è°ƒç”¨"""
    # æ¨¡æ‹Ÿéšæœºå¤±è´¥
    if random.random() < 0.7:  # 70% å¤±è´¥ç‡
        raise ConnectionError("API è¿æ¥å¤±è´¥")

    # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    time.sleep(2)

    return {"result": f"å¤„ç†æˆåŠŸ: {data}"}

def robust_api_node(state: dict) -> dict:
    """å…·æœ‰é‡è¯•å’Œè¶…æ—¶çš„ API èŠ‚ç‚¹"""
    try:
        result = unreliable_api_call(state.get("api_data", {}))

        return {
            **state,
            "api_result": result,
            "api_status": "success"
        }

    except TimeoutError:
        return {
            **state,
            "api_result": None,
            "api_status": "timeout"
        }

    except Exception as e:
        return {
            **state,
            "api_result": None,
            "api_status": f"error: {e}"
        }
```

### 3. èµ„æºç®¡ç†å’Œæ¸…ç†

```python
import tempfile
import os
from contextlib import contextmanager

class ResourceManager:
    """èµ„æºç®¡ç†å™¨"""

    def __init__(self):
        self.resources = []

    @contextmanager
    def managed_resource(self, resource_factory, cleanup_func=None):
        """ç®¡ç†èµ„æºçš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        resource = None
        try:
            resource = resource_factory()
            self.resources.append((resource, cleanup_func))
            yield resource
        finally:
            if resource and cleanup_func:
                try:
                    cleanup_func(resource)
                except Exception as e:
                    print(f"âš ï¸  æ¸…ç†èµ„æºæ—¶å‡ºé”™: {e}")

    def cleanup_all(self):
        """æ¸…ç†æ‰€æœ‰èµ„æº"""
        for resource, cleanup_func in self.resources:
            if cleanup_func:
                try:
                    cleanup_func(resource)
                except Exception as e:
                    print(f"âš ï¸  æ¸…ç†èµ„æºæ—¶å‡ºé”™: {e}")
        self.resources.clear()

# å…¨å±€èµ„æºç®¡ç†å™¨
resource_manager = ResourceManager()

def file_processing_node(state: dict) -> dict:
    """æ–‡ä»¶å¤„ç†èŠ‚ç‚¹ - å¸¦èµ„æºç®¡ç†"""

    def create_temp_file():
        """åˆ›å»ºä¸´æ—¶æ–‡ä»¶"""
        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False)
        temp_file.write(str(state.get("data", "")))
        temp_file.close()
        return temp_file.name

    def cleanup_temp_file(file_path):
        """æ¸…ç†ä¸´æ—¶æ–‡ä»¶"""
        if os.path.exists(file_path):
            os.unlink(file_path)

    try:
        with resource_manager.managed_resource(
            create_temp_file,
            cleanup_temp_file
        ) as temp_file_path:

            # å¤„ç†æ–‡ä»¶
            with open(temp_file_path, 'r') as f:
                content = f.read()

            processed_content = f"æ–‡ä»¶å¤„ç†ç»“æœ: {content}"

            return {
                **state,
                "processed_content": processed_content,
                "temp_file_used": temp_file_path
            }

    except Exception as e:
        return {
            **state,
            "error": f"æ–‡ä»¶å¤„ç†å¤±è´¥: {e}"
        }
```

## ğŸ”§ é”™è¯¯æ¢å¤ç­–ç•¥

### 1. æ–­è·¯å™¨æ¨¡å¼

```python
import time
from enum import Enum

class CircuitBreakerState(Enum):
    CLOSED = "closed"      # æ­£å¸¸çŠ¶æ€
    OPEN = "open"         # æ–­è·¯çŠ¶æ€
    HALF_OPEN = "half_open"  # åŠå¼€çŠ¶æ€

class CircuitBreaker:
    """æ–­è·¯å™¨å®ç°"""

    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitBreakerState.CLOSED

    def call(self, func, *args, **kwargs):
        """é€šè¿‡æ–­è·¯å™¨è°ƒç”¨å‡½æ•°"""
        if self.state == CircuitBreakerState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitBreakerState.HALF_OPEN
                print("ğŸ”„ æ–­è·¯å™¨è¿›å…¥åŠå¼€çŠ¶æ€")
            else:
                raise Exception("ğŸ’¥ æ–­è·¯å™¨å¼€å¯ï¼Œæ‹’ç»è°ƒç”¨")

        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e

    def _on_success(self):
        """æˆåŠŸæ—¶çš„å¤„ç†"""
        self.failure_count = 0
        if self.state == CircuitBreakerState.HALF_OPEN:
            self.state = CircuitBreakerState.CLOSED
            print("âœ… æ–­è·¯å™¨æ¢å¤åˆ°å…³é—­çŠ¶æ€")

    def _on_failure(self):
        """å¤±è´¥æ—¶çš„å¤„ç†"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = CircuitBreakerState.OPEN
            print(f"âš¡ æ–­è·¯å™¨å¼€å¯ (å¤±è´¥ {self.failure_count} æ¬¡)")

# ä½¿ç”¨æ–­è·¯å™¨
api_circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30)

def circuit_breaker_node(state: dict) -> dict:
    """ä½¿ç”¨æ–­è·¯å™¨çš„èŠ‚ç‚¹"""
    try:
        # é€šè¿‡æ–­è·¯å™¨è°ƒç”¨ä¸å¯é çš„æœåŠ¡
        result = api_circuit_breaker.call(unreliable_api_call, state.get("data", {}))

        return {
            **state,
            "api_result": result,
            "circuit_breaker_state": api_circuit_breaker.state.value
        }

    except Exception as e:
        return {
            **state,
            "api_result": None,
            "error": str(e),
            "circuit_breaker_state": api_circuit_breaker.state.value
        }
```

## ğŸ“ é”™è¯¯æ—¥å¿—å’Œç›‘æ§

### 1. ç»“æ„åŒ–æ—¥å¿—

```python
import logging
import json
from datetime import datetime

class StructuredLogger:
    """ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨"""

    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)

        # åˆ›å»ºå¤„ç†å™¨
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def log_node_execution(self, node_name: str, state: dict, status: str, error: str = None):
        """è®°å½•èŠ‚ç‚¹æ‰§è¡Œæ—¥å¿—"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "node_name": node_name,
            "status": status,
            "state_keys": list(state.keys()) if state else [],
            "state_size": len(str(state)) if state else 0
        }

        if error:
            log_entry["error"] = error
            self.logger.error(json.dumps(log_entry, ensure_ascii=False))
        else:
            self.logger.info(json.dumps(log_entry, ensure_ascii=False))

    def log_graph_execution(self, graph_name: str, input_state: dict, output_state: dict,
                          execution_time: float, success: bool):
        """è®°å½•å›¾æ‰§è¡Œæ—¥å¿—"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "graph_name": graph_name,
            "success": success,
            "execution_time": execution_time,
            "input_keys": list(input_state.keys()) if input_state else [],
            "output_keys": list(output_state.keys()) if output_state else []
        }

        if success:
            self.logger.info(f"GRAPH_SUCCESS: {json.dumps(log_entry, ensure_ascii=False)}")
        else:
            self.logger.error(f"GRAPH_FAILURE: {json.dumps(log_entry, ensure_ascii=False)}")

# å…¨å±€æ—¥å¿—å™¨
app_logger = StructuredLogger("langgraph_app")

def logged_node(node_name: str):
    """èŠ‚ç‚¹æ—¥å¿—è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(state):
            try:
                app_logger.log_node_execution(node_name, state, "started")
                result = func(state)
                app_logger.log_node_execution(node_name, result, "completed")
                return result
            except Exception as e:
                app_logger.log_node_execution(node_name, state, "failed", str(e))
                raise
        return wrapper
    return decorator

# ä½¿ç”¨æ—¥å¿—è£…é¥°å™¨
@logged_node("example_node")
def example_node(state: dict) -> dict:
    """ç¤ºä¾‹èŠ‚ç‚¹"""
    return {
        **state,
        "processed": True
    }
```

## ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

### 1. é”™è¯¯å¤„ç†æ£€æŸ¥æ¸…å•

```python
def error_handling_checklist():
    """é”™è¯¯å¤„ç†æ£€æŸ¥æ¸…å•"""
    checklist = [
        "âœ… æ‰€æœ‰èŠ‚ç‚¹éƒ½è¿”å›å­—å…¸ç±»å‹",
        "âœ… å¾ªç¯æ¡ä»¶æœ‰æ˜ç¡®çš„ç»ˆæ­¢é€»è¾‘",
        "âœ… å¹¶å‘èŠ‚ç‚¹é¿å…æ›´æ–°ç›¸åŒå­—æ®µæˆ–ä½¿ç”¨ reducer",
        "âœ… è¾“å…¥æ•°æ®è¿›è¡Œäº†éªŒè¯",
        "âœ… å¤–éƒ¨è°ƒç”¨æœ‰è¶…æ—¶å’Œé‡è¯•æœºåˆ¶",
        "âœ… èµ„æºä½¿ç”¨åè¿›è¡Œäº†æ¸…ç†",
        "âœ… é”™è¯¯ä¿¡æ¯è¢«æ­£ç¡®è®°å½•",
        "âœ… æœ‰é™çº§å’Œæ¢å¤ç­–ç•¥",
        "âœ… å…³é”®è·¯å¾„æœ‰ç›‘æ§å’Œå‘Šè­¦"
    ]

    print("ğŸ” é”™è¯¯å¤„ç†æ£€æŸ¥æ¸…å•:")
    for item in checklist:
        print(f"  {item}")

error_handling_checklist()
```

### 2. é”™è¯¯å¤„ç†æ¨¡æ¿

```python
def create_robust_node(node_name: str, process_func, validator_func=None):
    """åˆ›å»ºå¥å£®èŠ‚ç‚¹çš„æ¨¡æ¿"""

    @logged_node(node_name)
    @retry_with_backoff(max_retries=2)
    def robust_node(state: dict) -> dict:
        try:
            # 1. è¾“å…¥éªŒè¯
            if validator_func:
                validation_result = validator_func(state)
                if not validation_result["is_valid"]:
                    return {
                        **state,
                        "error": f"è¾“å…¥éªŒè¯å¤±è´¥: {validation_result['errors']}"
                    }

            # 2. æ‰§è¡Œå¤„ç†
            result = process_func(state)

            # 3. è¾“å‡ºéªŒè¯
            if not isinstance(result, dict):
                raise ValueError(f"èŠ‚ç‚¹å¿…é¡»è¿”å›å­—å…¸ï¼Œä½†è¿”å›äº† {type(result)}")

            return result

        except Exception as e:
            # 4. é”™è¯¯å¤„ç†
            error_msg = f"{node_name} æ‰§è¡Œå¤±è´¥: {e}"
            app_logger.log_node_execution(node_name, state, "failed", error_msg)

            # è¿”å›å®‰å…¨çš„çŠ¶æ€
            return {
                **state,
                "error": error_msg,
                f"{node_name}_failed": True
            }

    return robust_node
```

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [LangGraph é”™è¯¯å‚è€ƒ](https://langchain-ai.github.io/langgraph/troubleshooting/errors/)
- [Python å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ](https://realpython.com/python-exceptions-handling/)
- [æ–­è·¯å™¨æ¨¡å¼è¯¦è§£](https://martinfowler.com/bliki/CircuitBreaker.html)

---

ğŸ’¡ **å°è´´å£«**ï¼šé¢„é˜²èƒœäºæ²»ç–—ã€‚åœ¨è®¾è®¡é˜¶æ®µå°±è€ƒè™‘å¯èƒ½çš„å¤±è´¥æƒ…å†µï¼Œæ¯”äº‹åä¿®å¤è¦æœ‰æ•ˆå¾—å¤šï¼
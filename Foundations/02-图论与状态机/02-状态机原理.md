# 状态机原理

> 🎯 **学习目标**：理解有限状态机（FSM）的工作原理，掌握 LangGraph 的状态管理核心思想

## 🤖 什么是状态机？

状态机是一个数学模型，用来描述系统在不同状态之间的转换。想象一下：

### 生活中的状态机 - 电灯开关

```
关闭状态 ——[按下开关]——→ 开启状态
    ↑                        ↓
    ←——————[按下开关]—————————
```

这个简单的电灯就是一个状态机：
- **状态**：关闭、开启
- **事件**：按下开关
- **转换**：状态之间的切换

## 🏗️ 状态机的组成要素

### 1. 状态（State）

```python
# 聊天机器人的状态
class ChatbotStates:
    WAITING_INPUT = "waiting_input"      # 等待用户输入
    PROCESSING = "processing"            # 处理中
    GENERATING_RESPONSE = "generating"   # 生成响应
    COMPLETED = "completed"              # 完成
    ERROR = "error"                      # 错误状态
```

### 2. 事件（Event）/触发器

```python
# 状态转换的触发事件
class ChatbotEvents:
    USER_INPUT_RECEIVED = "user_input"
    PROCESSING_COMPLETE = "processed"
    RESPONSE_GENERATED = "response_ready"
    ERROR_OCCURRED = "error"
    RESET = "reset"
```

### 3. 转换（Transition）

```python
# 状态转换规则
state_transitions = {
    (ChatbotStates.WAITING_INPUT, ChatbotEvents.USER_INPUT_RECEIVED): ChatbotStates.PROCESSING,
    (ChatbotStates.PROCESSING, ChatbotEvents.PROCESSING_COMPLETE): ChatbotStates.GENERATING_RESPONSE,
    (ChatbotStates.GENERATING_RESPONSE, ChatbotEvents.RESPONSE_GENERATED): ChatbotStates.COMPLETED,
    (ChatbotStates.COMPLETED, ChatbotEvents.RESET): ChatbotStates.WAITING_INPUT,
    # 错误处理
    (ChatbotStates.PROCESSING, ChatbotEvents.ERROR_OCCURRED): ChatbotStates.ERROR,
    (ChatbotStates.ERROR, ChatbotEvents.RESET): ChatbotStates.WAITING_INPUT,
}
```

## 🎯 LangGraph 中的状态机

### 传统状态机 vs LangGraph 状态机

**传统状态机：**
```python
class TraditionalStateMachine:
    def __init__(self):
        self.current_state = "START"
        self.data = {}  # 简单的数据存储

    def transition(self, event):
        # 简单的状态切换
        if self.current_state == "START" and event == "begin":
            self.current_state = "PROCESSING"
```

**LangGraph 状态机：**
```python
from typing import TypedDict
from langgraph.graph import StateGraph

class AgentState(TypedDict):
    # 丰富的状态信息
    user_input: str
    conversation_history: list[str]
    current_step: str
    tool_results: dict
    confidence_score: float

def input_handler(state: AgentState) -> AgentState:
    """处理输入的节点 - 不只是状态切换，还有数据处理"""
    return {
        **state,
        "current_step": "processing",
        "conversation_history": state["conversation_history"] + [state["user_input"]]
    }
```

### LangGraph 状态管理的特点

1. **富状态（Rich State）**：不只是简单的状态标识，包含完整的上下文信息
2. **状态 + 数据**：每个状态都携带丰富的数据
3. **不可变更新**：每次状态转换都产生新的状态对象

## 🔄 状态转换模式

### 1. 顺序转换

```python
class SequentialState(TypedDict):
    step: int
    message: str
    data: list[str]

def step1(state: SequentialState) -> SequentialState:
    return {
        **state,
        "step": 1,
        "message": "完成步骤1",
        "data": state["data"] + ["步骤1完成"]
    }

def step2(state: SequentialState) -> SequentialState:
    return {
        **state,
        "step": 2,
        "message": "完成步骤2",
        "data": state["data"] + ["步骤2完成"]
    }

# 图构建
graph = StateGraph(SequentialState)
graph.add_node("step1", step1)
graph.add_node("step2", step2)
graph.add_edge("step1", "step2")  # 顺序转换
```

### 2. 条件转换

```python
class ConditionalState(TypedDict):
    user_type: str
    age: int
    access_granted: bool

def age_checker(state: ConditionalState) -> ConditionalState:
    """检查年龄"""
    return {
        **state,
        "access_granted": state["age"] >= 18
    }

def route_by_access(state: ConditionalState) -> str:
    """根据访问权限路由"""
    if state["access_granted"]:
        return "adult_content"
    else:
        return "restricted_content"

def adult_content(state: ConditionalState) -> ConditionalState:
    return {**state, "user_type": "成年用户"}

def restricted_content(state: ConditionalState) -> ConditionalState:
    return {**state, "user_type": "未成年用户"}

# 图构建
graph = StateGraph(ConditionalState)
graph.add_node("check_age", age_checker)
graph.add_node("adult_content", adult_content)
graph.add_node("restricted_content", restricted_content)

graph.add_conditional_edges(
    "check_age",
    route_by_access,
    {
        "adult_content": "adult_content",
        "restricted_content": "restricted_content"
    }
)
```

### 3. 循环转换

```python
class LoopState(TypedDict):
    attempts: int
    max_attempts: int
    success: bool
    result: str

def try_operation(state: LoopState) -> LoopState:
    """尝试执行操作"""
    import random

    success = random.random() > 0.5  # 50% 成功率
    attempts = state["attempts"] + 1

    return {
        **state,
        "attempts": attempts,
        "success": success,
        "result": "成功" if success else f"失败 (尝试 {attempts})"
    }

def should_continue(state: LoopState) -> str:
    """决定是否继续循环"""
    if state["success"]:
        return "end"
    elif state["attempts"] >= state["max_attempts"]:
        return "end"
    else:
        return "try_again"

# 图构建（支持循环）
graph = StateGraph(LoopState)
graph.add_node("try_operation", try_operation)

graph.set_entry_point("try_operation")
graph.add_conditional_edges(
    "try_operation",
    should_continue,
    {
        "try_again": "try_operation",  # 循环回自己
        "end": END
    }
)
```

## 🎪 复杂状态机示例：智能客服

让我们设计一个智能客服的状态机：

```python
from typing import TypedDict, Literal

class CustomerServiceState(TypedDict):
    # 用户信息
    user_message: str
    user_id: str
    session_id: str

    # 对话状态
    current_stage: Literal["greeting", "intent_analysis", "handling", "escalation", "closing"]
    intent: str
    confidence: float

    # 处理信息
    conversation_history: list[str]
    solution_attempts: int
    escalated: bool
    satisfaction_score: int

def greeting_handler(state: CustomerServiceState) -> CustomerServiceState:
    """处理问候阶段"""
    greeting_msg = f"您好！我是智能客服，很高兴为您服务。"

    return {
        **state,
        "current_stage": "intent_analysis",
        "conversation_history": state["conversation_history"] + [
            f"用户: {state['user_message']}",
            f"客服: {greeting_msg}"
        ]
    }

def intent_analyzer(state: CustomerServiceState) -> CustomerServiceState:
    """分析用户意图"""
    message = state["user_message"].lower()

    # 简单的意图识别
    if any(word in message for word in ["退款", "退货", "返回"]):
        intent = "refund"
        confidence = 0.8
    elif any(word in message for word in ["订单", "状态", "查询"]):
        intent = "order_inquiry"
        confidence = 0.9
    elif any(word in message for word in ["技术", "问题", "故障"]):
        intent = "technical_support"
        confidence = 0.7
    else:
        intent = "general_inquiry"
        confidence = 0.5

    return {
        **state,
        "current_stage": "handling",
        "intent": intent,
        "confidence": confidence
    }

def issue_handler(state: CustomerServiceState) -> CustomerServiceState:
    """处理具体问题"""
    intent = state["intent"]
    solution_attempts = state["solution_attempts"] + 1

    if intent == "refund":
        response = "我来帮您处理退款申请..."
    elif intent == "order_inquiry":
        response = "让我查询您的订单状态..."
    elif intent == "technical_support":
        response = "我来帮您解决技术问题..."
    else:
        response = "我需要了解更多信息来帮助您..."

    return {
        **state,
        "current_stage": "closing",
        "solution_attempts": solution_attempts,
        "conversation_history": state["conversation_history"] + [f"客服: {response}"]
    }

def escalation_checker(state: CustomerServiceState) -> str:
    """检查是否需要人工客服"""
    if state["confidence"] < 0.6:
        return "escalate"
    elif state["solution_attempts"] >= 3:
        return "escalate"
    else:
        return "handle"

def human_escalation(state: CustomerServiceState) -> CustomerServiceState:
    """转人工客服"""
    return {
        **state,
        "current_stage": "escalation",
        "escalated": True,
        "conversation_history": state["conversation_history"] + [
            "客服: 我将为您转接人工客服，请稍等..."
        ]
    }

# 构建客服状态机
graph = StateGraph(CustomerServiceState)

# 添加节点
graph.add_node("greeting", greeting_handler)
graph.add_node("analyze_intent", intent_analyzer)
graph.add_node("handle_issue", issue_handler)
graph.add_node("escalate", human_escalation)

# 设置流程
graph.set_entry_point("greeting")
graph.add_edge("greeting", "analyze_intent")

graph.add_conditional_edges(
    "analyze_intent",
    escalation_checker,
    {
        "handle": "handle_issue",
        "escalate": "escalate"
    }
)

graph.add_edge("handle_issue", END)
graph.add_edge("escalate", END)

# 编译和使用
customer_service = graph.compile()

# 测试
initial_state = {
    "user_message": "我要退款",
    "user_id": "user123",
    "session_id": "session456",
    "current_stage": "greeting",
    "intent": "",
    "confidence": 0.0,
    "conversation_history": [],
    "solution_attempts": 0,
    "escalated": False,
    "satisfaction_score": 0
}

result = customer_service.invoke(initial_state)
print(f"最终状态: {result['current_stage']}")
print(f"对话历史: {result['conversation_history']}")
```

## 🔍 状态机调试技巧

### 1. 状态追踪

```python
def trace_state_changes(old_state: dict, new_state: dict, node_name: str):
    """追踪状态变化"""
    print(f"\n🔄 节点 '{node_name}' 执行完成:")

    for key in set(old_state.keys()) | set(new_state.keys()):
        old_val = old_state.get(key, "<MISSING>")
        new_val = new_state.get(key, "<MISSING>")

        if old_val != new_val:
            print(f"  📝 {key}: {old_val} → {new_val}")

# 在节点中使用
def traced_node(state: AgentState) -> AgentState:
    old_state = state.copy()
    # ... 处理逻辑 ...
    new_state = {...}
    trace_state_changes(old_state, new_state, "traced_node")
    return new_state
```

### 2. 状态验证

```python
def validate_state_transition(state: dict, expected_fields: list[str]) -> bool:
    """验证状态转换是否有效"""
    for field in expected_fields:
        if field not in state:
            print(f"❌ 缺少必需字段: {field}")
            return False

    return True

def safe_node(state: AgentState) -> AgentState:
    """带验证的安全节点"""
    # 验证输入状态
    if not validate_state_transition(state, ["user_input", "conversation_history"]):
        raise ValueError("输入状态无效")

    # 处理逻辑
    new_state = {...}

    # 验证输出状态
    if not validate_state_transition(new_state, ["current_step", "conversation_history"]):
        raise ValueError("输出状态无效")

    return new_state
```

## ✅ 实践练习

### 练习 1：设计游戏状态机

设计一个简单游戏的状态机，包含以下状态：
- 菜单
- 游戏中
- 暂停
- 游戏结束

### 练习 2：电商订单状态机

设计一个电商订单的状态机：
- 待支付 → 已支付 → 发货中 → 已送达
- 支持取消和退款流程

## 💡 关键要点

1. **状态机 = 状态 + 转换规则**：清晰定义系统的所有可能状态
2. **LangGraph 的富状态**：不只是状态标识，还包含完整数据
3. **不可变更新**：每次转换产生新状态，保证数据一致性
4. **条件转换**：根据状态内容动态决定下一步
5. **调试友好**：状态追踪和验证帮助排查问题

## 🚀 下一步

掌握状态机原理后，接下来学习：
- `03-工作流模式.md` - 常见的工作流设计模式
- `../03-LangGraph基础/01-为什么需要LangGraph.md` - 开始 LangGraph 实战

---

*现在你已经理解了状态机的核心思想，这是掌握 LangGraph 工作原理的关键！* 🎉
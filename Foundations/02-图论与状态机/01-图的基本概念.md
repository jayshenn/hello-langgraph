# 图的基本概念

> 🎯 **学习目标**：理解图的基本概念，为掌握 LangGraph 的工作原理打下数学基础

## 🤔 为什么要学习图论？

LangGraph 的名字就说明了一切 - 它是基于**图**的结构来组织 AI Agent 的工作流。理解图的概念，就能更好地设计和调试你的 Agent 系统。

## 🔵 图是什么？

### 生活中的图

在学习抽象概念之前，让我们从生活中的例子开始：

```
地铁线路图:
    北京站 ——— 建国门 ——— 朝阳门
       |         |         |
    天安门东 ——— 王府井 ——— 东四
```

这就是一个图！其中：
- **节点**（Node）：各个地铁站
- **边**（Edge）：连接站点的地铁线路

### 程序中的图

```python
# 用字典表示地铁图
subway_graph = {
    "北京站": ["建国门", "天安门东"],
    "建国门": ["北京站", "朝阳门", "王府井"],
    "朝阳门": ["建国门", "东四"],
    "天安门东": ["北京站", "王府井"],
    "王府井": ["建国门", "天安门东", "东四"],
    "东四": ["朝阳门", "王府井"]
}
```

## 🎯 图的基本元素

### 1. 节点（Node/Vertex）

```python
# 在 LangGraph 中，节点通常是函数
def greeting_node(state):
    """问候节点 - 处理用户的问候"""
    return {"message": "你好！我是 AI 助手"}

def search_node(state):
    """搜索节点 - 执行网络搜索"""
    query = state["message"]
    return {"search_results": f"搜索'{query}'的结果..."}
```

### 2. 边（Edge）

边定义了从一个节点到另一个节点的连接：

```python
# 简单的连接：问候 → 搜索
graph.add_edge("greeting_node", "search_node")

# 条件连接：根据状态决定下一步
def should_search(state):
    """决定是否需要搜索"""
    if "搜索" in state["message"]:
        return "search_node"
    else:
        return "chat_node"

graph.add_conditional_edges("greeting_node", should_search)
```

## 🔄 图的类型

### 1. 无向图 vs 有向图

```
无向图（朋友关系）:
Alice ——— Bob
  |        |
Carol ——— David

有向图（关注关系）:
Alice ——→ Bob
  ↑        ↓
Carol ←—— David
```

**LangGraph 使用有向图**，因为 Agent 的工作流有明确的方向。

### 2. 循环图 vs 无环图

```
无环图（瀑布流程）:
开始 → 处理 → 结束

循环图（迭代流程）:
开始 → 处理 → 检查
  ↑              ↓
结束 ←—————————— 继续？
```

**LangGraph 支持循环**，这让 Agent 可以进行迭代思考。

## 🚀 LangGraph 中的图示例

### 简单线性图

```python
from langgraph.graph import StateGraph
from typing import TypedDict

class SimpleState(TypedDict):
    message: str
    step: int

# 三个连续的节点
def step1(state: SimpleState) -> SimpleState:
    return {
        "message": f"步骤1: {state['message']}",
        "step": 1
    }

def step2(state: SimpleState) -> SimpleState:
    return {
        "message": f"步骤2: {state['message']}",
        "step": 2
    }

def step3(state: SimpleState) -> SimpleState:
    return {
        "message": f"步骤3: {state['message']}",
        "step": 3
    }

# 构建图
graph = StateGraph(SimpleState)
graph.add_node("step1", step1)
graph.add_node("step2", step2)
graph.add_node("step3", step3)

# 连接节点（线性）
graph.set_entry_point("step1")
graph.add_edge("step1", "step2")
graph.add_edge("step2", "step3")
graph.set_finish_point("step3")

app = graph.compile()
```

### 分支图

```python
class BranchState(TypedDict):
    user_input: str
    intent: str
    response: str

def analyze_intent(state: BranchState) -> BranchState:
    """分析用户意图"""
    user_input = state["user_input"].lower()

    if "天气" in user_input:
        intent = "weather"
    elif "时间" in user_input:
        intent = "time"
    else:
        intent = "chat"

    return {**state, "intent": intent}

def weather_node(state: BranchState) -> BranchState:
    """处理天气查询"""
    return {**state, "response": "今天天气晴朗"}

def time_node(state: BranchState) -> BranchState:
    """处理时间查询"""
    return {**state, "response": "现在是下午2点"}

def chat_node(state: BranchState) -> BranchState:
    """一般聊天"""
    return {**state, "response": "我们聊聊吧！"}

# 条件路由函数
def route_by_intent(state: BranchState) -> str:
    """根据意图路由到不同节点"""
    intent_mapping = {
        "weather": "weather_node",
        "time": "time_node",
        "chat": "chat_node"
    }
    return intent_mapping.get(state["intent"], "chat_node")

# 构建分支图
graph = StateGraph(BranchState)
graph.add_node("analyze", analyze_intent)
graph.add_node("weather_node", weather_node)
graph.add_node("time_node", time_node)
graph.add_node("chat_node", chat_node)

graph.set_entry_point("analyze")
graph.add_conditional_edges(
    "analyze",
    route_by_intent,
    {
        "weather_node": "weather_node",
        "time_node": "time_node",
        "chat_node": "chat_node"
    }
)

# 所有分支都结束
from langgraph.graph import END
graph.add_edge("weather_node", END)
graph.add_edge("time_node", END)
graph.add_edge("chat_node", END)

app = graph.compile()
```

## 🔍 图的遍历

### 深度优先 vs 广度优先

虽然 LangGraph 有自己的执行策略，但理解图遍历有助于调试：

```python
def visualize_graph_execution(graph_state_history):
    """可视化图的执行路径"""
    print("图执行路径:")
    for i, (node_name, state) in enumerate(graph_state_history):
        print(f"  {i+1}. {node_name}: {state}")

# 示例输出:
# 图执行路径:
#   1. analyze: {"user_input": "今天天气怎么样", "intent": "weather"}
#   2. weather_node: {"user_input": "今天天气怎么样", "intent": "weather", "response": "今天天气晴朗"}
```

## 🎪 实践练习

### 练习 1：设计简单图

设计一个咖啡订购流程的图：

```
开始 → 选择咖啡 → 选择大小 → 确认订单 → 结束
```

<details>
<summary>🔍 查看答案</summary>

```python
from typing import TypedDict

class CoffeeOrderState(TypedDict):
    coffee_type: str
    size: str
    confirmed: bool
    total_price: float

def select_coffee(state: CoffeeOrderState) -> CoffeeOrderState:
    return {**state, "coffee_type": "拿铁"}

def select_size(state: CoffeeOrderState) -> CoffeeOrderState:
    return {**state, "size": "中杯"}

def confirm_order(state: CoffeeOrderState) -> CoffeeOrderState:
    price = 25.0 if state["size"] == "中杯" else 30.0
    return {**state, "confirmed": True, "total_price": price}

# 构建图
graph = StateGraph(CoffeeOrderState)
graph.add_node("select_coffee", select_coffee)
graph.add_node("select_size", select_size)
graph.add_node("confirm", confirm_order)

graph.set_entry_point("select_coffee")
graph.add_edge("select_coffee", "select_size")
graph.add_edge("select_size", "confirm")
graph.set_finish_point("confirm")
```
</details>

### 练习 2：带条件的图

设计一个ATM取款流程，包含余额检查：

```
验证密码 → 检查余额 → [足够] → 取款 → 结束
                   → [不足] → 提示 → 结束
```

## 🔧 图的可视化

理解图结构的最好方法是可视化：

```python
# LangGraph 内置可视化（需要安装额外依赖）
try:
    from IPython.display import Image, display
    display(Image(app.get_graph().draw_mermaid_png()))
except ImportError:
    print("安装 jupyter 和 langsmith 以使用可视化功能")

# 简单的文本可视化
def print_graph_structure(graph):
    """打印图的结构"""
    print("图结构:")
    for node_name in graph.nodes:
        print(f"  节点: {node_name}")

    print("  连接:")
    for source, target in graph.edges:
        print(f"    {source} → {target}")
```

## 💡 关键概念总结

1. **图 = 节点 + 边**：节点是处理逻辑，边是流程控制
2. **有向图**：LangGraph 中的数据流有明确方向
3. **状态传递**：通过边在节点间传递状态
4. **条件路由**：根据状态内容决定下一步
5. **循环支持**：允许迭代和重试逻辑

## 🚀 下一步

理解了图的基本概念后，接下来学习：
- `02-状态机原理.md` - 深入理解状态转换
- `03-工作流模式.md` - 常见的图设计模式

---

*现在你已经掌握了图的基本概念，这是理解 LangGraph 架构的重要基础！* 🎉
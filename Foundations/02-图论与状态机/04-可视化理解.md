# å¯è§†åŒ–ç†è§£

> ğŸ¯ **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡ LangGraph å›¾çš„å¯è§†åŒ–æ–¹æ³•ï¼Œå­¦ä¼šé€šè¿‡å›¾å½¢åŒ–å·¥å…·ç†è§£å’Œè°ƒè¯•å¤æ‚çš„å·¥ä½œæµ

## ğŸ‘ï¸ ä¸ºä»€ä¹ˆéœ€è¦å¯è§†åŒ–ï¼Ÿ

å½“ä½ çš„ LangGraph å˜å¾—å¤æ‚æ—¶ï¼Œä»…ä»…é˜…è¯»ä»£ç å·²ç»å¾ˆéš¾ç†è§£æ•´ä¸ªæµç¨‹ï¼š

```python
# ğŸ˜µ å¤æ‚çš„å›¾ç»“æ„ - å¾ˆéš¾ä»ä»£ç ç†è§£æµç¨‹
graph.add_conditional_edges("analyzer", route_func, {
    "search": "web_search",
    "data": "db_query",
    "api": "api_call"
})
graph.add_conditional_edges("web_search", check_results, {
    "success": "combiner",
    "retry": "analyzer"
})
# ... æ›´å¤šè¿æ¥
```

é€šè¿‡å¯è§†åŒ–ï¼Œå¤æ‚çš„é€»è¾‘å˜å¾—ä¸€ç›®äº†ç„¶ï¼š

```
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚analyzer â”‚
     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
       â”Œâ”€â”€â”€â”¼â”€â”€â”€â”
  â”Œâ”€â”€â”€â”€â–¼â” â”Œâ–¼â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”
  â”‚searchâ”‚ â”‚dataâ”‚ â”‚api  â”‚
  â””â”€â”€â”€â”€â”¬â”˜ â””â”¬â”€â”€â”˜ â””â”¬â”€â”€â”€â”€â”˜
       â””â”€â”€â”€â”¼â”€â”€â”€â”€â”˜
       â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
       â”‚combinerâ”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ› ï¸ LangGraph å†…ç½®å¯è§†åŒ–

### 1. Mermaid å›¾è¡¨ç”Ÿæˆ

LangGraph æä¾›äº†å†…ç½®çš„ Mermaid å›¾è¡¨ç”ŸæˆåŠŸèƒ½ï¼š

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

class SimpleState(TypedDict):
    message: str
    step: str

def step_a(state: SimpleState) -> SimpleState:
    return {"message": state["message"], "step": "A"}

def step_b(state: SimpleState) -> SimpleState:
    return {"message": state["message"], "step": "B"}

def step_c(state: SimpleState) -> SimpleState:
    return {"message": state["message"], "step": "C"}

# æ„å»ºå›¾
graph = StateGraph(SimpleState)
graph.add_node("step_a", step_a)
graph.add_node("step_b", step_b)
graph.add_node("step_c", step_c)

graph.set_entry_point("step_a")
graph.add_edge("step_a", "step_b")
graph.add_edge("step_b", "step_c")
graph.add_edge("step_c", END)

app = graph.compile()

# ç”Ÿæˆ Mermaid å›¾
print("=== Mermaid å›¾å½¢æè¿° ===")
print(app.get_graph().draw_mermaid())
```

è¾“å‡ºçš„ Mermaid ä»£ç ï¼š
```mermaid
%%{init: {'flowchart': {'curve': 'linear'}}}%%
flowchart TD
    __start__([__start__])
    step_a(step_a)
    step_b(step_b)
    step_c(step_c)
    __end__([__end__])
    __start__ --> step_a
    step_a --> step_b
    step_b --> step_c
    step_c --> __end__
```

### 2. PNG å›¾ç‰‡ç”Ÿæˆ

å¦‚æœä½ åœ¨ Jupyter Notebook ç¯å¢ƒä¸­ï¼š

```python
# åœ¨ Jupyter Notebook ä¸­æ˜¾ç¤ºå›¾ç‰‡
try:
    from IPython.display import Image, display

    # ç›´æ¥æ˜¾ç¤ºå›¾ç‰‡
    display(Image(app.get_graph().draw_mermaid_png()))

except ImportError:
    print("éœ€è¦å®‰è£… jupyter å’Œç›¸å…³ä¾èµ–ï¼špip install jupyter")

# ä¿å­˜å›¾ç‰‡åˆ°æ–‡ä»¶
try:
    with open("my_graph.png", "wb") as f:
        f.write(app.get_graph().draw_mermaid_png())
    print("å›¾ç‰‡å·²ä¿å­˜åˆ° my_graph.png")
except Exception as e:
    print(f"ä¿å­˜å›¾ç‰‡å¤±è´¥ï¼š{e}")
```

### 3. ASCII è‰ºæœ¯å¯è§†åŒ–

å¯¹äºç®€å•åœºæ™¯ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»º ASCII å›¾ï¼š

```python
def print_ascii_graph(graph_structure):
    """æ‰“å° ASCII é£æ ¼çš„å›¾ç»“æ„"""
    print("ğŸ“Š å›¾ç»“æ„å¯è§†åŒ–:")
    print("=" * 50)

    for step, (node, connections) in enumerate(graph_structure.items(), 1):
        # æ‰“å°å½“å‰èŠ‚ç‚¹
        print(f"  {step}. [{node}]")

        # æ‰“å°è¿æ¥
        for connection in connections:
            if connection == "END":
                print(f"     â””â”€â”€ ğŸ END")
            else:
                print(f"     â”œâ”€â”€ {connection}")

        if step < len(graph_structure):
            print("     â”‚")

# ä½¿ç”¨ç¤ºä¾‹
simple_structure = {
    "å…¥å£ç‚¹": ["æ•°æ®å¤„ç†"],
    "æ•°æ®å¤„ç†": ["éªŒè¯", "æ¸…ç†"],
    "éªŒè¯": ["æ±‡æ€»"],
    "æ¸…ç†": ["æ±‡æ€»"],
    "æ±‡æ€»": ["END"]
}

print_ascii_graph(simple_structure)
```

## ğŸ¨ å¤æ‚å›¾çš„å¯è§†åŒ–ç¤ºä¾‹

### æ¡ä»¶åˆ†æ”¯å›¾å¯è§†åŒ–

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

class ChatState(TypedDict):
    user_input: str
    intent: str
    response: str

def analyze_intent(state: ChatState) -> ChatState:
    user_input = state["user_input"].lower()

    if "å¤©æ°”" in user_input:
        intent = "weather"
    elif "æ—¶é—´" in user_input:
        intent = "time"
    elif "æ–°é—»" in user_input:
        intent = "news"
    else:
        intent = "chat"

    return {**state, "intent": intent}

def weather_handler(state: ChatState) -> ChatState:
    return {**state, "response": "ä»Šå¤©å¤©æ°”æ™´æœ—ï¼Œ25Â°C"}

def time_handler(state: ChatState) -> ChatState:
    return {**state, "response": "ç°åœ¨æ˜¯ä¸‹åˆ3:30"}

def news_handler(state: ChatState) -> ChatState:
    return {**state, "response": "ä»Šæ—¥è¦é—»ï¼šç§‘æŠ€åˆ›æ–°è¾¾åˆ°æ–°é«˜åº¦"}

def chat_handler(state: ChatState) -> ChatState:
    return {**state, "response": "å¾ˆé«˜å…´å’Œæ‚¨èŠå¤©ï¼"}

def route_by_intent(state: ChatState) -> str:
    intent_mapping = {
        "weather": "weather_handler",
        "time": "time_handler",
        "news": "news_handler",
        "chat": "chat_handler"
    }
    return intent_mapping.get(state["intent"], "chat_handler")

# æ„å»ºåˆ†æ”¯å›¾
chat_graph = StateGraph(ChatState)
chat_graph.add_node("analyze", analyze_intent)
chat_graph.add_node("weather_handler", weather_handler)
chat_graph.add_node("time_handler", time_handler)
chat_graph.add_node("news_handler", news_handler)
chat_graph.add_node("chat_handler", chat_handler)

chat_graph.set_entry_point("analyze")
chat_graph.add_conditional_edges(
    "analyze",
    route_by_intent,
    {
        "weather_handler": "weather_handler",
        "time_handler": "time_handler",
        "news_handler": "news_handler",
        "chat_handler": "chat_handler"
    }
)

# æ‰€æœ‰å¤„ç†å™¨æŒ‡å‘ç»“æŸ
for handler in ["weather_handler", "time_handler", "news_handler", "chat_handler"]:
    chat_graph.add_edge(handler, END)

chat_app = chat_graph.compile()

# å¯è§†åŒ–åˆ†æ”¯å›¾
print("=== èŠå¤©æœºå™¨äººåˆ†æ”¯å›¾ ===")
print(chat_app.get_graph().draw_mermaid())
```

### å¾ªç¯å›¾å¯è§†åŒ–

```python
class RetryState(TypedDict):
    task: str
    attempts: int
    max_attempts: int
    success: bool
    result: str

def try_task(state: RetryState) -> RetryState:
    import random

    attempts = state["attempts"] + 1
    # éšç€å°è¯•æ¬¡æ•°å¢åŠ ï¼ŒæˆåŠŸç‡æé«˜
    success_rate = 0.2 + (attempts * 0.2)
    success = random.random() < success_rate

    if success:
        result = f"âœ… ä»»åŠ¡åœ¨ç¬¬ {attempts} æ¬¡å°è¯•æˆåŠŸ"
    else:
        result = f"âŒ ç¬¬ {attempts} æ¬¡å°è¯•å¤±è´¥"

    return {
        **state,
        "attempts": attempts,
        "success": success,
        "result": result
    }

def should_retry(state: RetryState) -> str:
    if state["success"]:
        return "success"
    elif state["attempts"] >= state["max_attempts"]:
        return "give_up"
    else:
        return "retry"

def handle_success(state: RetryState) -> RetryState:
    return {**state, "result": f"ğŸ‰ {state['result']}"}

def handle_failure(state: RetryState) -> RetryState:
    return {**state, "result": f"ğŸ’” å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°: {state['max_attempts']}"}

# æ„å»ºé‡è¯•å›¾
retry_graph = StateGraph(RetryState)
retry_graph.add_node("try_task", try_task)
retry_graph.add_node("success", handle_success)
retry_graph.add_node("give_up", handle_failure)

retry_graph.set_entry_point("try_task")
retry_graph.add_conditional_edges(
    "try_task",
    should_retry,
    {
        "success": "success",
        "give_up": "give_up",
        "retry": "try_task"  # å¾ªç¯å›è‡ªå·±
    }
)

retry_graph.add_edge("success", END)
retry_graph.add_edge("give_up", END)

retry_app = retry_graph.compile()

print("=== é‡è¯•å¾ªç¯å›¾ ===")
print(retry_app.get_graph().draw_mermaid())
```

## ğŸ” å›¾æ‰§è¡Œæµç¨‹å¯è§†åŒ–

### å®æ—¶çŠ¶æ€è¿½è¸ª

```python
def create_execution_tracer():
    """åˆ›å»ºæ‰§è¡Œè¿½è¸ªå™¨"""
    execution_log = []

    def trace_execution(node_name: str, input_state: dict, output_state: dict):
        """è¿½è¸ªèŠ‚ç‚¹æ‰§è¡Œ"""
        execution_log.append({
            "node": node_name,
            "input": input_state.copy(),
            "output": output_state.copy(),
            "timestamp": __import__('datetime').datetime.now()
        })

    def visualize_execution():
        """å¯è§†åŒ–æ‰§è¡Œæµç¨‹"""
        print("\nğŸ¬ å›¾æ‰§è¡Œæµç¨‹:")
        print("=" * 60)

        for i, log_entry in enumerate(execution_log, 1):
            node = log_entry["node"]
            timestamp = log_entry["timestamp"].strftime("%H:%M:%S.%f")[:-3]

            print(f"  {i}. ğŸ“ [{timestamp}] æ‰§è¡ŒèŠ‚ç‚¹: {node}")

            # æ˜¾ç¤ºçŠ¶æ€å˜åŒ–
            input_state = log_entry["input"]
            output_state = log_entry["output"]

            for key in set(input_state.keys()) | set(output_state.keys()):
                old_val = input_state.get(key, "<æ— >")
                new_val = output_state.get(key, "<æ— >")

                if old_val != new_val:
                    print(f"      ğŸ”„ {key}: {old_val} â†’ {new_val}")

            print()

    return trace_execution, visualize_execution, execution_log

# ä½¿ç”¨è¿½è¸ªå™¨
tracer, visualizer, log = create_execution_tracer()

# å¸¦è¿½è¸ªçš„èŠ‚ç‚¹å‡½æ•°
def traced_node(node_name: str, func):
    """åŒ…è£…èŠ‚ç‚¹å‡½æ•°ä»¥æ”¯æŒè¿½è¸ª"""
    def wrapper(state):
        input_state = state.copy()
        output_state = func(state)
        tracer(node_name, input_state, output_state)
        return output_state
    return wrapper

# ç¤ºä¾‹ï¼šè¿½è¸ªèŠå¤©æœºå™¨äººæ‰§è¡Œ
traced_analyze = traced_node("æ„å›¾åˆ†æ", analyze_intent)
traced_weather = traced_node("å¤©æ°”å¤„ç†", weather_handler)

# æ‰‹åŠ¨æµ‹è¯•æ‰§è¡Œæµç¨‹
test_state = {"user_input": "ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·", "intent": "", "response": ""}

# æ‰§è¡Œæ­¥éª¤1
test_state = traced_analyze(test_state)

# æ‰§è¡Œæ­¥éª¤2ï¼ˆæ ¹æ®æ„å›¾ï¼‰
if test_state["intent"] == "weather":
    test_state = traced_weather(test_state)

# æ˜¾ç¤ºæ‰§è¡Œè¿‡ç¨‹
visualizer()
```

### æµç¨‹å›¾ç”Ÿæˆå™¨

```python
def generate_flow_diagram(execution_log: list) -> str:
    """æ ¹æ®æ‰§è¡Œæ—¥å¿—ç”Ÿæˆæµç¨‹å›¾"""

    if not execution_log:
        return "ç©ºæ‰§è¡Œæ—¥å¿—"

    diagram = ["æµç¨‹æ‰§è¡Œå›¾:", "=" * 40]

    for i, log_entry in enumerate(execution_log):
        node_name = log_entry["node"]

        if i == 0:
            # ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            diagram.append(f"  ğŸš€ å¼€å§‹")
            diagram.append(f"    â†“")
            diagram.append(f"  ğŸ“¦ {node_name}")
        else:
            diagram.append(f"    â†“")
            diagram.append(f"  ğŸ“¦ {node_name}")

    diagram.append(f"    â†“")
    diagram.append(f"  ğŸ ç»“æŸ")

    return "\n".join(diagram)

# ç”Ÿæˆå¹¶æ˜¾ç¤ºæµç¨‹å›¾
if log:
    print(generate_flow_diagram(log))
```

## ğŸ¯ å¯è§†åŒ–æœ€ä½³å®è·µ

### 1. èŠ‚ç‚¹å‘½åè§„èŒƒ

```python
# âŒ ä¸å¥½çš„å‘½å
graph.add_node("n1", func1)
graph.add_node("process", func2)
graph.add_node("h", func3)

# âœ… å¥½çš„å‘½å
graph.add_node("intent_analyzer", analyze_intent)
graph.add_node("weather_handler", handle_weather)
graph.add_node("response_formatter", format_response)
```

### 2. åˆ†å±‚å¯è§†åŒ–

å¯¹äºå¤æ‚å›¾ï¼ŒæŒ‰åŠŸèƒ½åˆ†å±‚å±•ç¤ºï¼š

```python
def print_layered_graph(graph_layers: dict):
    """åˆ†å±‚æ˜¾ç¤ºå›¾ç»“æ„"""
    print("ğŸ—ï¸ åˆ†å±‚å›¾ç»“æ„:")
    print("=" * 50)

    for layer_name, nodes in graph_layers.items():
        print(f"\nğŸ“‹ {layer_name} å±‚:")
        print("-" * 30)

        for node in nodes:
            print(f"  ğŸ“¦ {node}")

        print("  â†“ â†“ â†“")

# ç¤ºä¾‹åˆ†å±‚
layers = {
    "è¾“å…¥å¤„ç†": ["ç”¨æˆ·è¾“å…¥éªŒè¯", "æ„å›¾è¯†åˆ«"],
    "ä¸šåŠ¡é€»è¾‘": ["å¤©æ°”æŸ¥è¯¢", "æ–°é—»è·å–", "èŠå¤©å¤„ç†"],
    "è¾“å‡ºæ ¼å¼åŒ–": ["å“åº”æ ¼å¼åŒ–", "é”™è¯¯å¤„ç†"]
}

print_layered_graph(layers)
```

### 3. çŠ¶æ€æµå¯è§†åŒ–

```python
def visualize_state_flow(state_history: list):
    """å¯è§†åŒ–çŠ¶æ€æµè½¬"""
    print("ğŸŒŠ çŠ¶æ€æµè½¬å¯è§†åŒ–:")
    print("=" * 50)

    for i, state in enumerate(state_history):
        print(f"  æ­¥éª¤ {i+1}:")

        for key, value in state.items():
            # æˆªæ–­é•¿å€¼
            display_value = str(value)
            if len(display_value) > 30:
                display_value = display_value[:27] + "..."

            print(f"    ğŸ“ {key}: {display_value}")

        if i < len(state_history) - 1:
            print("    â¬‡ï¸")

        print()

# ä½¿ç”¨ç¤ºä¾‹
state_flow = [
    {"user_input": "ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·", "intent": "", "response": ""},
    {"user_input": "ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·", "intent": "weather", "response": ""},
    {"user_input": "ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·", "intent": "weather", "response": "ä»Šå¤©å¤©æ°”æ™´æœ—ï¼Œ25Â°C"}
]

visualize_state_flow(state_flow)
```

## ğŸ”§ è°ƒè¯•å¯è§†åŒ–å·¥å…·

### æ–­ç‚¹å¯è§†åŒ–

```python
def create_debug_visualizer():
    """åˆ›å»ºè°ƒè¯•å¯è§†åŒ–å·¥å…·"""
    breakpoints = set()

    def add_breakpoint(node_name: str):
        """æ·»åŠ æ–­ç‚¹"""
        breakpoints.add(node_name)
        print(f"ğŸ”´ åœ¨èŠ‚ç‚¹ '{node_name}' è®¾ç½®æ–­ç‚¹")

    def debug_node(node_name: str, state: dict):
        """è°ƒè¯•èŠ‚ç‚¹"""
        if node_name in breakpoints:
            print(f"\nğŸ›‘ æ–­ç‚¹è§¦å‘: {node_name}")
            print("ğŸ“Š å½“å‰çŠ¶æ€:")

            for key, value in state.items():
                print(f"  {key}: {value}")

            input("æŒ‰ Enter ç»§ç»­æ‰§è¡Œ...")

    return add_breakpoint, debug_node

# ä½¿ç”¨è°ƒè¯•å™¨
add_bp, debug = create_debug_visualizer()

# è®¾ç½®æ–­ç‚¹
add_bp("intent_analyzer")
add_bp("weather_handler")

# åœ¨èŠ‚ç‚¹ä¸­ä½¿ç”¨
def debuggable_node(node_name: str, func):
    """å¯è°ƒè¯•çš„èŠ‚ç‚¹"""
    def wrapper(state):
        debug(node_name, state)
        return func(state)
    return wrapper
```

## ğŸª å®è·µç»ƒä¹ 

### ç»ƒä¹  1ï¼šå¯è§†åŒ–ä½ çš„ç¬¬ä¸€ä¸ªå›¾

åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾å¹¶ç”Ÿæˆå…¶å¯è§†åŒ–ï¼š

```python
# åˆ›å»ºä¸€ä¸ªåŒ…å«æ¡ä»¶åˆ†æ”¯çš„ç®€å•å›¾
# ç„¶åä½¿ç”¨ä¸åŒçš„å¯è§†åŒ–æ–¹æ³•å±•ç¤ºå®ƒ
```

### ç»ƒä¹  2ï¼šæ‰§è¡Œè¿½è¸ªå™¨

ä¸º `Graphs/` ç›®å½•ä¸­çš„æŸä¸ª notebook æ·»åŠ æ‰§è¡Œè¿½è¸ªåŠŸèƒ½ï¼Œè§‚å¯ŸçŠ¶æ€å˜åŒ–è¿‡ç¨‹ã€‚

### ç»ƒä¹  3ï¼šå¤æ‚å›¾ç®€åŒ–

å¦‚æœä½ æœ‰ä¸€ä¸ªå¤æ‚çš„å›¾ï¼Œå°è¯•å°†å…¶åˆ†å±‚å±•ç¤ºï¼Œä½¿ç»“æ„æ›´æ¸…æ™°ã€‚

## ğŸ” å¯è§†åŒ–å·¥å…·å¯¹æ¯”

| å·¥å…· | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| Mermaid | ä¸“ä¸šã€ç¾è§‚ | éœ€è¦é¢å¤–å·¥å…·æ¸²æŸ“ | æ–‡æ¡£ã€å±•ç¤º |
| ASCII | ç®€å•ã€ç›´æ¥ | è¡¨è¾¾èƒ½åŠ›æœ‰é™ | å¿«é€Ÿè°ƒè¯• |
| æ‰§è¡Œè¿½è¸ª | åŠ¨æ€ã€è¯¦ç»† | è¾“å‡ºå†—é•¿ | æ·±åº¦è°ƒè¯• |
| åˆ†å±‚å±•ç¤º | ç»“æ„æ¸…æ™° | éœ€è¦æ‰‹åŠ¨æ•´ç† | å¤æ‚å›¾ç†è§£ |

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **å¯è§†åŒ–æ˜¯ç†è§£çš„æ¡¥æ¢**ï¼šå¤æ‚å›¾å¿…é¡»é€šè¿‡å¯è§†åŒ–æ‰èƒ½ç›´è§‚ç†è§£
2. **é€‰æ‹©åˆé€‚çš„å·¥å…·**ï¼šæ ¹æ®åœºæ™¯é€‰æ‹©æœ€é€‚åˆçš„å¯è§†åŒ–æ–¹æ³•
3. **å‘½åå¾ˆé‡è¦**ï¼šæ¸…æ™°çš„èŠ‚ç‚¹å‘½åè®©å›¾æ›´æ˜“è¯»
4. **åˆ†å±‚æ€è€ƒ**ï¼šå¤æ‚å›¾é€šè¿‡åˆ†å±‚å±•ç¤ºæ›´å®¹æ˜“ç†è§£
5. **è°ƒè¯•å‹å¥½**ï¼šå¥½çš„å¯è§†åŒ–å·¥å…·èƒ½å¤§å¤§æé«˜è°ƒè¯•æ•ˆç‡

## ğŸš€ ä¸‹ä¸€æ­¥

æŒæ¡å¯è§†åŒ–æŠ€å·§åï¼Œæ¥ä¸‹æ¥å­¦ä¹ ï¼š
- `../03-LangGraphåŸºç¡€/01-ä¸ºä»€ä¹ˆéœ€è¦LangGraph.md` - å¼€å§‹å®æˆ˜å­¦ä¹ 
- åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨è¿™äº›å¯è§†åŒ–æŠ€å·§

---

*ç°åœ¨ä½ å·²ç»æŒæ¡äº†å¯è§†åŒ– LangGraph çš„å„ç§æŠ€å·§ï¼Œå¤æ‚çš„å›¾ç»“æ„å†ä¹Ÿä¸ä¼šè®©ä½ å›°æƒ‘ï¼* ğŸ‰
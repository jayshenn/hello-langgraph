# 07-è®¤è¯ä¸æˆæƒ

## æ¦‚è¿°

è®¤è¯ä¸æˆæƒæ˜¯ä¼ä¸šçº§ LangGraph åº”ç”¨çš„å®‰å…¨åŸºçŸ³ã€‚æœ¬æ–‡æ¡£æ¶µç›–ä»åŸºç¡€çš„ API å¯†é’¥è®¤è¯åˆ°å¤æ‚çš„ OAuth2 å’ŒåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)ç³»ç»Ÿï¼Œç¡®ä¿åº”ç”¨åœ¨å¤šç”¨æˆ·ã€å¤šç§Ÿæˆ·ç¯å¢ƒä¸­çš„å®‰å…¨è¿è¡Œã€‚

## è®¤è¯ä¸æˆæƒæ¶æ„

### å®‰å…¨æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç”¨æˆ·ç«¯    â”‚â”€â”€â”€â–¶â”‚  è®¤è¯æœåŠ¡   â”‚â”€â”€â”€â–¶â”‚  æˆæƒæœåŠ¡   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚                   â”‚
                           â–¼                   â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ Tokenå­˜å‚¨   â”‚    â”‚  æƒé™ç®¡ç†   â”‚
                   â”‚  (Redis)    â”‚    â”‚ (Database)  â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚ LangGraph   â”‚
                                    â”‚ åº”ç”¨æœåŠ¡    â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæ¦‚å¿µ
- **è®¤è¯ (Authentication)**: éªŒè¯ç”¨æˆ·èº«ä»½
- **æˆæƒ (Authorization)**: æ§åˆ¶ç”¨æˆ·è®¿é—®æƒé™
- **ä¼šè¯ç®¡ç†**: ç»´æŠ¤ç”¨æˆ·çŠ¶æ€
- **è®¿é—®æ§åˆ¶**: åŸºäºè§’è‰²å’Œèµ„æºçš„æƒé™ç®¡ç†

## åŸºç¡€è®¤è¯æœºåˆ¶

### API å¯†é’¥è®¤è¯
```python
# api_key_auth.py
import hashlib
import secrets
from typing import Optional, Dict, Any
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

class APIKeyManager:
    """APIå¯†é’¥ç®¡ç†å™¨"""

    def __init__(self, redis_client):
        self.redis = redis_client

    def generate_api_key(self, user_id: str, name: str = "default") -> str:
        """ç”ŸæˆAPIå¯†é’¥"""
        # ç”Ÿæˆéšæœºå¯†é’¥
        api_key = f"lg_{secrets.token_urlsafe(32)}"

        # å­˜å‚¨å¯†é’¥ä¿¡æ¯
        key_data = {
            "user_id": user_id,
            "name": name,
            "created_at": time.time(),
            "last_used": None,
            "usage_count": 0
        }

        # ä½¿ç”¨hashå­˜å‚¨ï¼Œé¿å…æ˜æ–‡
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        self.redis.hset(f"api_key:{key_hash}", mapping=key_data)

        return api_key

    async def validate_api_key(self, api_key: str) -> Optional[Dict[str, Any]]:
        """éªŒè¯APIå¯†é’¥"""
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        key_data = await self.redis.hgetall(f"api_key:{key_hash}")

        if not key_data:
            return None

        # æ›´æ–°ä½¿ç”¨ç»Ÿè®¡
        await self.redis.hincrby(f"api_key:{key_hash}", "usage_count", 1)
        await self.redis.hset(f"api_key:{key_hash}", "last_used", time.time())

        return key_data

    async def revoke_api_key(self, api_key: str) -> bool:
        """æ’¤é”€APIå¯†é’¥"""
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        result = await self.redis.delete(f"api_key:{key_hash}")
        return result > 0

# è®¤è¯ä¾èµ–
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    api_key_manager: APIKeyManager = Depends()
) -> Dict[str, Any]:
    """è·å–å½“å‰ç”¨æˆ·"""
    if not credentials.credentials.startswith("lg_"):
        raise HTTPException(
            status_code=401,
            detail="æ— æ•ˆçš„APIå¯†é’¥æ ¼å¼"
        )

    user_data = await api_key_manager.validate_api_key(credentials.credentials)
    if not user_data:
        raise HTTPException(
            status_code=401,
            detail="æ— æ•ˆçš„APIå¯†é’¥"
        )

    return {
        "user_id": user_data["user_id"],
        "api_key_name": user_data["name"]
    }

# ä½¿ç”¨è®¤è¯
from fastapi import FastAPI, Depends

app = FastAPI()

@app.post("/agent/invoke")
async def invoke_agent(
    request: dict,
    current_user: dict = Depends(get_current_user)
):
    """è°ƒç”¨Agentï¼ˆéœ€è¦è®¤è¯ï¼‰"""
    user_id = current_user["user_id"]

    # æ·»åŠ ç”¨æˆ·ä¸Šä¸‹æ–‡åˆ°è¯·æ±‚
    request["user_id"] = user_id

    # è°ƒç”¨Agenté€»è¾‘
    result = await agent.invoke(request)

    return {"result": result, "user_id": user_id}
```

### JWT Token è®¤è¯
```python
# jwt_auth.py
import jwt
import time
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer

security = HTTPBearer()

class JWTManager:
    """JWTç®¡ç†å™¨"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm

    def generate_token(
        self,
        user_id: str,
        roles: list = None,
        expires_in: int = 3600
    ) -> str:
        """ç”ŸæˆJWTä»¤ç‰Œ"""
        payload = {
            "user_id": user_id,
            "roles": roles or [],
            "iat": datetime.utcnow(),
            "exp": datetime.utcnow() + timedelta(seconds=expires_in),
            "iss": "langgraph-app"
        }

        token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        return token

    def validate_token(self, token: str) -> Dict[str, Any]:
        """éªŒè¯JWTä»¤ç‰Œ"""
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=401,
                detail="ä»¤ç‰Œå·²è¿‡æœŸ"
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=401,
                detail="æ— æ•ˆçš„ä»¤ç‰Œ"
            )

    def refresh_token(self, token: str) -> str:
        """åˆ·æ–°ä»¤ç‰Œ"""
        try:
            # éªŒè¯ä½†å¿½ç•¥è¿‡æœŸæ—¶é—´
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm],
                options={"verify_exp": False}
            )

            # ç”Ÿæˆæ–°ä»¤ç‰Œ
            return self.generate_token(
                payload["user_id"],
                payload.get("roles", [])
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=401,
                detail="æ— æ³•åˆ·æ–°ä»¤ç‰Œ"
            )

# JWTè®¤è¯ä¾èµ–
jwt_manager = JWTManager(secret_key="your-secret-key")

async def get_current_user_jwt(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict[str, Any]:
    """é€šè¿‡JWTè·å–å½“å‰ç”¨æˆ·"""
    token = credentials.credentials
    payload = jwt_manager.validate_token(token)

    return {
        "user_id": payload["user_id"],
        "roles": payload.get("roles", []),
        "expires_at": payload["exp"]
    }

# è§’è‰²æ£€æŸ¥è£…é¥°å™¨
def require_roles(required_roles: list):
    """è¦æ±‚ç‰¹å®šè§’è‰²çš„è£…é¥°å™¨"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=401,
                    detail="éœ€è¦è®¤è¯"
                )

            user_roles = current_user.get("roles", [])
            if not any(role in user_roles for role in required_roles):
                raise HTTPException(
                    status_code=403,
                    detail="æƒé™ä¸è¶³"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ä½¿ç”¨è§’è‰²æ£€æŸ¥
@app.post("/admin/users")
@require_roles(["admin", "user_manager"])
async def manage_users(
    request: dict,
    current_user: dict = Depends(get_current_user_jwt)
):
    """ç®¡ç†ç”¨æˆ·ï¼ˆéœ€è¦ç®¡ç†å‘˜æƒé™ï¼‰"""
    return {"message": "ç”¨æˆ·ç®¡ç†æ“ä½œ", "operator": current_user["user_id"]}
```

## OAuth2 é›†æˆ

### OAuth2 æä¾›è€…é…ç½®
```python
# oauth2_provider.py
import httpx
from authlib.integrations.starlette_client import OAuth
from starlette.config import Config
from typing import Dict, Any

# é…ç½®OAuth2æä¾›è€…
config = Config('.env')
oauth = OAuth(config)

# æ³¨å†ŒOAuth2æä¾›è€…
oauth.register(
    name='google',
    client_id=config('GOOGLE_CLIENT_ID'),
    client_secret=config('GOOGLE_CLIENT_SECRET'),
    authorize_url='https://accounts.google.com/o/oauth2/auth',
    access_token_url='https://oauth2.googleapis.com/token',
    client_kwargs={
        'scope': 'openid email profile',
        'response_type': 'code'
    }
)

oauth.register(
    name='github',
    client_id=config('GITHUB_CLIENT_ID'),
    client_secret=config('GITHUB_CLIENT_SECRET'),
    access_token_url='https://github.com/login/oauth/access_token',
    authorize_url='https://github.com/login/oauth/authorize',
    api_base_url='https://api.github.com/',
    client_kwargs={'scope': 'user:email'},
)

class OAuth2Manager:
    """OAuth2ç®¡ç†å™¨"""

    def __init__(self, jwt_manager: JWTManager, user_service):
        self.jwt_manager = jwt_manager
        self.user_service = user_service

    async def handle_oauth_callback(
        self,
        provider: str,
        code: str,
        state: str
    ) -> Dict[str, Any]:
        """å¤„ç†OAuthå›è°ƒ"""
        # è·å–è®¿é—®ä»¤ç‰Œ
        token = await oauth.create_client(provider).authorize_access_token(code)

        # è·å–ç”¨æˆ·ä¿¡æ¯
        user_info = await self._get_user_info(provider, token)

        # åˆ›å»ºæˆ–æ›´æ–°ç”¨æˆ·
        user = await self.user_service.create_or_update_oauth_user(
            provider=provider,
            provider_user_id=user_info["id"],
            email=user_info["email"],
            name=user_info["name"],
            avatar_url=user_info.get("avatar_url")
        )

        # ç”ŸæˆJWTä»¤ç‰Œ
        jwt_token = self.jwt_manager.generate_token(
            user_id=user["id"],
            roles=user["roles"]
        )

        return {
            "access_token": jwt_token,
            "token_type": "bearer",
            "user": user
        }

    async def _get_user_info(self, provider: str, token: dict) -> Dict[str, Any]:
        """è·å–ç”¨æˆ·ä¿¡æ¯"""
        if provider == "google":
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://www.googleapis.com/oauth2/v2/userinfo",
                    headers={"Authorization": f"Bearer {token['access_token']}"}
                )
                return response.json()

        elif provider == "github":
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.github.com/user",
                    headers={"Authorization": f"Bearer {token['access_token']}"}
                )
                return response.json()

        else:
            raise ValueError(f"ä¸æ”¯æŒçš„OAuthæä¾›è€…: {provider}")

# OAuthè·¯ç”±
@app.get("/auth/{provider}")
async def oauth_login(provider: str, request: Request):
    """OAuthç™»å½•"""
    if provider not in ["google", "github"]:
        raise HTTPException(status_code=400, detail="ä¸æ”¯æŒçš„ç™»å½•æä¾›è€…")

    client = oauth.create_client(provider)
    redirect_uri = request.url_for('oauth_callback', provider=provider)

    return await client.authorize_redirect(request, redirect_uri)

@app.get("/auth/{provider}/callback")
async def oauth_callback(
    provider: str,
    request: Request,
    oauth_manager: OAuth2Manager = Depends()
):
    """OAuthå›è°ƒ"""
    code = request.query_params.get('code')
    state = request.query_params.get('state')

    if not code:
        raise HTTPException(status_code=400, detail="ç¼ºå°‘æˆæƒä»£ç ")

    result = await oauth_manager.handle_oauth_callback(provider, code, state)

    return result
```

## åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ (RBAC)

### RBAC æ•°æ®æ¨¡å‹
```python
# rbac_models.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Table, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

# ç”¨æˆ·è§’è‰²å…³è”è¡¨
user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True)
)

# è§’è‰²æƒé™å…³è”è¡¨
role_permissions = Table(
    'role_permissions',
    Base.metadata,
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    Column('permission_id', Integer, ForeignKey('permissions.id'), primary_key=True)
)

class User(Base):
    """ç”¨æˆ·æ¨¡å‹"""
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(128))
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime)

    # OAuthç›¸å…³å­—æ®µ
    oauth_provider = Column(String(20))
    oauth_provider_id = Column(String(100))

    # å…³ç³»
    roles = relationship("Role", secondary=user_roles, back_populates="users")
    sessions = relationship("UserSession", back_populates="user")

class Role(Base):
    """è§’è‰²æ¨¡å‹"""
    __tablename__ = 'roles'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)
    description = Column(String(200))
    is_system = Column(Boolean, default=False)  # ç³»ç»Ÿè§’è‰²ä¸å¯åˆ é™¤
    created_at = Column(DateTime, default=datetime.utcnow)

    # å…³ç³»
    users = relationship("User", secondary=user_roles, back_populates="roles")
    permissions = relationship("Permission", secondary=role_permissions, back_populates="roles")

class Permission(Base):
    """æƒé™æ¨¡å‹"""
    __tablename__ = 'permissions'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)
    description = Column(String(200))
    resource = Column(String(50), nullable=False)  # èµ„æºç±»å‹
    action = Column(String(20), nullable=False)    # æ“ä½œç±»å‹
    created_at = Column(DateTime, default=datetime.utcnow)

    # å…³ç³»
    roles = relationship("Role", secondary=role_permissions, back_populates="permissions")

class UserSession(Base):
    """ç”¨æˆ·ä¼šè¯æ¨¡å‹"""
    __tablename__ = 'user_sessions'

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    session_token = Column(String(128), unique=True, nullable=False)
    ip_address = Column(String(45))
    user_agent = Column(String(500))
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)
    is_active = Column(Boolean, default=True)

    # å…³ç³»
    user = relationship("User", back_populates="sessions")
```

### RBAC æœåŠ¡å±‚
```python
# rbac_service.py
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from .rbac_models import User, Role, Permission

class RBACService:
    """RBACæœåŠ¡"""

    def __init__(self, db_session: Session):
        self.db = db_session

    def create_user(
        self,
        username: str,
        email: str,
        password_hash: str = None,
        roles: List[str] = None
    ) -> User:
        """åˆ›å»ºç”¨æˆ·"""
        user = User(
            username=username,
            email=email,
            password_hash=password_hash
        )

        if roles:
            user_roles = self.db.query(Role).filter(Role.name.in_(roles)).all()
            user.roles = user_roles

        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)

        return user

    def assign_role(self, user_id: int, role_name: str) -> bool:
        """åˆ†é…è§’è‰²ç»™ç”¨æˆ·"""
        user = self.db.query(User).filter(User.id == user_id).first()
        role = self.db.query(Role).filter(Role.name == role_name).first()

        if not user or not role:
            return False

        if role not in user.roles:
            user.roles.append(role)
            self.db.commit()

        return True

    def remove_role(self, user_id: int, role_name: str) -> bool:
        """ç§»é™¤ç”¨æˆ·è§’è‰²"""
        user = self.db.query(User).filter(User.id == user_id).first()
        role = self.db.query(Role).filter(Role.name == role_name).first()

        if not user or not role:
            return False

        if role in user.roles:
            user.roles.remove(role)
            self.db.commit()

        return True

    def check_permission(
        self,
        user_id: int,
        resource: str,
        action: str
    ) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æƒé™"""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user or not user.is_active:
            return False

        # è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
        permissions = []
        for role in user.roles:
            permissions.extend(role.permissions)

        # æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…çš„æƒé™
        for permission in permissions:
            if (permission.resource == resource and
                permission.action == action):
                return True

        return False

    def get_user_permissions(self, user_id: int) -> List[Dict[str, str]]:
        """è·å–ç”¨æˆ·æ‰€æœ‰æƒé™"""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return []

        permissions = []
        for role in user.roles:
            for permission in role.permissions:
                permissions.append({
                    "resource": permission.resource,
                    "action": permission.action,
                    "name": permission.name
                })

        return permissions

    def create_role(
        self,
        name: str,
        description: str,
        permissions: List[str] = None
    ) -> Role:
        """åˆ›å»ºè§’è‰²"""
        role = Role(name=name, description=description)

        if permissions:
            role_permissions = (
                self.db.query(Permission)
                .filter(Permission.name.in_(permissions))
                .all()
            )
            role.permissions = role_permissions

        self.db.add(role)
        self.db.commit()
        self.db.refresh(role)

        return role

    def create_permission(
        self,
        name: str,
        description: str,
        resource: str,
        action: str
    ) -> Permission:
        """åˆ›å»ºæƒé™"""
        permission = Permission(
            name=name,
            description=description,
            resource=resource,
            action=action
        )

        self.db.add(permission)
        self.db.commit()
        self.db.refresh(permission)

        return permission

# æƒé™æ£€æŸ¥è£…é¥°å™¨
def require_permission(resource: str, action: str):
    """è¦æ±‚ç‰¹å®šæƒé™çš„è£…é¥°å™¨"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=401,
                    detail="éœ€è¦è®¤è¯"
                )

            rbac_service = RBACService(get_db_session())
            if not rbac_service.check_permission(
                current_user["user_id"],
                resource,
                action
            ):
                raise HTTPException(
                    status_code=403,
                    detail=f"ç¼ºå°‘æƒé™: {resource}:{action}"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ä½¿ç”¨æƒé™æ£€æŸ¥
@app.post("/agents/create")
@require_permission("agent", "create")
async def create_agent(
    request: dict,
    current_user: dict = Depends(get_current_user_jwt)
):
    """åˆ›å»ºAgentï¼ˆéœ€è¦åˆ›å»ºæƒé™ï¼‰"""
    return {"message": "Agentåˆ›å»ºæˆåŠŸ", "creator": current_user["user_id"]}

@app.delete("/agents/{agent_id}")
@require_permission("agent", "delete")
async def delete_agent(
    agent_id: str,
    current_user: dict = Depends(get_current_user_jwt)
):
    """åˆ é™¤Agentï¼ˆéœ€è¦åˆ é™¤æƒé™ï¼‰"""
    return {"message": f"Agent {agent_id} åˆ é™¤æˆåŠŸ"}
```

## å¤šç§Ÿæˆ·æ¶æ„

### ç§Ÿæˆ·éš”ç¦»
```python
# multi_tenant.py
from typing import Optional
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

class Tenant(Base):
    """ç§Ÿæˆ·æ¨¡å‹"""
    __tablename__ = 'tenants'

    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    subdomain = Column(String(50), unique=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # å…³ç³»
    users = relationship("User", back_populates="tenant")
    agents = relationship("Agent", back_populates="tenant")

# æ›´æ–°ç”¨æˆ·æ¨¡å‹æ·»åŠ ç§Ÿæˆ·
class User(Base):
    # ... å…¶ä»–å­—æ®µ ...
    tenant_id = Column(Integer, ForeignKey('tenants.id'), nullable=False)
    tenant = relationship("Tenant", back_populates="users")

class TenantService:
    """ç§Ÿæˆ·æœåŠ¡"""

    def __init__(self, db_session: Session):
        self.db = db_session

    def create_tenant(self, name: str, subdomain: str) -> Tenant:
        """åˆ›å»ºç§Ÿæˆ·"""
        tenant = Tenant(name=name, subdomain=subdomain)
        self.db.add(tenant)
        self.db.commit()
        self.db.refresh(tenant)

        # åˆ›å»ºé»˜è®¤è§’è‰²
        self._create_default_roles(tenant.id)

        return tenant

    def _create_default_roles(self, tenant_id: int):
        """ä¸ºç§Ÿæˆ·åˆ›å»ºé»˜è®¤è§’è‰²"""
        default_roles = [
            {
                "name": f"admin_{tenant_id}",
                "description": "ç§Ÿæˆ·ç®¡ç†å‘˜",
                "permissions": ["*:*"]  # æ‰€æœ‰æƒé™
            },
            {
                "name": f"user_{tenant_id}",
                "description": "æ™®é€šç”¨æˆ·",
                "permissions": ["agent:read", "agent:execute"]
            }
        ]

        for role_data in default_roles:
            role = Role(
                name=role_data["name"],
                description=role_data["description"]
            )
            self.db.add(role)

        self.db.commit()

    def get_tenant_by_subdomain(self, subdomain: str) -> Optional[Tenant]:
        """æ ¹æ®å­åŸŸåè·å–ç§Ÿæˆ·"""
        return (
            self.db.query(Tenant)
            .filter(Tenant.subdomain == subdomain)
            .filter(Tenant.is_active == True)
            .first()
        )

# ç§Ÿæˆ·ä¸­é—´ä»¶
class TenantMiddleware:
    """ç§Ÿæˆ·ä¸­é—´ä»¶"""

    def __init__(self, app, tenant_service: TenantService):
        self.app = app
        self.tenant_service = tenant_service

    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            # ä»Hostå¤´ä¸­æå–å­åŸŸå
            host = scope.get("headers", {}).get("host", "")
            subdomain = self._extract_subdomain(host)

            if subdomain:
                tenant = self.tenant_service.get_tenant_by_subdomain(subdomain)
                if tenant:
                    scope["tenant"] = tenant
                else:
                    # ç§Ÿæˆ·ä¸å­˜åœ¨ï¼Œè¿”å›404
                    response = PlainTextResponse(
                        "ç§Ÿæˆ·ä¸å­˜åœ¨",
                        status_code=404
                    )
                    await response(scope, receive, send)
                    return

        await self.app(scope, receive, send)

    def _extract_subdomain(self, host: str) -> str:
        """æå–å­åŸŸå"""
        parts = host.split(".")
        if len(parts) > 2:
            return parts[0]
        return ""

# ç§Ÿæˆ·ä¸Šä¸‹æ–‡ç®¡ç†
def get_current_tenant(request: Request) -> Tenant:
    """è·å–å½“å‰ç§Ÿæˆ·"""
    tenant = getattr(request.scope, "tenant", None)
    if not tenant:
        raise HTTPException(
            status_code=400,
            detail="æœªæŒ‡å®šç§Ÿæˆ·"
        )
    return tenant

# ä½¿ç”¨ç§Ÿæˆ·éš”ç¦»
@app.get("/agents")
async def list_agents(
    current_user: dict = Depends(get_current_user_jwt),
    tenant: Tenant = Depends(get_current_tenant)
):
    """åˆ—å‡ºç§Ÿæˆ·çš„Agents"""
    # åªè¿”å›å½“å‰ç§Ÿæˆ·çš„Agents
    agents = get_agents_by_tenant(tenant.id)
    return {"agents": agents, "tenant": tenant.name}
```

## å®‰å…¨æœ€ä½³å®è·µ

### å¯†ç å®‰å…¨
```python
# password_security.py
import bcrypt
import secrets
from typing import str

class PasswordManager:
    """å¯†ç ç®¡ç†å™¨"""

    @staticmethod
    def hash_password(password: str) -> str:
        """å“ˆå¸Œå¯†ç """
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')

    @staticmethod
    def verify_password(password: str, hashed: str) -> bool:
        """éªŒè¯å¯†ç """
        return bcrypt.checkpw(
            password.encode('utf-8'),
            hashed.encode('utf-8')
        )

    @staticmethod
    def generate_secure_password(length: int = 12) -> str:
        """ç”Ÿæˆå®‰å…¨å¯†ç """
        return secrets.token_urlsafe(length)

    @staticmethod
    def check_password_strength(password: str) -> Dict[str, Any]:
        """æ£€æŸ¥å¯†ç å¼ºåº¦"""
        score = 0
        feedback = []

        # é•¿åº¦æ£€æŸ¥
        if len(password) >= 8:
            score += 1
        else:
            feedback.append("å¯†ç è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦")

        # åŒ…å«å¤§å†™å­—æ¯
        if any(c.isupper() for c in password):
            score += 1
        else:
            feedback.append("å¯†ç éœ€è¦åŒ…å«å¤§å†™å­—æ¯")

        # åŒ…å«å°å†™å­—æ¯
        if any(c.islower() for c in password):
            score += 1
        else:
            feedback.append("å¯†ç éœ€è¦åŒ…å«å°å†™å­—æ¯")

        # åŒ…å«æ•°å­—
        if any(c.isdigit() for c in password):
            score += 1
        else:
            feedback.append("å¯†ç éœ€è¦åŒ…å«æ•°å­—")

        # åŒ…å«ç‰¹æ®Šå­—ç¬¦
        special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        if any(c in special_chars for c in password):
            score += 1
        else:
            feedback.append("å¯†ç éœ€è¦åŒ…å«ç‰¹æ®Šå­—ç¬¦")

        strength_levels = {
            0: "éå¸¸å¼±",
            1: "å¼±",
            2: "ä¸€èˆ¬",
            3: "å¼º",
            4: "å¾ˆå¼º",
            5: "æå¼º"
        }

        return {
            "score": score,
            "strength": strength_levels[score],
            "feedback": feedback
        }
```

### ä¼šè¯ç®¡ç†
```python
# session_management.py
import time
import uuid
from typing import Optional, Dict, Any

class SessionManager:
    """ä¼šè¯ç®¡ç†å™¨"""

    def __init__(self, redis_client, default_ttl: int = 3600):
        self.redis = redis_client
        self.default_ttl = default_ttl

    async def create_session(
        self,
        user_id: str,
        ip_address: str,
        user_agent: str,
        ttl: Optional[int] = None
    ) -> str:
        """åˆ›å»ºä¼šè¯"""
        session_id = str(uuid.uuid4())
        session_data = {
            "user_id": user_id,
            "ip_address": ip_address,
            "user_agent": user_agent,
            "created_at": time.time(),
            "last_activity": time.time()
        }

        await self.redis.hset(f"session:{session_id}", mapping=session_data)
        await self.redis.expire(f"session:{session_id}", ttl or self.default_ttl)

        return session_id

    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """è·å–ä¼šè¯"""
        session_data = await self.redis.hgetall(f"session:{session_id}")
        if session_data:
            # æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
            await self.redis.hset(
                f"session:{session_id}",
                "last_activity",
                time.time()
            )
            return session_data
        return None

    async def invalidate_session(self, session_id: str) -> bool:
        """ä½¿ä¼šè¯å¤±æ•ˆ"""
        result = await self.redis.delete(f"session:{session_id}")
        return result > 0

    async def invalidate_user_sessions(self, user_id: str) -> int:
        """ä½¿ç”¨æˆ·æ‰€æœ‰ä¼šè¯å¤±æ•ˆ"""
        pattern = "session:*"
        count = 0

        async for key in self.redis.scan_iter(pattern):
            session_data = await self.redis.hgetall(key)
            if session_data.get("user_id") == user_id:
                await self.redis.delete(key)
                count += 1

        return count

    async def cleanup_expired_sessions(self):
        """æ¸…ç†è¿‡æœŸä¼šè¯"""
        pattern = "session:*"
        current_time = time.time()
        count = 0

        async for key in self.redis.scan_iter(pattern):
            ttl = await self.redis.ttl(key)
            if ttl == -1:  # æ²¡æœ‰è¿‡æœŸæ—¶é—´çš„ä¼šè¯
                session_data = await self.redis.hgetall(key)
                last_activity = float(session_data.get("last_activity", 0))

                # å¦‚æœè¶…è¿‡24å°æ—¶æ²¡æœ‰æ´»åŠ¨ï¼Œåˆ é™¤ä¼šè¯
                if current_time - last_activity > 86400:
                    await self.redis.delete(key)
                    count += 1

        return count
```

## å®‰å…¨é…ç½®

### ç¯å¢ƒå˜é‡é…ç½®
```bash
# .env.security
# JWTé…ç½®
JWT_SECRET_KEY=your-very-secure-secret-key-here
JWT_ALGORITHM=HS256
JWT_EXPIRATION=3600

# OAuth2é…ç½®
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

# æ•°æ®åº“åŠ å¯†
DATABASE_ENCRYPTION_KEY=your-database-encryption-key

# Redisè¿æ¥
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=your-redis-password

# å®‰å…¨è®¾ç½®
BCRYPT_ROUNDS=12
SESSION_TIMEOUT=3600
MAX_LOGIN_ATTEMPTS=5
LOCKOUT_DURATION=900

# CORSè®¾ç½®
ALLOWED_ORIGINS=https://yourdomain.com,https://app.yourdomain.com
ALLOWED_METHODS=GET,POST,PUT,DELETE
ALLOWED_HEADERS=Authorization,Content-Type
```

### å®‰å…¨ä¸­é—´ä»¶
```python
# security_middleware.py
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import time

app = FastAPI()

# CORSä¸­é—´ä»¶
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["Authorization", "Content-Type"],
)

# ä¿¡ä»»ä¸»æœºä¸­é—´ä»¶
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["yourdomain.com", "*.yourdomain.com"]
)

# é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
class RateLimitMiddleware:
    """é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶"""

    def __init__(self, app, redis_client, max_requests: int = 100, window: int = 60):
        self.app = app
        self.redis = redis_client
        self.max_requests = max_requests
        self.window = window

    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            # è·å–å®¢æˆ·ç«¯IP
            client_ip = scope.get("client", ["unknown", None])[0]
            key = f"rate_limit:{client_ip}"

            # æ£€æŸ¥é€Ÿç‡é™åˆ¶
            current_requests = await self.redis.get(key)
            if current_requests is None:
                # ç¬¬ä¸€æ¬¡è¯·æ±‚
                await self.redis.setex(key, self.window, 1)
            else:
                current_requests = int(current_requests)
                if current_requests >= self.max_requests:
                    # è¶…è¿‡é€Ÿç‡é™åˆ¶
                    response = PlainTextResponse(
                        "Rate limit exceeded",
                        status_code=429
                    )
                    await response(scope, receive, send)
                    return
                else:
                    # å¢åŠ è¯·æ±‚è®¡æ•°
                    await self.redis.incr(key)

        await self.app(scope, receive, send)

app.add_middleware(RateLimitMiddleware, redis_client=redis_client)

# å®‰å…¨å¤´ä¸­é—´ä»¶
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    """æ·»åŠ å®‰å…¨å¤´"""
    response = await call_next(request)

    # å®‰å…¨ç›¸å…³å¤´éƒ¨
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    response.headers["Content-Security-Policy"] = "default-src 'self'"

    return response
```

## ä¸‹ä¸€æ­¥

- ğŸ”— å­¦ä¹  [08-Webhooksé›†æˆ](./08-Webhooksé›†æˆ.md) - äº‹ä»¶é©±åŠ¨æ¶æ„
- ğŸ“– æŸ¥çœ‹éƒ¨ç½²é€‰é¡¹æ€»è§ˆ - é€‰æ‹©æœ€é€‚åˆçš„éƒ¨ç½²æ–¹æ¡ˆ

## ç›¸å…³é“¾æ¥

- [LangGraph Platform è®¤è¯](https://langchain-ai.github.io/langgraph/concepts/auth/)
- [FastAPI å®‰å…¨æŒ‡å—](https://fastapi.tiangolo.com/tutorial/security/)
- [OAuth2 è§„èŒƒ](https://oauth.net/2/)
- [JWT æœ€ä½³å®è·µ](https://auth0.com/blog/a-look-at-the-latest-draft-for-jwt-bcp/)
# 07-认证与授权

## 概述

认证与授权是企业级 LangGraph 应用的安全基石。本文档涵盖从基础的 API 密钥认证到复杂的 OAuth2 和基于角色的访问控制(RBAC)系统，确保应用在多用户、多租户环境中的安全运行。

## 认证与授权架构

### 安全架构图
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   用户端    │───▶│  认证服务   │───▶│  授权服务   │
└─────────────┘    └─────────────┘    └─────────────┘
                           │                   │
                           ▼                   ▼
                   ┌─────────────┐    ┌─────────────┐
                   │ Token存储   │    │  权限管理   │
                   │  (Redis)    │    │ (Database)  │
                   └─────────────┘    └─────────────┘
                                             │
                                             ▼
                                    ┌─────────────┐
                                    │ LangGraph   │
                                    │ 应用服务    │
                                    └─────────────┘
```

### 核心概念
- **认证 (Authentication)**: 验证用户身份
- **授权 (Authorization)**: 控制用户访问权限
- **会话管理**: 维护用户状态
- **访问控制**: 基于角色和资源的权限管理

## 基础认证机制

### API 密钥认证
```python
# api_key_auth.py
import hashlib
import secrets
from typing import Optional, Dict, Any
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

class APIKeyManager:
    """API密钥管理器"""

    def __init__(self, redis_client):
        self.redis = redis_client

    def generate_api_key(self, user_id: str, name: str = "default") -> str:
        """生成API密钥"""
        # 生成随机密钥
        api_key = f"lg_{secrets.token_urlsafe(32)}"

        # 存储密钥信息
        key_data = {
            "user_id": user_id,
            "name": name,
            "created_at": time.time(),
            "last_used": None,
            "usage_count": 0
        }

        # 使用hash存储，避免明文
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        self.redis.hset(f"api_key:{key_hash}", mapping=key_data)

        return api_key

    async def validate_api_key(self, api_key: str) -> Optional[Dict[str, Any]]:
        """验证API密钥"""
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        key_data = await self.redis.hgetall(f"api_key:{key_hash}")

        if not key_data:
            return None

        # 更新使用统计
        await self.redis.hincrby(f"api_key:{key_hash}", "usage_count", 1)
        await self.redis.hset(f"api_key:{key_hash}", "last_used", time.time())

        return key_data

    async def revoke_api_key(self, api_key: str) -> bool:
        """撤销API密钥"""
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        result = await self.redis.delete(f"api_key:{key_hash}")
        return result > 0

# 认证依赖
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    api_key_manager: APIKeyManager = Depends()
) -> Dict[str, Any]:
    """获取当前用户"""
    if not credentials.credentials.startswith("lg_"):
        raise HTTPException(
            status_code=401,
            detail="无效的API密钥格式"
        )

    user_data = await api_key_manager.validate_api_key(credentials.credentials)
    if not user_data:
        raise HTTPException(
            status_code=401,
            detail="无效的API密钥"
        )

    return {
        "user_id": user_data["user_id"],
        "api_key_name": user_data["name"]
    }

# 使用认证
from fastapi import FastAPI, Depends

app = FastAPI()

@app.post("/agent/invoke")
async def invoke_agent(
    request: dict,
    current_user: dict = Depends(get_current_user)
):
    """调用Agent（需要认证）"""
    user_id = current_user["user_id"]

    # 添加用户上下文到请求
    request["user_id"] = user_id

    # 调用Agent逻辑
    result = await agent.invoke(request)

    return {"result": result, "user_id": user_id}
```

### JWT Token 认证
```python
# jwt_auth.py
import jwt
import time
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer

security = HTTPBearer()

class JWTManager:
    """JWT管理器"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm

    def generate_token(
        self,
        user_id: str,
        roles: list = None,
        expires_in: int = 3600
    ) -> str:
        """生成JWT令牌"""
        payload = {
            "user_id": user_id,
            "roles": roles or [],
            "iat": datetime.utcnow(),
            "exp": datetime.utcnow() + timedelta(seconds=expires_in),
            "iss": "langgraph-app"
        }

        token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        return token

    def validate_token(self, token: str) -> Dict[str, Any]:
        """验证JWT令牌"""
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=401,
                detail="令牌已过期"
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=401,
                detail="无效的令牌"
            )

    def refresh_token(self, token: str) -> str:
        """刷新令牌"""
        try:
            # 验证但忽略过期时间
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm],
                options={"verify_exp": False}
            )

            # 生成新令牌
            return self.generate_token(
                payload["user_id"],
                payload.get("roles", [])
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=401,
                detail="无法刷新令牌"
            )

# JWT认证依赖
jwt_manager = JWTManager(secret_key="your-secret-key")

async def get_current_user_jwt(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict[str, Any]:
    """通过JWT获取当前用户"""
    token = credentials.credentials
    payload = jwt_manager.validate_token(token)

    return {
        "user_id": payload["user_id"],
        "roles": payload.get("roles", []),
        "expires_at": payload["exp"]
    }

# 角色检查装饰器
def require_roles(required_roles: list):
    """要求特定角色的装饰器"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=401,
                    detail="需要认证"
                )

            user_roles = current_user.get("roles", [])
            if not any(role in user_roles for role in required_roles):
                raise HTTPException(
                    status_code=403,
                    detail="权限不足"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# 使用角色检查
@app.post("/admin/users")
@require_roles(["admin", "user_manager"])
async def manage_users(
    request: dict,
    current_user: dict = Depends(get_current_user_jwt)
):
    """管理用户（需要管理员权限）"""
    return {"message": "用户管理操作", "operator": current_user["user_id"]}
```

## OAuth2 集成

### OAuth2 提供者配置
```python
# oauth2_provider.py
import httpx
from authlib.integrations.starlette_client import OAuth
from starlette.config import Config
from typing import Dict, Any

# 配置OAuth2提供者
config = Config('.env')
oauth = OAuth(config)

# 注册OAuth2提供者
oauth.register(
    name='google',
    client_id=config('GOOGLE_CLIENT_ID'),
    client_secret=config('GOOGLE_CLIENT_SECRET'),
    authorize_url='https://accounts.google.com/o/oauth2/auth',
    access_token_url='https://oauth2.googleapis.com/token',
    client_kwargs={
        'scope': 'openid email profile',
        'response_type': 'code'
    }
)

oauth.register(
    name='github',
    client_id=config('GITHUB_CLIENT_ID'),
    client_secret=config('GITHUB_CLIENT_SECRET'),
    access_token_url='https://github.com/login/oauth/access_token',
    authorize_url='https://github.com/login/oauth/authorize',
    api_base_url='https://api.github.com/',
    client_kwargs={'scope': 'user:email'},
)

class OAuth2Manager:
    """OAuth2管理器"""

    def __init__(self, jwt_manager: JWTManager, user_service):
        self.jwt_manager = jwt_manager
        self.user_service = user_service

    async def handle_oauth_callback(
        self,
        provider: str,
        code: str,
        state: str
    ) -> Dict[str, Any]:
        """处理OAuth回调"""
        # 获取访问令牌
        token = await oauth.create_client(provider).authorize_access_token(code)

        # 获取用户信息
        user_info = await self._get_user_info(provider, token)

        # 创建或更新用户
        user = await self.user_service.create_or_update_oauth_user(
            provider=provider,
            provider_user_id=user_info["id"],
            email=user_info["email"],
            name=user_info["name"],
            avatar_url=user_info.get("avatar_url")
        )

        # 生成JWT令牌
        jwt_token = self.jwt_manager.generate_token(
            user_id=user["id"],
            roles=user["roles"]
        )

        return {
            "access_token": jwt_token,
            "token_type": "bearer",
            "user": user
        }

    async def _get_user_info(self, provider: str, token: dict) -> Dict[str, Any]:
        """获取用户信息"""
        if provider == "google":
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://www.googleapis.com/oauth2/v2/userinfo",
                    headers={"Authorization": f"Bearer {token['access_token']}"}
                )
                return response.json()

        elif provider == "github":
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.github.com/user",
                    headers={"Authorization": f"Bearer {token['access_token']}"}
                )
                return response.json()

        else:
            raise ValueError(f"不支持的OAuth提供者: {provider}")

# OAuth路由
@app.get("/auth/{provider}")
async def oauth_login(provider: str, request: Request):
    """OAuth登录"""
    if provider not in ["google", "github"]:
        raise HTTPException(status_code=400, detail="不支持的登录提供者")

    client = oauth.create_client(provider)
    redirect_uri = request.url_for('oauth_callback', provider=provider)

    return await client.authorize_redirect(request, redirect_uri)

@app.get("/auth/{provider}/callback")
async def oauth_callback(
    provider: str,
    request: Request,
    oauth_manager: OAuth2Manager = Depends()
):
    """OAuth回调"""
    code = request.query_params.get('code')
    state = request.query_params.get('state')

    if not code:
        raise HTTPException(status_code=400, detail="缺少授权代码")

    result = await oauth_manager.handle_oauth_callback(provider, code, state)

    return result
```

## 基于角色的访问控制 (RBAC)

### RBAC 数据模型
```python
# rbac_models.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Table, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

# 用户角色关联表
user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True)
)

# 角色权限关联表
role_permissions = Table(
    'role_permissions',
    Base.metadata,
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    Column('permission_id', Integer, ForeignKey('permissions.id'), primary_key=True)
)

class User(Base):
    """用户模型"""
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(128))
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime)

    # OAuth相关字段
    oauth_provider = Column(String(20))
    oauth_provider_id = Column(String(100))

    # 关系
    roles = relationship("Role", secondary=user_roles, back_populates="users")
    sessions = relationship("UserSession", back_populates="user")

class Role(Base):
    """角色模型"""
    __tablename__ = 'roles'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)
    description = Column(String(200))
    is_system = Column(Boolean, default=False)  # 系统角色不可删除
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    users = relationship("User", secondary=user_roles, back_populates="roles")
    permissions = relationship("Permission", secondary=role_permissions, back_populates="roles")

class Permission(Base):
    """权限模型"""
    __tablename__ = 'permissions'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True, nullable=False)
    description = Column(String(200))
    resource = Column(String(50), nullable=False)  # 资源类型
    action = Column(String(20), nullable=False)    # 操作类型
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    roles = relationship("Role", secondary=role_permissions, back_populates="permissions")

class UserSession(Base):
    """用户会话模型"""
    __tablename__ = 'user_sessions'

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    session_token = Column(String(128), unique=True, nullable=False)
    ip_address = Column(String(45))
    user_agent = Column(String(500))
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)
    is_active = Column(Boolean, default=True)

    # 关系
    user = relationship("User", back_populates="sessions")
```

### RBAC 服务层
```python
# rbac_service.py
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from .rbac_models import User, Role, Permission

class RBACService:
    """RBAC服务"""

    def __init__(self, db_session: Session):
        self.db = db_session

    def create_user(
        self,
        username: str,
        email: str,
        password_hash: str = None,
        roles: List[str] = None
    ) -> User:
        """创建用户"""
        user = User(
            username=username,
            email=email,
            password_hash=password_hash
        )

        if roles:
            user_roles = self.db.query(Role).filter(Role.name.in_(roles)).all()
            user.roles = user_roles

        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)

        return user

    def assign_role(self, user_id: int, role_name: str) -> bool:
        """分配角色给用户"""
        user = self.db.query(User).filter(User.id == user_id).first()
        role = self.db.query(Role).filter(Role.name == role_name).first()

        if not user or not role:
            return False

        if role not in user.roles:
            user.roles.append(role)
            self.db.commit()

        return True

    def remove_role(self, user_id: int, role_name: str) -> bool:
        """移除用户角色"""
        user = self.db.query(User).filter(User.id == user_id).first()
        role = self.db.query(Role).filter(Role.name == role_name).first()

        if not user or not role:
            return False

        if role in user.roles:
            user.roles.remove(role)
            self.db.commit()

        return True

    def check_permission(
        self,
        user_id: int,
        resource: str,
        action: str
    ) -> bool:
        """检查用户权限"""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user or not user.is_active:
            return False

        # 获取用户所有权限
        permissions = []
        for role in user.roles:
            permissions.extend(role.permissions)

        # 检查是否有匹配的权限
        for permission in permissions:
            if (permission.resource == resource and
                permission.action == action):
                return True

        return False

    def get_user_permissions(self, user_id: int) -> List[Dict[str, str]]:
        """获取用户所有权限"""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return []

        permissions = []
        for role in user.roles:
            for permission in role.permissions:
                permissions.append({
                    "resource": permission.resource,
                    "action": permission.action,
                    "name": permission.name
                })

        return permissions

    def create_role(
        self,
        name: str,
        description: str,
        permissions: List[str] = None
    ) -> Role:
        """创建角色"""
        role = Role(name=name, description=description)

        if permissions:
            role_permissions = (
                self.db.query(Permission)
                .filter(Permission.name.in_(permissions))
                .all()
            )
            role.permissions = role_permissions

        self.db.add(role)
        self.db.commit()
        self.db.refresh(role)

        return role

    def create_permission(
        self,
        name: str,
        description: str,
        resource: str,
        action: str
    ) -> Permission:
        """创建权限"""
        permission = Permission(
            name=name,
            description=description,
            resource=resource,
            action=action
        )

        self.db.add(permission)
        self.db.commit()
        self.db.refresh(permission)

        return permission

# 权限检查装饰器
def require_permission(resource: str, action: str):
    """要求特定权限的装饰器"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=401,
                    detail="需要认证"
                )

            rbac_service = RBACService(get_db_session())
            if not rbac_service.check_permission(
                current_user["user_id"],
                resource,
                action
            ):
                raise HTTPException(
                    status_code=403,
                    detail=f"缺少权限: {resource}:{action}"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# 使用权限检查
@app.post("/agents/create")
@require_permission("agent", "create")
async def create_agent(
    request: dict,
    current_user: dict = Depends(get_current_user_jwt)
):
    """创建Agent（需要创建权限）"""
    return {"message": "Agent创建成功", "creator": current_user["user_id"]}

@app.delete("/agents/{agent_id}")
@require_permission("agent", "delete")
async def delete_agent(
    agent_id: str,
    current_user: dict = Depends(get_current_user_jwt)
):
    """删除Agent（需要删除权限）"""
    return {"message": f"Agent {agent_id} 删除成功"}
```

## 多租户架构

### 租户隔离
```python
# multi_tenant.py
from typing import Optional
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

class Tenant(Base):
    """租户模型"""
    __tablename__ = 'tenants'

    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    subdomain = Column(String(50), unique=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    users = relationship("User", back_populates="tenant")
    agents = relationship("Agent", back_populates="tenant")

# 更新用户模型添加租户
class User(Base):
    # ... 其他字段 ...
    tenant_id = Column(Integer, ForeignKey('tenants.id'), nullable=False)
    tenant = relationship("Tenant", back_populates="users")

class TenantService:
    """租户服务"""

    def __init__(self, db_session: Session):
        self.db = db_session

    def create_tenant(self, name: str, subdomain: str) -> Tenant:
        """创建租户"""
        tenant = Tenant(name=name, subdomain=subdomain)
        self.db.add(tenant)
        self.db.commit()
        self.db.refresh(tenant)

        # 创建默认角色
        self._create_default_roles(tenant.id)

        return tenant

    def _create_default_roles(self, tenant_id: int):
        """为租户创建默认角色"""
        default_roles = [
            {
                "name": f"admin_{tenant_id}",
                "description": "租户管理员",
                "permissions": ["*:*"]  # 所有权限
            },
            {
                "name": f"user_{tenant_id}",
                "description": "普通用户",
                "permissions": ["agent:read", "agent:execute"]
            }
        ]

        for role_data in default_roles:
            role = Role(
                name=role_data["name"],
                description=role_data["description"]
            )
            self.db.add(role)

        self.db.commit()

    def get_tenant_by_subdomain(self, subdomain: str) -> Optional[Tenant]:
        """根据子域名获取租户"""
        return (
            self.db.query(Tenant)
            .filter(Tenant.subdomain == subdomain)
            .filter(Tenant.is_active == True)
            .first()
        )

# 租户中间件
class TenantMiddleware:
    """租户中间件"""

    def __init__(self, app, tenant_service: TenantService):
        self.app = app
        self.tenant_service = tenant_service

    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            # 从Host头中提取子域名
            host = scope.get("headers", {}).get("host", "")
            subdomain = self._extract_subdomain(host)

            if subdomain:
                tenant = self.tenant_service.get_tenant_by_subdomain(subdomain)
                if tenant:
                    scope["tenant"] = tenant
                else:
                    # 租户不存在，返回404
                    response = PlainTextResponse(
                        "租户不存在",
                        status_code=404
                    )
                    await response(scope, receive, send)
                    return

        await self.app(scope, receive, send)

    def _extract_subdomain(self, host: str) -> str:
        """提取子域名"""
        parts = host.split(".")
        if len(parts) > 2:
            return parts[0]
        return ""

# 租户上下文管理
def get_current_tenant(request: Request) -> Tenant:
    """获取当前租户"""
    tenant = getattr(request.scope, "tenant", None)
    if not tenant:
        raise HTTPException(
            status_code=400,
            detail="未指定租户"
        )
    return tenant

# 使用租户隔离
@app.get("/agents")
async def list_agents(
    current_user: dict = Depends(get_current_user_jwt),
    tenant: Tenant = Depends(get_current_tenant)
):
    """列出租户的Agents"""
    # 只返回当前租户的Agents
    agents = get_agents_by_tenant(tenant.id)
    return {"agents": agents, "tenant": tenant.name}
```

## 安全最佳实践

### 密码安全
```python
# password_security.py
import bcrypt
import secrets
from typing import str

class PasswordManager:
    """密码管理器"""

    @staticmethod
    def hash_password(password: str) -> str:
        """哈希密码"""
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')

    @staticmethod
    def verify_password(password: str, hashed: str) -> bool:
        """验证密码"""
        return bcrypt.checkpw(
            password.encode('utf-8'),
            hashed.encode('utf-8')
        )

    @staticmethod
    def generate_secure_password(length: int = 12) -> str:
        """生成安全密码"""
        return secrets.token_urlsafe(length)

    @staticmethod
    def check_password_strength(password: str) -> Dict[str, Any]:
        """检查密码强度"""
        score = 0
        feedback = []

        # 长度检查
        if len(password) >= 8:
            score += 1
        else:
            feedback.append("密码至少需要8个字符")

        # 包含大写字母
        if any(c.isupper() for c in password):
            score += 1
        else:
            feedback.append("密码需要包含大写字母")

        # 包含小写字母
        if any(c.islower() for c in password):
            score += 1
        else:
            feedback.append("密码需要包含小写字母")

        # 包含数字
        if any(c.isdigit() for c in password):
            score += 1
        else:
            feedback.append("密码需要包含数字")

        # 包含特殊字符
        special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        if any(c in special_chars for c in password):
            score += 1
        else:
            feedback.append("密码需要包含特殊字符")

        strength_levels = {
            0: "非常弱",
            1: "弱",
            2: "一般",
            3: "强",
            4: "很强",
            5: "极强"
        }

        return {
            "score": score,
            "strength": strength_levels[score],
            "feedback": feedback
        }
```

### 会话管理
```python
# session_management.py
import time
import uuid
from typing import Optional, Dict, Any

class SessionManager:
    """会话管理器"""

    def __init__(self, redis_client, default_ttl: int = 3600):
        self.redis = redis_client
        self.default_ttl = default_ttl

    async def create_session(
        self,
        user_id: str,
        ip_address: str,
        user_agent: str,
        ttl: Optional[int] = None
    ) -> str:
        """创建会话"""
        session_id = str(uuid.uuid4())
        session_data = {
            "user_id": user_id,
            "ip_address": ip_address,
            "user_agent": user_agent,
            "created_at": time.time(),
            "last_activity": time.time()
        }

        await self.redis.hset(f"session:{session_id}", mapping=session_data)
        await self.redis.expire(f"session:{session_id}", ttl or self.default_ttl)

        return session_id

    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话"""
        session_data = await self.redis.hgetall(f"session:{session_id}")
        if session_data:
            # 更新最后活动时间
            await self.redis.hset(
                f"session:{session_id}",
                "last_activity",
                time.time()
            )
            return session_data
        return None

    async def invalidate_session(self, session_id: str) -> bool:
        """使会话失效"""
        result = await self.redis.delete(f"session:{session_id}")
        return result > 0

    async def invalidate_user_sessions(self, user_id: str) -> int:
        """使用户所有会话失效"""
        pattern = "session:*"
        count = 0

        async for key in self.redis.scan_iter(pattern):
            session_data = await self.redis.hgetall(key)
            if session_data.get("user_id") == user_id:
                await self.redis.delete(key)
                count += 1

        return count

    async def cleanup_expired_sessions(self):
        """清理过期会话"""
        pattern = "session:*"
        current_time = time.time()
        count = 0

        async for key in self.redis.scan_iter(pattern):
            ttl = await self.redis.ttl(key)
            if ttl == -1:  # 没有过期时间的会话
                session_data = await self.redis.hgetall(key)
                last_activity = float(session_data.get("last_activity", 0))

                # 如果超过24小时没有活动，删除会话
                if current_time - last_activity > 86400:
                    await self.redis.delete(key)
                    count += 1

        return count
```

## 安全配置

### 环境变量配置
```bash
# .env.security
# JWT配置
JWT_SECRET_KEY=your-very-secure-secret-key-here
JWT_ALGORITHM=HS256
JWT_EXPIRATION=3600

# OAuth2配置
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

# 数据库加密
DATABASE_ENCRYPTION_KEY=your-database-encryption-key

# Redis连接
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=your-redis-password

# 安全设置
BCRYPT_ROUNDS=12
SESSION_TIMEOUT=3600
MAX_LOGIN_ATTEMPTS=5
LOCKOUT_DURATION=900

# CORS设置
ALLOWED_ORIGINS=https://yourdomain.com,https://app.yourdomain.com
ALLOWED_METHODS=GET,POST,PUT,DELETE
ALLOWED_HEADERS=Authorization,Content-Type
```

### 安全中间件
```python
# security_middleware.py
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import time

app = FastAPI()

# CORS中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["Authorization", "Content-Type"],
)

# 信任主机中间件
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["yourdomain.com", "*.yourdomain.com"]
)

# 速率限制中间件
class RateLimitMiddleware:
    """速率限制中间件"""

    def __init__(self, app, redis_client, max_requests: int = 100, window: int = 60):
        self.app = app
        self.redis = redis_client
        self.max_requests = max_requests
        self.window = window

    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            # 获取客户端IP
            client_ip = scope.get("client", ["unknown", None])[0]
            key = f"rate_limit:{client_ip}"

            # 检查速率限制
            current_requests = await self.redis.get(key)
            if current_requests is None:
                # 第一次请求
                await self.redis.setex(key, self.window, 1)
            else:
                current_requests = int(current_requests)
                if current_requests >= self.max_requests:
                    # 超过速率限制
                    response = PlainTextResponse(
                        "Rate limit exceeded",
                        status_code=429
                    )
                    await response(scope, receive, send)
                    return
                else:
                    # 增加请求计数
                    await self.redis.incr(key)

        await self.app(scope, receive, send)

app.add_middleware(RateLimitMiddleware, redis_client=redis_client)

# 安全头中间件
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    """添加安全头"""
    response = await call_next(request)

    # 安全相关头部
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    response.headers["Content-Security-Policy"] = "default-src 'self'"

    return response
```

## 下一步

- 🔗 学习 [08-Webhooks集成](./08-Webhooks集成.md) - 事件驱动架构
- 📖 查看部署选项总览 - 选择最适合的部署方案

## 相关链接

- [LangGraph Platform 认证](https://langchain-ai.github.io/langgraph/concepts/auth/)
- [FastAPI 安全指南](https://fastapi.tiangolo.com/tutorial/security/)
- [OAuth2 规范](https://oauth.net/2/)
- [JWT 最佳实践](https://auth0.com/blog/a-look-at-the-latest-draft-for-jwt-bcp/)
# 03-自托管

## 概述

自托管部署让你完全控制 LangGraph 应用的运行环境。提供四种部署选项：Self-Hosted Data Plane、Self-Hosted Control Plane、Standalone Container 和 Kubernetes 集群部署，满足不同的安全性、可控性和合规性需求。

## 部署选项对比

| 特性 | Cloud SaaS | Self-Hosted Data Plane | Self-Hosted Control Plane | Standalone Container |
|------|------------|-------------------------|----------------------------|---------------------|
| **基础设施管理** | LangChain | 用户 | 用户 | 用户 |
| **控制平面** | LangChain | LangChain | 用户 | 无 |
| **数据平面** | LangChain | 用户 | 用户 | 用户 |
| **复杂度** | 低 | 中 | 高 | 低 |
| **自定义性** | 低 | 中 | 高 | 高 |
| **合规性** | 标准 | 高 | 最高 | 高 |

## Self-Hosted Data Plane

### 架构概述
- **控制平面**：由 LangChain 管理
- **数据平面**：在你的基础设施中运行
- **适用场景**：需要数据隐私但希望简化管理

### 部署要求
```yaml
系统要求:
  - Kubernetes 1.21+
  - 或 Amazon ECS
  - 最少 2 vCPU, 4GB RAM
  - 持久化存储 20GB+
  - 网络访问控制平面
```

### Kubernetes 部署

#### 1. 准备 Helm Chart
```bash
# 添加 LangGraph Helm 仓库
helm repo add langgraph https://charts.langchain.dev
helm repo update

# 创建命名空间
kubectl create namespace langgraph
```

#### 2. 配置文件
```yaml
# values.yaml
global:
  deployment_type: "self_hosted_data_plane"
  license_key: "your_license_key"

dataPlane:
  image:
    repository: "langgraph/langgraph-server"
    tag: "latest"

  replicas: 2

  resources:
    requests:
      memory: "1Gi"
      cpu: "500m"
    limits:
      memory: "2Gi"
      cpu: "1000m"

  env:
    LANGSMITH_API_KEY: "your_langsmith_key"
    REDIS_URL: "redis://redis:6379"
    POSTGRES_URL: "postgresql://user:pass@postgres:5432/langgraph"

postgres:
  enabled: true
  primary:
    persistence:
      size: 20Gi
      storageClass: "gp2"

redis:
  enabled: true
  master:
    persistence:
      size: 8Gi
      storageClass: "gp2"

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: langgraph.yourdomain.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: langgraph-tls
      hosts:
        - langgraph.yourdomain.com
```

#### 3. 部署执行
```bash
# 安装 LangGraph Data Plane
helm install langgraph-dp langgraph/langgraph-data-plane \
  -n langgraph \
  -f values.yaml

# 检查部署状态
kubectl get pods -n langgraph

# 查看服务
kubectl get svc -n langgraph

# 查看日志
kubectl logs -f deployment/langgraph-server -n langgraph
```

### Amazon ECS 部署

#### 1. 任务定义
```json
{
  "family": "langgraph-data-plane",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "1024",
  "memory": "2048",
  "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::account:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "langgraph-server",
      "image": "langgraph/langgraph-server:latest",
      "portMappings": [
        {
          "containerPort": 8000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "DEPLOYMENT_TYPE",
          "value": "self_hosted_data_plane"
        },
        {
          "name": "LICENSE_KEY",
          "value": "your_license_key"
        }
      ],
      "secrets": [
        {
          "name": "POSTGRES_URL",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:postgres-url"
        },
        {
          "name": "REDIS_URL",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:redis-url"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/langgraph-data-plane",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

#### 2. 服务配置
```json
{
  "serviceName": "langgraph-data-plane",
  "cluster": "langgraph-cluster",
  "taskDefinition": "langgraph-data-plane",
  "desiredCount": 2,
  "launchType": "FARGATE",
  "networkConfiguration": {
    "awsvpcConfiguration": {
      "subnets": ["subnet-12345", "subnet-67890"],
      "securityGroups": ["sg-langgraph"],
      "assignPublicIp": "ENABLED"
    }
  },
  "loadBalancers": [
    {
      "targetGroupArn": "arn:aws:elasticloadbalancing:region:account:targetgroup/langgraph-tg",
      "containerName": "langgraph-server",
      "containerPort": 8000
    }
  ]
}
```

## Self-Hosted Control Plane

### 架构概述
- **完全自托管**：控制平面和数据平面都在你的环境
- **最高安全性**：所有数据和控制都在内部
- **适用场景**：严格合规要求、完全控制需求

### 部署准备
```bash
# 系统要求
- Kubernetes 1.21+
- 最少 4 vCPU, 8GB RAM
- 持久化存储 50GB+
- 负载均衡器
- SSL/TLS 证书
```

### Kubernetes 部署

#### 1. 部署 PostgreSQL
```yaml
# postgres.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: langgraph
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        env:
        - name: POSTGRES_DB
          value: "langgraph"
        - name: POSTGRES_USER
          value: "langgraph"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "gp2"
      resources:
        requests:
          storage: 20Gi
```

#### 2. 部署 Redis
```yaml
# redis.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: langgraph
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        volumeMounts:
        - name: redis-storage
          mountPath: /data
      volumes:
      - name: redis-storage
        persistentVolumeClaim:
          claimName: redis-pvc
```

#### 3. 部署控制平面
```yaml
# control-plane.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: langgraph-control-plane
  namespace: langgraph
spec:
  replicas: 2
  selector:
    matchLabels:
      app: langgraph-control-plane
  template:
    metadata:
      labels:
        app: langgraph-control-plane
    spec:
      containers:
      - name: control-plane
        image: langgraph/langgraph-control-plane:latest
        env:
        - name: DEPLOYMENT_TYPE
          value: "self_hosted_control_plane"
        - name: LICENSE_KEY
          valueFrom:
            secretKeyRef:
              name: langgraph-license
              key: license-key
        - name: POSTGRES_URL
          value: "postgresql://langgraph:$(POSTGRES_PASSWORD)@postgres:5432/langgraph"
        - name: REDIS_URL
          value: "redis://redis:6379"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        ports:
        - containerPort: 8000
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
```

#### 4. 部署数据平面
```yaml
# data-plane.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: langgraph-data-plane
  namespace: langgraph
spec:
  replicas: 3
  selector:
    matchLabels:
      app: langgraph-data-plane
  template:
    metadata:
      labels:
        app: langgraph-data-plane
    spec:
      containers:
      - name: data-plane
        image: langgraph/langgraph-server:latest
        env:
        - name: DEPLOYMENT_TYPE
          value: "self_hosted_control_plane"
        - name: CONTROL_PLANE_URL
          value: "http://langgraph-control-plane:8000"
        - name: POSTGRES_URL
          value: "postgresql://langgraph:$(POSTGRES_PASSWORD)@postgres:5432/langgraph"
        - name: REDIS_URL
          value: "redis://redis:6379"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        ports:
        - containerPort: 8000
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
```

## Standalone Container

### 概述
- **最简部署**：单容器包含所有组件
- **无控制平面**：直接 API 访问
- **适用场景**：简单部署、开发测试、小规模生产

### Docker Compose 部署

#### 1. 项目结构
```
standalone-deployment/
├── docker-compose.yml
├── langgraph.json
├── requirements.txt
├── .env
├── src/
│   └── my_agent/
│       ├── __init__.py
│       ├── graph.py
│       └── state.py
└── data/
    ├── postgres/
    └── redis/
```

#### 2. Docker Compose 配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: langgraph
      POSTGRES_USER: langgraph
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U langgraph"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  langgraph:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      - POSTGRES_URL=postgresql://langgraph:${POSTGRES_PASSWORD}@postgres:5432/langgraph
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - LANGCHAIN_TRACING_V2=${LANGCHAIN_TRACING_V2}
      - LANGCHAIN_API_KEY=${LANGCHAIN_API_KEY}
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./src:/app/src
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

#### 3. Dockerfile
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
COPY langgraph.json .

# 安装 Python 依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY src/ ./src/

# 暴露端口
EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# 启动应用
CMD ["langgraph", "run", "--host", "0.0.0.0", "--port", "8000"]
```

#### 4. 环境变量
```bash
# .env
POSTGRES_PASSWORD=your_secure_password
OPENAI_API_KEY=sk-your_openai_api_key
LANGCHAIN_TRACING_V2=true
LANGCHAIN_API_KEY=your_langsmith_key
LANGCHAIN_PROJECT=standalone-deployment
```

#### 5. 部署执行
```bash
# 构建并启动服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f langgraph

# 停止服务
docker-compose down

# 完全清理（包括数据）
docker-compose down -v
```

### 单容器部署

#### 1. 简化的 Dockerfile
```dockerfile
# Dockerfile.standalone
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制配置和代码
COPY langgraph.json .
COPY src/ ./src/

# 环境变量
ENV PYTHONPATH=/app
ENV DEPLOYMENT_TYPE=standalone

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["python", "-m", "langgraph", "run", "--host", "0.0.0.0"]
```

#### 2. 构建和运行
```bash
# 构建镜像
docker build -f Dockerfile.standalone -t my-agent:latest .

# 运行容器
docker run -d \
  --name my-agent \
  -p 8000:8000 \
  -e OPENAI_API_KEY=sk-your_key \
  -e LANGCHAIN_TRACING_V2=true \
  -e LANGCHAIN_API_KEY=your_langsmith_key \
  my-agent:latest

# 查看日志
docker logs -f my-agent

# 停止容器
docker stop my-agent
docker rm my-agent
```

## 数据库配置

### PostgreSQL 优化
```sql
-- postgresql.conf 优化
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 4MB
maintenance_work_mem = 64MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200

-- 创建索引
CREATE INDEX CONCURRENTLY idx_threads_thread_id ON threads(thread_id);
CREATE INDEX CONCURRENTLY idx_checkpoints_thread_id ON checkpoints(thread_id);
CREATE INDEX CONCURRENTLY idx_checkpoints_timestamp ON checkpoints(created_at);
```

### Redis 配置
```conf
# redis.conf
maxmemory 512mb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
appendonly yes
appendfsync everysec
```

## 监控配置

### Prometheus 监控
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'langgraph'
    static_configs:
      - targets: ['langgraph:8000']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

### Grafana 仪表板
```json
{
  "dashboard": {
    "title": "LangGraph Metrics",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "Requests/sec"
          }
        ]
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      }
    ]
  }
}
```

## 安全配置

### 网络安全
```yaml
# network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: langgraph-network-policy
  namespace: langgraph
spec:
  podSelector:
    matchLabels:
      app: langgraph-data-plane
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8000
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
```

### RBAC 配置
```yaml
# rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: langgraph-service-account
  namespace: langgraph

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: langgraph
  name: langgraph-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: langgraph-role-binding
  namespace: langgraph
subjects:
- kind: ServiceAccount
  name: langgraph-service-account
  namespace: langgraph
roleRef:
  kind: Role
  name: langgraph-role
  apiGroup: rbac.authorization.k8s.io
```

## 备份与恢复

### 数据库备份
```bash
#!/bin/bash
# backup.sh

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"

# PostgreSQL 备份
kubectl exec -n langgraph postgres-0 -- pg_dump \
  -U langgraph langgraph > ${BACKUP_DIR}/postgres_${TIMESTAMP}.sql

# Redis 备份
kubectl exec -n langgraph redis-0 -- redis-cli BGSAVE
kubectl cp langgraph/redis-0:/data/dump.rdb ${BACKUP_DIR}/redis_${TIMESTAMP}.rdb

echo "备份完成: ${TIMESTAMP}"
```

### 数据恢复
```bash
#!/bin/bash
# restore.sh

BACKUP_FILE=$1

if [[ $BACKUP_FILE == *.sql ]]; then
  # 恢复 PostgreSQL
  kubectl exec -i -n langgraph postgres-0 -- psql -U langgraph langgraph < $BACKUP_FILE
elif [[ $BACKUP_FILE == *.rdb ]]; then
  # 恢复 Redis
  kubectl cp $BACKUP_FILE langgraph/redis-0:/data/dump.rdb
  kubectl delete pod -n langgraph redis-0
fi

echo "恢复完成: $BACKUP_FILE"
```

## 故障排除

### 常见问题

#### 1. 许可证验证失败
```bash
# 错误：INVALID_LICENSE
# 解决方案：
# 1. 检查许可证密钥格式
# 2. 验证网络连接到许可证服务器
# 3. 确保许可证未过期
```

#### 2. 数据库连接失败
```bash
# 检查 PostgreSQL 状态
kubectl get pods -n langgraph | grep postgres

# 查看 PostgreSQL 日志
kubectl logs -n langgraph postgres-0

# 测试连接
kubectl exec -it -n langgraph postgres-0 -- psql -U langgraph
```

#### 3. Redis 连接问题
```bash
# 检查 Redis 状态
kubectl get pods -n langgraph | grep redis

# 测试 Redis 连接
kubectl exec -it -n langgraph redis-0 -- redis-cli ping
```

### 调试工具

#### 1. 日志收集
```bash
# 收集所有组件日志
kubectl logs -n langgraph --selector=app=langgraph-data-plane --tail=1000

# 实时查看日志
kubectl logs -f -n langgraph deployment/langgraph-data-plane
```

#### 2. 性能分析
```bash
# 查看资源使用
kubectl top pods -n langgraph

# 查看节点资源
kubectl top nodes

# 检查存储使用
kubectl get pvc -n langgraph
```

## 下一步

- 📊 学习 [04-监控与追踪](./04-监控与追踪.md) - 生产级监控方案
- 🚀 探索 [05-扩展性与韧性](./05-扩展性与韧性.md) - 高可用架构设计
- 🔐 了解 [07-认证与授权](./07-认证与授权.md) - 企业级安全控制

## 相关链接

- [Self-Hosted Data Plane 部署](https://langchain-ai.github.io/langgraph/cloud/deployment/self_hosted_data_plane/)
- [Self-Hosted Control Plane 部署](https://langchain-ai.github.io/langgraph/cloud/deployment/self_hosted_control_plane/)
- [Standalone Container 部署](https://langchain-ai.github.io/langgraph/cloud/deployment/standalone_container/)
- [部署选项对比](https://langchain-ai.github.io/langgraph/concepts/deployment_options/)
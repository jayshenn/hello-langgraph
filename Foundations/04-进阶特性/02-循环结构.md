# 02-å¾ªç¯ç»“æ„

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š
- LangGraph ä¸­å¾ªç¯å›¾çš„è®¾è®¡åŸåˆ™
- å¦‚ä½•å®‰å…¨åœ°å®ç°å¾ªç¯é€»è¾‘
- é€’å½’é™åˆ¶çš„å¤„ç†å’Œé…ç½®
- å¾ªç¯æ€§èƒ½ä¼˜åŒ–æŠ€å·§

## ğŸ“š å‰ç½®çŸ¥è¯†å›é¡¾

åœ¨åŸºç¡€æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¹ äº†ç®€å•çš„å¾ªç¯ç»“æ„ï¼ˆGraph V - Loopingï¼‰ï¼š

```python
# åŸºç¡€å¾ªç¯ç»“æ„
def should_continue(state):
    return "continue" if condition else END

graph.add_conditional_edges(
    "work_node",
    should_continue,
    {
        "continue": "work_node",  # æŒ‡å‘è‡ªå·±å½¢æˆå¾ªç¯
        END: END
    }
)
```

## ğŸ”„ å¾ªç¯ç»“æ„çš„ç±»å‹

### 1. è‡ªå¾ªç¯ï¼ˆSelf-Loopï¼‰

æœ€ç®€å•çš„å¾ªç¯å½¢å¼ï¼ŒèŠ‚ç‚¹æŒ‡å‘è‡ªå·±ï¼š

```python
def self_loop_example(state: AgentState) -> AgentState:
    """è‡ªå¾ªç¯èŠ‚ç‚¹ç¤ºä¾‹"""
    attempts = state.get("attempts", 0)
    max_attempts = state.get("max_attempts", 5)

    # å¤„ç†ä¸šåŠ¡é€»è¾‘
    result = process_task(state.get("task"))

    # æ›´æ–°çŠ¶æ€
    state["attempts"] = attempts + 1
    state["last_result"] = result

    # æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­
    if result.success:
        state["status"] = "completed"
    elif attempts >= max_attempts:
        state["status"] = "failed"
    else:
        state["status"] = "continue"

    return state

def should_continue_self_loop(state: AgentState) -> str:
    """è‡ªå¾ªç¯çš„æ¡ä»¶åˆ¤æ–­"""
    status = state.get("status", "continue")

    if status == "completed":
        return "success"
    elif status == "failed":
        return "failure"
    else:
        return "continue"

# æ„å»ºè‡ªå¾ªç¯å›¾
graph.add_node("processor", self_loop_example)
graph.add_conditional_edges(
    "processor",
    should_continue_self_loop,
    {
        "continue": "processor",    # è‡ªå¾ªç¯
        "success": "success_node",
        "failure": "failure_node"
    }
)
```

### 2. å¤šèŠ‚ç‚¹å¾ªç¯

åœ¨å¤šä¸ªèŠ‚ç‚¹ä¹‹é—´å½¢æˆå¾ªç¯ï¼š

```python
def multi_node_cycle_example():
    """å¤šèŠ‚ç‚¹å¾ªç¯ç¤ºä¾‹ï¼šåˆ†æ -> å¤„ç† -> éªŒè¯ -> åˆ†æ"""

    def analyze_node(state: AgentState) -> AgentState:
        """åˆ†æèŠ‚ç‚¹"""
        data = state.get("data")
        analysis_result = analyze_data(data)

        state["analysis"] = analysis_result
        state["phase"] = "analyzed"
        return state

    def process_node(state: AgentState) -> AgentState:
        """å¤„ç†èŠ‚ç‚¹"""
        analysis = state.get("analysis")
        processed_data = process_based_on_analysis(analysis)

        state["processed_data"] = processed_data
        state["phase"] = "processed"
        return state

    def validate_node(state: AgentState) -> AgentState:
        """éªŒè¯èŠ‚ç‚¹"""
        processed_data = state.get("processed_data")
        validation_result = validate_data(processed_data)

        state["validation"] = validation_result
        state["phase"] = "validated"

        # å¾ªç¯è®¡æ•°å™¨
        cycle_count = state.get("cycle_count", 0)
        state["cycle_count"] = cycle_count + 1

        return state

    def cycle_router(state: AgentState) -> str:
        """å¾ªç¯è·¯ç”±å†³ç­–"""
        validation = state.get("validation", {})
        cycle_count = state.get("cycle_count", 0)
        max_cycles = state.get("max_cycles", 3)

        if validation.get("is_valid", False):
            return "complete"
        elif cycle_count >= max_cycles:
            return "max_cycles_reached"
        else:
            return "reanalyze"

    # æ„å»ºå¤šèŠ‚ç‚¹å¾ªç¯å›¾
    graph = StateGraph(AgentState)
    graph.add_node("analyze", analyze_node)
    graph.add_node("process", process_node)
    graph.add_node("validate", validate_node)
    graph.add_node("complete", lambda state: state)
    graph.add_node("failed", lambda state: state)

    # çº¿æ€§æµç¨‹
    graph.add_edge("analyze", "process")
    graph.add_edge("process", "validate")

    # æ¡ä»¶å¾ªç¯
    graph.add_conditional_edges(
        "validate",
        cycle_router,
        {
            "reanalyze": "analyze",     # å›åˆ°å¼€å§‹å½¢æˆå¾ªç¯
            "complete": "complete",
            "max_cycles_reached": "failed"
        }
    )

    return graph
```

### 3. åµŒå¥—å¾ªç¯

å¤–å±‚å¾ªç¯åŒ…å«å†…å±‚å¾ªç¯ï¼š

```python
def nested_loops_example():
    """åµŒå¥—å¾ªç¯ç¤ºä¾‹"""

    def outer_loop_node(state: AgentState) -> AgentState:
        """å¤–å±‚å¾ªç¯èŠ‚ç‚¹"""
        outer_count = state.get("outer_count", 0)
        state["outer_count"] = outer_count + 1
        state["inner_count"] = 0  # é‡ç½®å†…å±‚è®¡æ•°å™¨
        state["phase"] = "outer_processing"
        return state

    def inner_loop_node(state: AgentState) -> AgentState:
        """å†…å±‚å¾ªç¯èŠ‚ç‚¹"""
        inner_count = state.get("inner_count", 0)
        state["inner_count"] = inner_count + 1
        state["phase"] = "inner_processing"

        # æ¨¡æ‹Ÿå†…å±‚å¤„ç†
        result = f"Inner iteration {inner_count}"
        state.setdefault("inner_results", []).append(result)

        return state

    def inner_loop_condition(state: AgentState) -> str:
        """å†…å±‚å¾ªç¯æ¡ä»¶"""
        inner_count = state.get("inner_count", 0)
        max_inner = state.get("max_inner_iterations", 3)

        if inner_count < max_inner:
            return "continue_inner"
        else:
            return "inner_complete"

    def outer_loop_condition(state: AgentState) -> str:
        """å¤–å±‚å¾ªç¯æ¡ä»¶"""
        outer_count = state.get("outer_count", 0)
        max_outer = state.get("max_outer_iterations", 2)

        if outer_count < max_outer:
            return "continue_outer"
        else:
            return "all_complete"

    return graph
```

## âš¡ å¾ªç¯æ€§èƒ½ä¼˜åŒ–

### 1. å¾ªç¯çŠ¶æ€ç®¡ç†

```python
class LoopStateManager:
    """å¾ªç¯çŠ¶æ€ç®¡ç†å™¨"""

    @staticmethod
    def initialize_loop(state: AgentState, loop_name: str, max_iterations: int = 10):
        """åˆå§‹åŒ–å¾ªç¯çŠ¶æ€"""
        loop_key = f"{loop_name}_loop_info"
        state[loop_key] = {
            "current_iteration": 0,
            "max_iterations": max_iterations,
            "start_time": time.time(),
            "iteration_times": [],
            "status": "running"
        }
        return state

    @staticmethod
    def update_loop(state: AgentState, loop_name: str):
        """æ›´æ–°å¾ªç¯çŠ¶æ€"""
        loop_key = f"{loop_name}_loop_info"
        loop_info = state.get(loop_key, {})

        current_time = time.time()
        loop_info["current_iteration"] += 1

        # è®°å½•è¿­ä»£æ—¶é—´
        if loop_info.get("last_iteration_time"):
            iteration_duration = current_time - loop_info["last_iteration_time"]
            loop_info["iteration_times"].append(iteration_duration)

        loop_info["last_iteration_time"] = current_time

        # æ£€æŸ¥æ˜¯å¦è¶…æ—¶æˆ–è¶…è¿‡æœ€å¤§è¿­ä»£æ¬¡æ•°
        total_time = current_time - loop_info["start_time"]
        max_time = loop_info.get("max_time", 300)  # 5åˆ†é’Ÿé»˜è®¤è¶…æ—¶

        if loop_info["current_iteration"] >= loop_info["max_iterations"]:
            loop_info["status"] = "max_iterations_reached"
        elif total_time > max_time:
            loop_info["status"] = "timeout"
        else:
            loop_info["status"] = "running"

        state[loop_key] = loop_info
        return state

    @staticmethod
    def should_continue_loop(state: AgentState, loop_name: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥ç»§ç»­å¾ªç¯"""
        loop_key = f"{loop_name}_loop_info"
        loop_info = state.get(loop_key, {})
        return loop_info.get("status") == "running"

    @staticmethod
    def get_loop_stats(state: AgentState, loop_name: str) -> dict:
        """è·å–å¾ªç¯ç»Ÿè®¡ä¿¡æ¯"""
        loop_key = f"{loop_name}_loop_info"
        loop_info = state.get(loop_key, {})

        if not loop_info.get("iteration_times"):
            return loop_info

        iteration_times = loop_info["iteration_times"]
        stats = {
            **loop_info,
            "average_iteration_time": sum(iteration_times) / len(iteration_times),
            "max_iteration_time": max(iteration_times),
            "min_iteration_time": min(iteration_times),
            "total_execution_time": time.time() - loop_info.get("start_time", time.time())
        }
        return stats
```

### 2. æ™ºèƒ½å¾ªç¯æ§åˆ¶

```python
def intelligent_loop_controller(state: AgentState) -> str:
    """æ™ºèƒ½å¾ªç¯æ§åˆ¶å™¨"""

    # æ£€æŸ¥åŸºæœ¬å¾ªç¯æ¡ä»¶
    loop_manager = LoopStateManager()
    if not loop_manager.should_continue_loop(state, "main"):
        return "exit_loop"

    # æ£€æŸ¥ä¸šåŠ¡é€»è¾‘æ¡ä»¶
    quality_score = state.get("quality_score", 0.0)
    improvement_threshold = state.get("improvement_threshold", 0.01)

    # è·å–å¾ªç¯ç»Ÿè®¡
    loop_stats = loop_manager.get_loop_stats(state, "main")
    iteration_times = loop_stats.get("iteration_times", [])

    # æ™ºèƒ½é€€å‡ºæ¡ä»¶
    if len(iteration_times) >= 3:
        # æ£€æŸ¥æ˜¯å¦æ”¶æ•›ï¼ˆè¿ç»­å‡ æ¬¡æ”¹è¿›å¾ˆå°ï¼‰
        recent_improvements = []
        for i in range(len(iteration_times) - 2):
            current_score = state.get("quality_history", [])[i + 1]
            previous_score = state.get("quality_history", [])[i]
            improvement = current_score - previous_score
            recent_improvements.append(improvement)

        if all(imp < improvement_threshold for imp in recent_improvements[-2:]):
            state["exit_reason"] = "converged"
            return "exit_loop"

    # æ£€æŸ¥æ€§èƒ½æ¶åŒ–
    if len(iteration_times) >= 2:
        if iteration_times[-1] > iteration_times[-2] * 1.5:
            state["exit_reason"] = "performance_degradation"
            return "exit_loop"

    # ç»§ç»­å¾ªç¯
    return "continue_loop"
```

## ğŸ›¡ï¸ å¾ªç¯å®‰å…¨æœºåˆ¶

### 1. é€’å½’é™åˆ¶å¤„ç†

```python
def configure_recursion_limit():
    """é…ç½®é€’å½’é™åˆ¶"""

    # æ–¹æ³•1ï¼šåœ¨å›¾ç¼–è¯‘æ—¶è®¾ç½®
    app = graph.compile(
        checkpointer=checkpointer,
        recursion_limit=50  # è®¾ç½®é€’å½’é™åˆ¶
    )

    # æ–¹æ³•2ï¼šåœ¨è¿è¡Œæ—¶åŠ¨æ€è®¾ç½®
    config = {
        "recursion_limit": 100,
        "max_execution_time": 300  # 5åˆ†é’Ÿè¶…æ—¶
    }

    result = app.invoke(initial_state, config=config)
    return result

def safe_recursive_node(state: AgentState) -> AgentState:
    """å®‰å…¨çš„é€’å½’èŠ‚ç‚¹"""
    # æ£€æŸ¥é€’å½’æ·±åº¦
    recursion_depth = state.get("recursion_depth", 0)
    max_depth = state.get("max_recursion_depth", 20)

    if recursion_depth >= max_depth:
        state["error"] = "Max recursion depth reached"
        state["should_exit"] = True
        return state

    # æ›´æ–°é€’å½’æ·±åº¦
    state["recursion_depth"] = recursion_depth + 1

    # æ‰§è¡Œå®é™…é€»è¾‘
    try:
        result = perform_recursive_operation(state)
        state.update(result)
    except Exception as e:
        state["error"] = str(e)
        state["should_exit"] = True

    return state
```

### 2. æ­»é”æ£€æµ‹

```python
class DeadlockDetector:
    """æ­»é”æ£€æµ‹å™¨"""

    def __init__(self, max_same_state_count: int = 3):
        self.state_history = []
        self.max_same_state_count = max_same_state_count

    def check_deadlock(self, state: AgentState) -> bool:
        """æ£€æµ‹æ˜¯å¦å‡ºç°æ­»é”"""
        # åˆ›å»ºçŠ¶æ€æŒ‡çº¹
        state_fingerprint = self._create_state_fingerprint(state)

        # æ·»åŠ åˆ°å†å²
        self.state_history.append(state_fingerprint)

        # ä¿æŒå†å²é•¿åº¦åˆç†
        if len(self.state_history) > 10:
            self.state_history.pop(0)

        # æ£€æŸ¥é‡å¤çŠ¶æ€
        same_state_count = self.state_history.count(state_fingerprint)

        if same_state_count >= self.max_same_state_count:
            return True

        return False

    def _create_state_fingerprint(self, state: AgentState) -> str:
        """åˆ›å»ºçŠ¶æ€æŒ‡çº¹"""
        # é€‰æ‹©å…³é”®å­—æ®µåˆ›å»ºæŒ‡çº¹
        key_fields = ["user_input", "current_task", "intent", "context_hash"]
        fingerprint_data = {}

        for field in key_fields:
            if field in state:
                fingerprint_data[field] = state[field]

        # åˆ›å»ºå“ˆå¸Œ
        import hashlib
        import json
        state_str = json.dumps(fingerprint_data, sort_keys=True)
        return hashlib.md5(state_str.encode()).hexdigest()

def deadlock_safe_router(state: AgentState) -> str:
    """é˜²æ­»é”è·¯ç”±å™¨"""
    # è·å–æˆ–åˆ›å»ºæ­»é”æ£€æµ‹å™¨
    if "deadlock_detector" not in state:
        state["deadlock_detector"] = DeadlockDetector()

    detector = state["deadlock_detector"]

    # æ£€æµ‹æ­»é”
    if detector.check_deadlock(state):
        state["exit_reason"] = "deadlock_detected"
        return "emergency_exit"

    # æ­£å¸¸è·¯ç”±é€»è¾‘
    if state.get("task_completed", False):
        return "success"
    elif state.get("should_retry", False):
        return "retry"
    else:
        return "continue"
```

## ğŸ“Š å¾ªç¯ç›‘æ§å’Œè°ƒè¯•

### 1. å¾ªç¯æ€§èƒ½ç›‘æ§

```python
class LoopMonitor:
    """å¾ªç¯æ€§èƒ½ç›‘æ§å™¨"""

    def __init__(self):
        self.metrics = {
            "total_iterations": 0,
            "total_time": 0,
            "iteration_times": [],
            "memory_usage": [],
            "error_count": 0,
            "warning_count": 0
        }

    def start_iteration(self):
        """å¼€å§‹è¿­ä»£ç›‘æ§"""
        self.iteration_start_time = time.time()

    def end_iteration(self, state: AgentState):
        """ç»“æŸè¿­ä»£ç›‘æ§"""
        iteration_time = time.time() - self.iteration_start_time

        self.metrics["total_iterations"] += 1
        self.metrics["total_time"] += iteration_time
        self.metrics["iteration_times"].append(iteration_time)

        # è®°å½•å†…å­˜ä½¿ç”¨
        import psutil
        memory_usage = psutil.Process().memory_info().rss / 1024 / 1024  # MB
        self.metrics["memory_usage"].append(memory_usage)

        # æ£€æŸ¥é”™è¯¯å’Œè­¦å‘Š
        if state.get("error"):
            self.metrics["error_count"] += 1
        if state.get("warning"):
            self.metrics["warning_count"] += 1

        # æ€§èƒ½è­¦å‘Š
        if iteration_time > 10:  # è¶…è¿‡10ç§’
            import logging
            logging.warning(f"Slow iteration detected: {iteration_time:.2f}s")

        if memory_usage > 1000:  # è¶…è¿‡1GB
            logging.warning(f"High memory usage: {memory_usage:.2f}MB")

    def get_report(self) -> dict:
        """ç”Ÿæˆç›‘æ§æŠ¥å‘Š"""
        if not self.metrics["iteration_times"]:
            return self.metrics

        iteration_times = self.metrics["iteration_times"]
        memory_usage = self.metrics["memory_usage"]

        report = {
            **self.metrics,
            "average_iteration_time": sum(iteration_times) / len(iteration_times),
            "max_iteration_time": max(iteration_times),
            "min_iteration_time": min(iteration_times),
            "average_memory_usage": sum(memory_usage) / len(memory_usage),
            "peak_memory_usage": max(memory_usage),
            "iterations_per_second": len(iteration_times) / max(sum(iteration_times), 0.001)
        }

        return report

def monitored_loop_node(state: AgentState) -> AgentState:
    """å¸¦ç›‘æ§çš„å¾ªç¯èŠ‚ç‚¹"""
    # è·å–æˆ–åˆ›å»ºç›‘æ§å™¨
    if "loop_monitor" not in state:
        state["loop_monitor"] = LoopMonitor()

    monitor = state["loop_monitor"]
    monitor.start_iteration()

    try:
        # æ‰§è¡Œå®é™…çš„ä¸šåŠ¡é€»è¾‘
        result = execute_business_logic(state)
        state.update(result)

    except Exception as e:
        state["error"] = str(e)
        import logging
        logging.error(f"Loop iteration error: {e}")

    finally:
        monitor.end_iteration(state)

    return state
```

### 2. å¾ªç¯å¯è§†åŒ–

```python
def visualize_loop_execution(state: AgentState):
    """å¯è§†åŒ–å¾ªç¯æ‰§è¡Œè¿‡ç¨‹"""
    import matplotlib.pyplot as plt

    # è·å–ç›‘æ§æ•°æ®
    monitor = state.get("loop_monitor")
    if not monitor:
        return

    report = monitor.get_report()

    # åˆ›å»ºå›¾è¡¨
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))

    # è¿­ä»£æ—¶é—´è¶‹åŠ¿
    axes[0, 0].plot(report["iteration_times"])
    axes[0, 0].set_title("Iteration Time Trend")
    axes[0, 0].set_xlabel("Iteration")
    axes[0, 0].set_ylabel("Time (seconds)")

    # å†…å­˜ä½¿ç”¨è¶‹åŠ¿
    axes[0, 1].plot(report["memory_usage"])
    axes[0, 1].set_title("Memory Usage Trend")
    axes[0, 1].set_xlabel("Iteration")
    axes[0, 1].set_ylabel("Memory (MB)")

    # æ€§èƒ½ç»Ÿè®¡
    stats_data = [
        report["average_iteration_time"],
        report["max_iteration_time"],
        report["min_iteration_time"]
    ]
    axes[1, 0].bar(["Avg", "Max", "Min"], stats_data)
    axes[1, 0].set_title("Iteration Time Statistics")
    axes[1, 0].set_ylabel("Time (seconds)")

    # é”™è¯¯ç»Ÿè®¡
    error_data = [
        report["error_count"],
        report["warning_count"],
        report["total_iterations"] - report["error_count"] - report["warning_count"]
    ]
    axes[1, 1].pie(error_data, labels=["Errors", "Warnings", "Success"], autopct='%1.1f%%')
    axes[1, 1].set_title("Execution Results")

    plt.tight_layout()
    plt.savefig("loop_execution_report.png")
    plt.close()

    print(f"Loop execution report saved as 'loop_execution_report.png'")
    print(f"Total iterations: {report['total_iterations']}")
    print(f"Average iteration time: {report['average_iteration_time']:.3f}s")
    print(f"Peak memory usage: {report['peak_memory_usage']:.2f}MB")
```

## ğŸ® å®è·µç»ƒä¹ 

### ç»ƒä¹  1ï¼šæ™ºèƒ½é‡è¯•å¾ªç¯

å®ç°ä¸€ä¸ªæ™ºèƒ½é‡è¯•ç³»ç»Ÿï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š
- æŒ‡æ•°é€€é¿é‡è¯•
- ä¸åŒé”™è¯¯ç±»å‹çš„ä¸åŒé‡è¯•ç­–ç•¥
- é‡è¯•æ¬¡æ•°é™åˆ¶

```python
def intelligent_retry_loop(state: AgentState) -> AgentState:
    """
    ç»ƒä¹ ï¼šå®ç°æ™ºèƒ½é‡è¯•å¾ªç¯

    è¦æ±‚ï¼š
    1. æ”¯æŒæŒ‡æ•°é€€é¿ï¼ˆ1s, 2s, 4s, 8s...ï¼‰
    2. ç½‘ç»œé”™è¯¯æœ€å¤šé‡è¯•5æ¬¡
    3. ä¸šåŠ¡é€»è¾‘é”™è¯¯æœ€å¤šé‡è¯•3æ¬¡
    4. ç³»ç»Ÿé”™è¯¯ä¸é‡è¯•
    """
    # TODO: å®ç°ä½ çš„é‡è¯•é€»è¾‘
    pass
```

### ç»ƒä¹  2ï¼šæ•°æ®å¤„ç†ç®¡é“å¾ªç¯

åˆ›å»ºä¸€ä¸ªæ•°æ®å¤„ç†ç®¡é“ï¼ŒåŒ…å«ï¼š
- æ•°æ®éªŒè¯
- æ•°æ®æ¸…æ´—
- æ•°æ®è½¬æ¢
- è´¨é‡æ£€æŸ¥
- å¦‚æœè´¨é‡ä¸è¾¾æ ‡ï¼Œé‡æ–°å¤„ç†

```python
def data_processing_pipeline(state: AgentState) -> AgentState:
    """
    ç»ƒä¹ ï¼šå®ç°æ•°æ®å¤„ç†ç®¡é“å¾ªç¯

    æµç¨‹ï¼š
    éªŒè¯ -> æ¸…æ´— -> è½¬æ¢ -> è´¨é‡æ£€æŸ¥ -> (å¦‚æœä¸åˆæ ¼) è¿”å›æ¸…æ´—
    """
    # TODO: å®ç°ä½ çš„ç®¡é“é€»è¾‘
    pass
```

## ğŸ”— ä¸å…¶ä»–ç‰¹æ€§çš„å…³ç³»

å¾ªç¯ç»“æ„æ˜¯æ„å»ºå¤æ‚ Agent ç³»ç»Ÿçš„åŸºç¡€ï¼š

- **ä¸æ¡ä»¶è·¯ç”±ç»“åˆ**ï¼šå®ç°å¤æ‚çš„å†³ç­–å¾ªç¯
- **ä¸ Memory ç»“åˆ**ï¼šåœ¨å¾ªç¯ä¸­ç§¯ç´¯å’Œä½¿ç”¨ç»éªŒ
- **ä¸ Human-in-the-Loop ç»“åˆ**ï¼šåœ¨å¾ªç¯ä¸­é€‚æ—¶è¯·æ±‚äººå·¥å¹²é¢„
- **ä¸å­å›¾ç»“åˆ**ï¼šåœ¨å¾ªç¯ä¸­è°ƒç”¨å­å›¾å¤„ç†å¤æ‚ä»»åŠ¡

## ğŸ“š æ¨èé˜…è¯»

- [LangGraph å®˜æ–¹æ–‡æ¡£ - Graph Recursion](https://langchain-ai.github.io/langgraph/troubleshooting/errors/GRAPH_RECURSION_LIMIT/)
- é¡¹ç›®ç¤ºä¾‹ï¼š`Graphs/05-Looping.ipynb`
- ç»ƒä¹ ï¼š`Exercises/Exercise_Graph5.ipynb`

---

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼šå­¦ä¹ å®Œå¾ªç¯ç»“æ„åï¼Œæˆ‘ä»¬å°†æ·±å…¥äº†è§£å­å›¾å’Œå¤š Agent ç³»ç»Ÿï¼Œæ¢ç´¢å¦‚ä½•æ„å»ºæ›´å¤æ‚çš„åˆ†å¸ƒå¼ AI åº”ç”¨ã€‚
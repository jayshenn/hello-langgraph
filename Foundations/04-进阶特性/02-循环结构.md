# 02-循环结构

## 🎯 学习目标

通过本章学习，你将掌握：
- LangGraph 中循环图的设计原则
- 如何安全地实现循环逻辑
- 递归限制的处理和配置
- 循环性能优化技巧

## 📚 前置知识回顾

在基础教程中，我们已经学习了简单的循环结构（Graph V - Looping）：

```python
# 基础循环结构
def should_continue(state):
    return "continue" if condition else END

graph.add_conditional_edges(
    "work_node",
    should_continue,
    {
        "continue": "work_node",  # 指向自己形成循环
        END: END
    }
)
```

## 🔄 循环结构的类型

### 1. 自循环（Self-Loop）

最简单的循环形式，节点指向自己：

```python
def self_loop_example(state: AgentState) -> AgentState:
    """自循环节点示例"""
    attempts = state.get("attempts", 0)
    max_attempts = state.get("max_attempts", 5)

    # 处理业务逻辑
    result = process_task(state.get("task"))

    # 更新状态
    state["attempts"] = attempts + 1
    state["last_result"] = result

    # 检查是否需要继续
    if result.success:
        state["status"] = "completed"
    elif attempts >= max_attempts:
        state["status"] = "failed"
    else:
        state["status"] = "continue"

    return state

def should_continue_self_loop(state: AgentState) -> str:
    """自循环的条件判断"""
    status = state.get("status", "continue")

    if status == "completed":
        return "success"
    elif status == "failed":
        return "failure"
    else:
        return "continue"

# 构建自循环图
graph.add_node("processor", self_loop_example)
graph.add_conditional_edges(
    "processor",
    should_continue_self_loop,
    {
        "continue": "processor",    # 自循环
        "success": "success_node",
        "failure": "failure_node"
    }
)
```

### 2. 多节点循环

在多个节点之间形成循环：

```python
def multi_node_cycle_example():
    """多节点循环示例：分析 -> 处理 -> 验证 -> 分析"""

    def analyze_node(state: AgentState) -> AgentState:
        """分析节点"""
        data = state.get("data")
        analysis_result = analyze_data(data)

        state["analysis"] = analysis_result
        state["phase"] = "analyzed"
        return state

    def process_node(state: AgentState) -> AgentState:
        """处理节点"""
        analysis = state.get("analysis")
        processed_data = process_based_on_analysis(analysis)

        state["processed_data"] = processed_data
        state["phase"] = "processed"
        return state

    def validate_node(state: AgentState) -> AgentState:
        """验证节点"""
        processed_data = state.get("processed_data")
        validation_result = validate_data(processed_data)

        state["validation"] = validation_result
        state["phase"] = "validated"

        # 循环计数器
        cycle_count = state.get("cycle_count", 0)
        state["cycle_count"] = cycle_count + 1

        return state

    def cycle_router(state: AgentState) -> str:
        """循环路由决策"""
        validation = state.get("validation", {})
        cycle_count = state.get("cycle_count", 0)
        max_cycles = state.get("max_cycles", 3)

        if validation.get("is_valid", False):
            return "complete"
        elif cycle_count >= max_cycles:
            return "max_cycles_reached"
        else:
            return "reanalyze"

    # 构建多节点循环图
    graph = StateGraph(AgentState)
    graph.add_node("analyze", analyze_node)
    graph.add_node("process", process_node)
    graph.add_node("validate", validate_node)
    graph.add_node("complete", lambda state: state)
    graph.add_node("failed", lambda state: state)

    # 线性流程
    graph.add_edge("analyze", "process")
    graph.add_edge("process", "validate")

    # 条件循环
    graph.add_conditional_edges(
        "validate",
        cycle_router,
        {
            "reanalyze": "analyze",     # 回到开始形成循环
            "complete": "complete",
            "max_cycles_reached": "failed"
        }
    )

    return graph
```

### 3. 嵌套循环

外层循环包含内层循环：

```python
def nested_loops_example():
    """嵌套循环示例"""

    def outer_loop_node(state: AgentState) -> AgentState:
        """外层循环节点"""
        outer_count = state.get("outer_count", 0)
        state["outer_count"] = outer_count + 1
        state["inner_count"] = 0  # 重置内层计数器
        state["phase"] = "outer_processing"
        return state

    def inner_loop_node(state: AgentState) -> AgentState:
        """内层循环节点"""
        inner_count = state.get("inner_count", 0)
        state["inner_count"] = inner_count + 1
        state["phase"] = "inner_processing"

        # 模拟内层处理
        result = f"Inner iteration {inner_count}"
        state.setdefault("inner_results", []).append(result)

        return state

    def inner_loop_condition(state: AgentState) -> str:
        """内层循环条件"""
        inner_count = state.get("inner_count", 0)
        max_inner = state.get("max_inner_iterations", 3)

        if inner_count < max_inner:
            return "continue_inner"
        else:
            return "inner_complete"

    def outer_loop_condition(state: AgentState) -> str:
        """外层循环条件"""
        outer_count = state.get("outer_count", 0)
        max_outer = state.get("max_outer_iterations", 2)

        if outer_count < max_outer:
            return "continue_outer"
        else:
            return "all_complete"

    return graph
```

## ⚡ 循环性能优化

### 1. 循环状态管理

```python
class LoopStateManager:
    """循环状态管理器"""

    @staticmethod
    def initialize_loop(state: AgentState, loop_name: str, max_iterations: int = 10):
        """初始化循环状态"""
        loop_key = f"{loop_name}_loop_info"
        state[loop_key] = {
            "current_iteration": 0,
            "max_iterations": max_iterations,
            "start_time": time.time(),
            "iteration_times": [],
            "status": "running"
        }
        return state

    @staticmethod
    def update_loop(state: AgentState, loop_name: str):
        """更新循环状态"""
        loop_key = f"{loop_name}_loop_info"
        loop_info = state.get(loop_key, {})

        current_time = time.time()
        loop_info["current_iteration"] += 1

        # 记录迭代时间
        if loop_info.get("last_iteration_time"):
            iteration_duration = current_time - loop_info["last_iteration_time"]
            loop_info["iteration_times"].append(iteration_duration)

        loop_info["last_iteration_time"] = current_time

        # 检查是否超时或超过最大迭代次数
        total_time = current_time - loop_info["start_time"]
        max_time = loop_info.get("max_time", 300)  # 5分钟默认超时

        if loop_info["current_iteration"] >= loop_info["max_iterations"]:
            loop_info["status"] = "max_iterations_reached"
        elif total_time > max_time:
            loop_info["status"] = "timeout"
        else:
            loop_info["status"] = "running"

        state[loop_key] = loop_info
        return state

    @staticmethod
    def should_continue_loop(state: AgentState, loop_name: str) -> bool:
        """检查是否应该继续循环"""
        loop_key = f"{loop_name}_loop_info"
        loop_info = state.get(loop_key, {})
        return loop_info.get("status") == "running"

    @staticmethod
    def get_loop_stats(state: AgentState, loop_name: str) -> dict:
        """获取循环统计信息"""
        loop_key = f"{loop_name}_loop_info"
        loop_info = state.get(loop_key, {})

        if not loop_info.get("iteration_times"):
            return loop_info

        iteration_times = loop_info["iteration_times"]
        stats = {
            **loop_info,
            "average_iteration_time": sum(iteration_times) / len(iteration_times),
            "max_iteration_time": max(iteration_times),
            "min_iteration_time": min(iteration_times),
            "total_execution_time": time.time() - loop_info.get("start_time", time.time())
        }
        return stats
```

### 2. 智能循环控制

```python
def intelligent_loop_controller(state: AgentState) -> str:
    """智能循环控制器"""

    # 检查基本循环条件
    loop_manager = LoopStateManager()
    if not loop_manager.should_continue_loop(state, "main"):
        return "exit_loop"

    # 检查业务逻辑条件
    quality_score = state.get("quality_score", 0.0)
    improvement_threshold = state.get("improvement_threshold", 0.01)

    # 获取循环统计
    loop_stats = loop_manager.get_loop_stats(state, "main")
    iteration_times = loop_stats.get("iteration_times", [])

    # 智能退出条件
    if len(iteration_times) >= 3:
        # 检查是否收敛（连续几次改进很小）
        recent_improvements = []
        for i in range(len(iteration_times) - 2):
            current_score = state.get("quality_history", [])[i + 1]
            previous_score = state.get("quality_history", [])[i]
            improvement = current_score - previous_score
            recent_improvements.append(improvement)

        if all(imp < improvement_threshold for imp in recent_improvements[-2:]):
            state["exit_reason"] = "converged"
            return "exit_loop"

    # 检查性能恶化
    if len(iteration_times) >= 2:
        if iteration_times[-1] > iteration_times[-2] * 1.5:
            state["exit_reason"] = "performance_degradation"
            return "exit_loop"

    # 继续循环
    return "continue_loop"
```

## 🛡️ 循环安全机制

### 1. 递归限制处理

```python
def configure_recursion_limit():
    """配置递归限制"""

    # 方法1：在图编译时设置
    app = graph.compile(
        checkpointer=checkpointer,
        recursion_limit=50  # 设置递归限制
    )

    # 方法2：在运行时动态设置
    config = {
        "recursion_limit": 100,
        "max_execution_time": 300  # 5分钟超时
    }

    result = app.invoke(initial_state, config=config)
    return result

def safe_recursive_node(state: AgentState) -> AgentState:
    """安全的递归节点"""
    # 检查递归深度
    recursion_depth = state.get("recursion_depth", 0)
    max_depth = state.get("max_recursion_depth", 20)

    if recursion_depth >= max_depth:
        state["error"] = "Max recursion depth reached"
        state["should_exit"] = True
        return state

    # 更新递归深度
    state["recursion_depth"] = recursion_depth + 1

    # 执行实际逻辑
    try:
        result = perform_recursive_operation(state)
        state.update(result)
    except Exception as e:
        state["error"] = str(e)
        state["should_exit"] = True

    return state
```

### 2. 死锁检测

```python
class DeadlockDetector:
    """死锁检测器"""

    def __init__(self, max_same_state_count: int = 3):
        self.state_history = []
        self.max_same_state_count = max_same_state_count

    def check_deadlock(self, state: AgentState) -> bool:
        """检测是否出现死锁"""
        # 创建状态指纹
        state_fingerprint = self._create_state_fingerprint(state)

        # 添加到历史
        self.state_history.append(state_fingerprint)

        # 保持历史长度合理
        if len(self.state_history) > 10:
            self.state_history.pop(0)

        # 检查重复状态
        same_state_count = self.state_history.count(state_fingerprint)

        if same_state_count >= self.max_same_state_count:
            return True

        return False

    def _create_state_fingerprint(self, state: AgentState) -> str:
        """创建状态指纹"""
        # 选择关键字段创建指纹
        key_fields = ["user_input", "current_task", "intent", "context_hash"]
        fingerprint_data = {}

        for field in key_fields:
            if field in state:
                fingerprint_data[field] = state[field]

        # 创建哈希
        import hashlib
        import json
        state_str = json.dumps(fingerprint_data, sort_keys=True)
        return hashlib.md5(state_str.encode()).hexdigest()

def deadlock_safe_router(state: AgentState) -> str:
    """防死锁路由器"""
    # 获取或创建死锁检测器
    if "deadlock_detector" not in state:
        state["deadlock_detector"] = DeadlockDetector()

    detector = state["deadlock_detector"]

    # 检测死锁
    if detector.check_deadlock(state):
        state["exit_reason"] = "deadlock_detected"
        return "emergency_exit"

    # 正常路由逻辑
    if state.get("task_completed", False):
        return "success"
    elif state.get("should_retry", False):
        return "retry"
    else:
        return "continue"
```

## 📊 循环监控和调试

### 1. 循环性能监控

```python
class LoopMonitor:
    """循环性能监控器"""

    def __init__(self):
        self.metrics = {
            "total_iterations": 0,
            "total_time": 0,
            "iteration_times": [],
            "memory_usage": [],
            "error_count": 0,
            "warning_count": 0
        }

    def start_iteration(self):
        """开始迭代监控"""
        self.iteration_start_time = time.time()

    def end_iteration(self, state: AgentState):
        """结束迭代监控"""
        iteration_time = time.time() - self.iteration_start_time

        self.metrics["total_iterations"] += 1
        self.metrics["total_time"] += iteration_time
        self.metrics["iteration_times"].append(iteration_time)

        # 记录内存使用
        import psutil
        memory_usage = psutil.Process().memory_info().rss / 1024 / 1024  # MB
        self.metrics["memory_usage"].append(memory_usage)

        # 检查错误和警告
        if state.get("error"):
            self.metrics["error_count"] += 1
        if state.get("warning"):
            self.metrics["warning_count"] += 1

        # 性能警告
        if iteration_time > 10:  # 超过10秒
            import logging
            logging.warning(f"Slow iteration detected: {iteration_time:.2f}s")

        if memory_usage > 1000:  # 超过1GB
            logging.warning(f"High memory usage: {memory_usage:.2f}MB")

    def get_report(self) -> dict:
        """生成监控报告"""
        if not self.metrics["iteration_times"]:
            return self.metrics

        iteration_times = self.metrics["iteration_times"]
        memory_usage = self.metrics["memory_usage"]

        report = {
            **self.metrics,
            "average_iteration_time": sum(iteration_times) / len(iteration_times),
            "max_iteration_time": max(iteration_times),
            "min_iteration_time": min(iteration_times),
            "average_memory_usage": sum(memory_usage) / len(memory_usage),
            "peak_memory_usage": max(memory_usage),
            "iterations_per_second": len(iteration_times) / max(sum(iteration_times), 0.001)
        }

        return report

def monitored_loop_node(state: AgentState) -> AgentState:
    """带监控的循环节点"""
    # 获取或创建监控器
    if "loop_monitor" not in state:
        state["loop_monitor"] = LoopMonitor()

    monitor = state["loop_monitor"]
    monitor.start_iteration()

    try:
        # 执行实际的业务逻辑
        result = execute_business_logic(state)
        state.update(result)

    except Exception as e:
        state["error"] = str(e)
        import logging
        logging.error(f"Loop iteration error: {e}")

    finally:
        monitor.end_iteration(state)

    return state
```

### 2. 循环可视化

```python
def visualize_loop_execution(state: AgentState):
    """可视化循环执行过程"""
    import matplotlib.pyplot as plt

    # 获取监控数据
    monitor = state.get("loop_monitor")
    if not monitor:
        return

    report = monitor.get_report()

    # 创建图表
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))

    # 迭代时间趋势
    axes[0, 0].plot(report["iteration_times"])
    axes[0, 0].set_title("Iteration Time Trend")
    axes[0, 0].set_xlabel("Iteration")
    axes[0, 0].set_ylabel("Time (seconds)")

    # 内存使用趋势
    axes[0, 1].plot(report["memory_usage"])
    axes[0, 1].set_title("Memory Usage Trend")
    axes[0, 1].set_xlabel("Iteration")
    axes[0, 1].set_ylabel("Memory (MB)")

    # 性能统计
    stats_data = [
        report["average_iteration_time"],
        report["max_iteration_time"],
        report["min_iteration_time"]
    ]
    axes[1, 0].bar(["Avg", "Max", "Min"], stats_data)
    axes[1, 0].set_title("Iteration Time Statistics")
    axes[1, 0].set_ylabel("Time (seconds)")

    # 错误统计
    error_data = [
        report["error_count"],
        report["warning_count"],
        report["total_iterations"] - report["error_count"] - report["warning_count"]
    ]
    axes[1, 1].pie(error_data, labels=["Errors", "Warnings", "Success"], autopct='%1.1f%%')
    axes[1, 1].set_title("Execution Results")

    plt.tight_layout()
    plt.savefig("loop_execution_report.png")
    plt.close()

    print(f"Loop execution report saved as 'loop_execution_report.png'")
    print(f"Total iterations: {report['total_iterations']}")
    print(f"Average iteration time: {report['average_iteration_time']:.3f}s")
    print(f"Peak memory usage: {report['peak_memory_usage']:.2f}MB")
```

## 🎮 实践练习

### 练习 1：智能重试循环

实现一个智能重试系统，具有以下特性：
- 指数退避重试
- 不同错误类型的不同重试策略
- 重试次数限制

```python
def intelligent_retry_loop(state: AgentState) -> AgentState:
    """
    练习：实现智能重试循环

    要求：
    1. 支持指数退避（1s, 2s, 4s, 8s...）
    2. 网络错误最多重试5次
    3. 业务逻辑错误最多重试3次
    4. 系统错误不重试
    """
    # TODO: 实现你的重试逻辑
    pass
```

### 练习 2：数据处理管道循环

创建一个数据处理管道，包含：
- 数据验证
- 数据清洗
- 数据转换
- 质量检查
- 如果质量不达标，重新处理

```python
def data_processing_pipeline(state: AgentState) -> AgentState:
    """
    练习：实现数据处理管道循环

    流程：
    验证 -> 清洗 -> 转换 -> 质量检查 -> (如果不合格) 返回清洗
    """
    # TODO: 实现你的管道逻辑
    pass
```

## 🔗 与其他特性的关系

循环结构是构建复杂 Agent 系统的基础：

- **与条件路由结合**：实现复杂的决策循环
- **与 Memory 结合**：在循环中积累和使用经验
- **与 Human-in-the-Loop 结合**：在循环中适时请求人工干预
- **与子图结合**：在循环中调用子图处理复杂任务

## 📚 推荐阅读

- [LangGraph 官方文档 - Graph Recursion](https://langchain-ai.github.io/langgraph/troubleshooting/errors/GRAPH_RECURSION_LIMIT/)
- 项目示例：`Graphs/05-Looping.ipynb`
- 练习：`Exercises/Exercise_Graph5.ipynb`

---

**下一章预告**：学习完循环结构后，我们将深入了解子图和多 Agent 系统，探索如何构建更复杂的分布式 AI 应用。
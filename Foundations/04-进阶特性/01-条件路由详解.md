# 01-条件路由详解

## 🎯 学习目标

通过本章学习，你将掌握：
- LangGraph 中条件路由的高级用法
- 设计复杂的路由函数
- 实现多条件组合路由
- 动态路由策略的应用场景

## 📚 前置知识回顾

在开始进阶内容之前，让我们回顾一下基础的条件路由：

```python
# 基础条件路由（来自 Graph IV）
graph.add_conditional_edges(
    "source_node",
    condition_function,  # 返回字符串键
    {
        "condition_result": "target_node",
        "other_result": END
    }
)
```

## 🔍 条件路由的本质

### 路由函数的工作原理

条件路由本质上是一个**决策树**，路由函数负责：
1. **接收当前状态**：分析 `AgentState` 中的数据
2. **执行决策逻辑**：基于业务规则做判断
3. **返回路由键**：指示下一步执行的节点

```python
def route_function(state: AgentState) -> str:
    """
    路由函数必须：
    1. 接收 state 参数
    2. 返回字符串（对应映射表中的键）
    3. 逻辑清晰，易于调试
    """
    # 分析状态
    user_input = state.get("user_input", "")
    confidence = state.get("confidence", 0.0)

    # 决策逻辑
    if confidence > 0.8:
        return "high_confidence"
    elif confidence > 0.5:
        return "medium_confidence"
    else:
        return "low_confidence"
```

## 🎨 高级路由模式

### 1. 多层条件路由

当单一条件不足以做决策时，可以使用多层条件：

```python
def complex_router(state: AgentState) -> str:
    """复杂的多层条件路由"""
    message_type = state.get("message_type")
    user_intent = state.get("user_intent")
    context_available = state.get("has_context", False)

    # 第一层：按消息类型分类
    if message_type == "query":
        # 第二层：按意图细分
        if user_intent == "information_seeking":
            return "search_knowledge" if context_available else "gather_context"
        elif user_intent == "task_execution":
            return "execute_task"
        else:
            return "clarify_intent"

    elif message_type == "feedback":
        return "process_feedback"

    else:
        return "default_handler"

# 使用多层路由
graph.add_conditional_edges(
    "classifier",
    complex_router,
    {
        "search_knowledge": "knowledge_search",
        "gather_context": "context_gathering",
        "execute_task": "task_executor",
        "clarify_intent": "intent_clarifier",
        "process_feedback": "feedback_processor",
        "default_handler": "fallback_node"
    }
)
```

### 2. 概率性路由

基于置信度或概率进行动态路由：

```python
import random

def probability_router(state: AgentState) -> str:
    """基于概率的路由决策"""
    predictions = state.get("model_predictions", {})

    # 获取最高置信度的预测
    if not predictions:
        return "fallback"

    best_prediction = max(predictions.items(), key=lambda x: x[1])
    confidence = best_prediction[1]

    # 基于置信度的路由策略
    if confidence > 0.9:
        return "direct_answer"
    elif confidence > 0.7:
        return "verify_answer"
    elif confidence > 0.4:
        # 中等置信度，考虑多种策略
        strategies = ["search_more", "ask_human", "use_fallback"]
        weights = [0.5, 0.3, 0.2]
        return random.choices(strategies, weights=weights)[0]
    else:
        return "request_clarification"
```

### 3. 状态历史路由

基于节点执行历史做决策：

```python
def history_aware_router(state: AgentState) -> str:
    """感知历史状态的路由"""
    execution_history = state.get("execution_history", [])
    current_attempts = state.get("retry_count", 0)
    last_error = state.get("last_error")

    # 避免无限循环
    if current_attempts >= 3:
        return "escalate_to_human"

    # 基于历史选择策略
    if "search_failed" in execution_history:
        if "alternative_search" not in execution_history:
            return "alternative_search"
        else:
            return "manual_research"

    # 基于错误类型路由
    if last_error:
        if "network" in str(last_error).lower():
            return "retry_with_backoff"
        elif "permission" in str(last_error).lower():
            return "request_permission"
        else:
            return "error_analysis"

    return "continue_normal_flow"
```

## 🔧 动态路由映射

### 运行时路由构建

有时路由映射需要根据状态动态构建：

```python
def build_dynamic_routes(state: AgentState) -> Dict[str, str]:
    """动态构建路由映射"""
    available_tools = state.get("available_tools", [])
    user_preferences = state.get("user_preferences", {})

    routes = {"fallback": "default_node"}

    # 根据可用工具动态添加路由
    for tool in available_tools:
        if tool == "web_search" and user_preferences.get("allow_web", True):
            routes["need_search"] = "web_search_node"
        elif tool == "database" and user_preferences.get("allow_db", True):
            routes["need_data"] = "database_node"
        elif tool == "calculator":
            routes["need_calculation"] = "calculator_node"

    return routes

# 在图构建时使用动态路由
def smart_conditional_edges(graph, source_node, route_func, state_sample):
    """智能条件边添加"""
    # 使用示例状态构建初始路由
    initial_routes = build_dynamic_routes(state_sample)

    graph.add_conditional_edges(
        source_node,
        route_func,
        initial_routes
    )
```

## 🚀 最佳实践

### 1. 路由函数设计原则

```python
def well_designed_router(state: AgentState) -> str:
    """设计良好的路由函数示例"""

    # ✅ 好的实践：
    # 1. 明确的默认分支
    default_route = "fallback"

    # 2. 空值检查
    if not state:
        return default_route

    # 3. 清晰的条件逻辑
    user_query = state.get("user_query", "").lower().strip()
    if not user_query:
        return "request_input"

    # 4. 可配置的阈值
    similarity_threshold = state.get("config", {}).get("similarity_threshold", 0.7)

    # 5. 详细的日志
    import logging
    logger = logging.getLogger(__name__)

    # 6. 异常处理
    try:
        similarity_score = calculate_similarity(user_query, state.get("context", ""))

        if similarity_score > similarity_threshold:
            logger.info(f"High similarity route chosen: {similarity_score}")
            return "contextual_response"
        else:
            logger.info(f"General route chosen: {similarity_score}")
            return "general_response"

    except Exception as e:
        logger.error(f"Router error: {e}")
        return default_route

def calculate_similarity(query: str, context: str) -> float:
    """计算相似度的辅助函数"""
    # 这里可以使用更复杂的相似度算法
    if not query or not context:
        return 0.0
    return len(set(query.split()) & set(context.split())) / len(set(query.split()))
```

### 2. 调试条件路由

```python
def debug_router(state: AgentState) -> str:
    """带调试功能的路由函数"""
    debug_info = {
        "input_state": dict(state),
        "timestamp": datetime.now().isoformat(),
        "route_decision": None,
        "decision_factors": {}
    }

    try:
        # 决策逻辑
        user_input = state.get("user_input", "")
        intent_confidence = state.get("intent_confidence", 0.0)

        debug_info["decision_factors"] = {
            "user_input_length": len(user_input),
            "intent_confidence": intent_confidence,
            "has_context": bool(state.get("context"))
        }

        if intent_confidence > 0.8:
            route = "high_confidence_path"
        elif len(user_input) > 100:
            route = "detailed_analysis_path"
        else:
            route = "standard_path"

        debug_info["route_decision"] = route

        # 保存调试信息到状态
        if "debug_history" not in state:
            state["debug_history"] = []
        state["debug_history"].append(debug_info)

        return route

    except Exception as e:
        debug_info["error"] = str(e)
        state.setdefault("debug_history", []).append(debug_info)
        return "error_path"
```

## 📊 性能优化

### 1. 路由函数性能

```python
import functools
import time

def performance_monitored_router(state: AgentState) -> str:
    """性能监控的路由函数"""
    start_time = time.time()

    # 缓存昂贵的计算
    @functools.lru_cache(maxsize=128)
    def expensive_calculation(input_text: str) -> float:
        # 模拟昂贵的计算（如 NLP 处理）
        time.sleep(0.1)  # 模拟处理时间
        return len(input_text) / 100.0

    try:
        user_input = state.get("user_input", "")

        # 使用缓存的计算结果
        score = expensive_calculation(user_input)

        route = "complex_path" if score > 0.5 else "simple_path"

        # 记录性能指标
        execution_time = time.time() - start_time
        if execution_time > 0.5:  # 超过500ms记录警告
            import logging
            logging.warning(f"Router execution time: {execution_time:.3f}s")

        return route

    except Exception as e:
        return "error_path"
```

### 2. 避免路由死锁

```python
def deadlock_safe_router(state: AgentState) -> str:
    """防止死锁的路由函数"""

    # 检查循环计数
    node_visit_count = state.get("node_visit_count", {})
    current_node = state.get("current_node", "unknown")

    # 更新访问计数
    node_visit_count[current_node] = node_visit_count.get(current_node, 0) + 1
    state["node_visit_count"] = node_visit_count

    # 检测潜在的无限循环
    max_visits = 5
    if node_visit_count.get(current_node, 0) > max_visits:
        # 强制退出循环
        return "exit_loop"

    # 检查总的节点访问次数
    total_visits = sum(node_visit_count.values())
    if total_visits > 50:  # 总访问次数限制
        return "force_exit"

    # 正常的路由逻辑
    user_intent = state.get("user_intent", "")

    if user_intent == "continue":
        return "next_step"
    elif user_intent == "retry":
        # 限制重试次数
        if node_visit_count.get("retry_node", 0) < 3:
            return "retry_node"
        else:
            return "give_up"
    else:
        return "default_next"
```

## 🎮 实践练习

### 练习 1：智能客服路由器

设计一个智能客服系统的路由器，需要根据用户问题的类型、紧急程度和用户等级进行路由：

```python
def customer_service_router(state: AgentState) -> str:
    """
    练习：实现客服路由逻辑

    路由规则：
    1. VIP用户 -> 专属服务
    2. 紧急问题 -> 优先处理
    3. 技术问题 -> 技术支持
    4. 账单问题 -> 财务部门
    5. 其他 -> 通用客服
    """
    # TODO: 实现你的路由逻辑
    pass
```

### 练习 2：多模态内容路由

创建一个能够处理文本、图片、音频的多模态路由器：

```python
def multimodal_router(state: AgentState) -> str:
    """
    练习：实现多模态路由

    需要处理：
    - 文本消息
    - 图片分析
    - 音频转文本
    - 组合内容
    """
    # TODO: 实现你的路由逻辑
    pass
```

## 🔗 与后续章节的联系

条件路由是 LangGraph 的核心机制之一，它为后续的高级特性提供了基础：

- **循环结构**：需要条件路由来控制循环的继续或退出
- **Human-in-the-Loop**：使用条件路由决定何时需要人工干预
- **子图通信**：条件路由控制子图之间的消息传递

## 📚 推荐阅读

- [LangGraph 官方文档 - Conditional Edges](https://langchain-ai.github.io/langgraph/how-tos/graph-api/)
- 项目示例：`Graphs/04-Conditional.ipynb`
- 练习：`Exercises/Exercise_Graph4.ipynb`

---

**下一章预告**：在掌握了高级条件路由后，我们将学习如何设计安全高效的循环结构，避免无限循环陷阱。